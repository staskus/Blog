<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Povilas Sta≈°kus</title><description>iOS Developer</description><link>https://www.staskus.io</link><language>en</language><lastBuildDate>Sun, 26 Jan 2020 11:20:17 +0200</lastBuildDate><pubDate>Sun, 26 Jan 2020 11:20:17 +0200</pubDate><ttl>250</ttl><atom:link href="https://www.staskus.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</guid><title>"Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views."</title><description></description><link>https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</link><pubDate>Sun, 24 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When starting to develop any application it's beneficial to think early about the way code can be testable and whether it would be scalable or maintainable. Many iOS applications have suffered from what is called <em>Massive View Controller</em> problem. By putting all the code that fetches, maps, presents and styles into one ViewController it very quickly overgrows in size and complexity. A lot of solutions where introduced to tackle this problem such as MVVM, MVVM + ReactiveCocoa or VIPER. In this application we'll be using <a href="https://clean-swift.com">Clean Swift</a> approach for breaking up massive view controllers into testable and maintainable parts.</p><h1>Data Structures</h1><h2>Data</h2><p><code>Struct</code> containing <em>raw data</em>.</p><pre><code class="language-swift">    struct Data: Equatable {
        let regions: [Region]
        let trips: [Trip]
    }
</code></pre><h2>View Model</h2><p><code>Struct</code> containing <em>State</em> (loading, error, empty, loaded) and mapped data that is used by <em>View Controllers</em> for configuring views.</p><pre><code class="language-swift">    struct ViewModel: FeatureViewModel {
        let state: ViewState&lt;Feed.ViewModel.Content&gt;
        let title: String

        struct Content: FeatureContentViewModel, Equatable {
            var rows: [FeedCardViewModel]
            let availableRegions: [Feed.ViewModel.Content.Region]
            let selectedRegion: Feed.ViewModel.Content.Region?

            struct Region: Equatable {
                let id: String
                let name: String
            }

            var hasContent: Bool {
                return !rows.isEmpty
            }
        }
    }
</code></pre><h2>Action</h2><p><code>Enum</code> with actions that <em>View Controller</em> can do and <em>Interactor</em> can handle.</p><pre><code class="language-swift">    enum Action {
        case load
        case changeRegion(regionId: String?)
    }
</code></pre><h2>Route</h2><p><code>Enum</code> with destinations that <em>View Controller</em> can route to.</p><pre><code class="language-swift">    enum Route: Equatable {
        case book(Trip)
    }
</code></pre><h1>Components</h1><h2>Interactor</h2><p>Receives an action, performs work and sends raw data to presenter.</p><ul><li>Input - <em>Action</em></li><li>Output - <em>Data</em></li><li>Uses - <em>Presenter</em></li></ul><h2>Presenter</h2><p>Receives raw data and maps it into <em>View Model</em></p><ul><li>Input - <em>Data</em></li><li>Output - <em>View Model</em></li></ul><h2>View Controller</h2><p>Receives <em>View Model</em> and configures a view according to it. Sends actions to <em>Interactor</em>.</p><ul><li>Input - <em>View Model</em></li><li>Output - <em>Action</em></li><li>Uses - <em>Interactor</em>, <em>Router</em></li></ul><h2>Router</h2><p>Receives <em>Route</em> object from <em>View Controller</em>, that contains information about next destination, and opens next <em>View Controller</em> using <em>Configurator</em></p><ul><li>Input - <em>Route</em></li><li>Uses - <em>Configurator</em></li></ul><h2>Configurator</h2><p>Takes an input and creates configured <em>View Controller</em> with other components.</p><ul><li>Input - Optional configuration data.</li><li>Output - <em>View Controller</em></li><li>Creates - <em>Interactor</em>, <em>Presenter</em>, <em>View Controller</em>, <em>Router</em></li></ul><h1>Feature</h1><p>The group of these components is called <code>Feature</code>. <a href="https://clean-swift.com">Clean Swift</a> provides with XCode templates that allow to generate all of these components together. We are using <a href="https://github.com/nitesuit/aerogami-ios/tree/master/templates/plop/Feature">plop templates</a> for feature generation. All of this allows to avoid writing boilerplate code and concentrate on actual code of the feature.</p><h1>Feed Example</h1><p><code>Feed</code> is a main <a href="https://github.com/nitesuit/aerogami-ios/tree/master/TravelFeatureKit/Features/Feed">feature</a> of the application. We're going to see how all of these different components is used to create a complete feature.</p><h2>Feed Interactor</h2><p><code>Feed Interactor</code> uses repositories of <em>Region</em>, <em>Trip</em> and <em>Airport</em> for loading data.</p><p><code>dispatch</code> function is an entry point of any <code>Interactor</code>.</p><pre><code class="language-swift">    func dispatch(_ action: Feed.Action) {
        switch action {
        case .load:
            contentState = .loading(data: contentState.data)
            load()
        case .changeRegion(let regionId):
            changeRegion(id: regionId)
        }
    }
</code></pre><p>We can see when <code>FeedInteractor</code> receives <em>load</em> action it sets current state to <em>loading</em> and calls <code>load()</code> method. It combines <code>RegionRepository</code> and <code>TripRepository</code>, maps it to <em>Data</em> object and passes it to <code>FeedPresenter</code> by setting <em>contentState</em>.</p><pre><code class="language-swift">    func load() {
        let selectedRegion = regionRepository.getSelectedRegion()

        Observable.combineLatest(
            self.regionRepository.getRegions(),
            self.tripRepository.getTrips(in: selectedRegion?.id)
            )
            .map { (regions, trips) -&gt; Feed.Data in
                return Feed.Data(
                    regions: regions,
                    trips: trips,
                    selectedRegionId: selectedRegion?.id,
                    tripImages: []
                )
            }
            .subscribe(
                onNext: { data in
                    self.contentState = .loaded(data: data, error: nil)
                    self.loadImages(for: data.trips)
                },
                onError: { error in
                    self.contentState = .error(error: .loading(reason: R.string.localizable.errorGenericTitle()))
                }
            )
            .disposed(by: disposeBag)
    }
</code></pre><h2>Feed Presenter</h2><p><a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelFeatureKit/Features/Feed/FeedPresenter.swift">Feed Presenter</a> essentially takes <code>Feed.Data</code> and returns <code>Feed.ViewModel</code>.</p><pre><code class="language-swift">    func makeContentViewModel(content: Feed.Data) throws -&gt; Feed.ViewModel.Content {
        return Feed.ViewModel.Content(
            rows: makeFeedCardRows(content),
            availableRegions: makeAvailableRegions(content),
            selectedRegion: makeSelectedRegion(content)
        )
    }
</code></pre><p>We can see that <em>struct</em> such as <code>FeedCardViewModel</code> is fairly complicated and comprehensively describes for a table view row what needs to be displayed. It ensures that there is absolutely no business logic, mapping or formatting done in a view as it's simply sets these properties to appropriate variables.</p><pre><code class="language-swift">    private func makeFeedCardRows(_ content: Feed.Data) -&gt; [FeedCardViewModel] {
        return getSortedTrips(content).map { trip in
            currencyFormatter.currencyCode = trip.currency
            return FeedCardViewModel(
                direction: R.string.localizable.feedBothWaysTitle(),
                trip: makeTripString(trip),
                price: formatCurrency(trip),
                dateRange: dateRange(trip),
                routeName: R.string.localizable.feedBookTitle(),
                imageUrl: makeTripImageURL(trip, content: content),
                route: Feed.Route.book(trip),
                isExpired: trip.expiresAt &lt;= Date()
            )
        }
    }
</code></pre><h2>Feed View Controller</h2><p>View Controller in this architecture is a very lean and clean class. It does what view <em>should</em> do: present data, handle user actions and delegate these actions to 'interactor'.</p><p><em>display()</em> lets <code>FeedViewController</code> know that the state and <code>Feed.ViewModel</code> was updated. Different views then can use parts of view model to configure themselves.</p><pre><code class="language-swift">    func display() {
        guard let viewModel = viewModel?.state.viewModel else { return }

        tableView.reloadData()
        headerView.configure(with: viewModel.selectedRegion)
    }
</code></pre><p><code>Feed.Action</code> is sent to <code>Feed.Interactor</code> when anything meaningful happens in <code>FeedViewController.</code> For example, loading data when view appears.</p><pre><code class="language-swift">    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        interactor.subscribe()
        interactor.dispatch(Feed.Action.load)
    }
</code></pre><p><code>Feed.Route</code> is sent to <code>Feed.Router</code> when <code>FeedViewController</code> wants to transition to other view controller.</p><pre><code class="language-swift">    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let cellViewModel = viewModel?.state.viewModel?.rows[indexPath.row] else { return }

        router.route(to: cellViewModel.route)
    }
</code></pre><h2>Feed Router</h2><p><code>FeedRouter</code> handles <em>route</em> actions and opens other view controllers. It uses <code>BookTripConfigurator</code> for building <code>BookTripViewController</code>.</p><pre><code class="language-swift">class FeedRouter {

    private let bookTripConfigurator: BookTripConfigurator

    weak var viewController: FeedViewController?

    init(bookTripConfigurator: BookTripConfigurator) {
        self.bookTripConfigurator = bookTripConfigurator
    }

    func route(to route: Feed.Route) {
        switch route {
        case .book(let trip):
            let bookTripViewController = bookTripConfigurator.createViewController(trip: trip)
            bookTripViewController.modalPresentationStyle = .overCurrentContext
            bookTripViewController.modalTransitionStyle = .coverVertical
            viewController?.tabBarController?.present(bookTripViewController, animated: true, completion: nil)
        }
    }
}
</code></pre><h2>Usage</h2><p>For understanding this flow easier we can imagine a hypothetical scenario of <code>Feed</code> feature.</p><ol><li>AppDelegate uses <code>FeedConfigurator</code> and calls <code>createViewController()</code> to create <code>FeedViewController</code></li><li><code>FeedViewController</code> on <code>viewWillAppear</code> calls <code>interactor.dispatch(Feed.Action.load)</code> to trigger <code>load</code> action</li><li><code>FeedInteractor</code> handles <code>load</code> action and uses <code>TripRepository</code> to load an array of <code>Trips</code> from the backend. It passes an array of <code>Trips</code> to <code>FeedPresenter</code>.</li><li><code>FeedPresenter</code> takes an array of <code>Trips</code> and maps it to <code>FeedViewModel</code> by formatting and localizing text, loading images and splitting it into fields that view needs to know about.</li><li><code>FeedViewController</code>'s method <code>display()</code> is triggered and table view is loaded with new data.</li></ol><p>Although this all may seem too much at first, it actually provides developers with huge clarity when building and maintaining the project. Moreover, all these different components have clear inputs and outputs than can be unit tested. With the growing complexity of the feature it becomes convenient to simply check <code>Action</code> to see all the different things that <code>ViewController</code> does or analyse <code>Presenter</code> to understand what kind of data is actually presented.</p><h2>Result</h2><p>In these series we've seen how to build iOS application by separating it into different frameworks, loading data from API and mapping it using <code>Codable</code>, sketching UIs following Apple's guidelines and develop it all on top of <em>Clean</em> architecture. All of these steps allow the app to be scalable, maintainable and testable.<br><br><img src="https://www.staskus.io/images/aerogami-tutorial/part5/app_demo.gif" alt="App Demo" width="300"/></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</guid><title>"Building a real-world iOS app (Part 4): Design"</title><description></description><link>https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</link><pubDate>Wed, 20 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>User experience (UX) and design is an integral part of any application. As a developer, I don't have much knowledge or "feeling" towards good looking designs. Moreover, truly great user experience requires many iterations of development and feedback. In this part we'll see how we can take example from Apple's mobile apps and design guidelines to create a familiar looking application.</p><h1>Colors</h1><p>We'll begin to design by choosing the color palette of our application. One of the best ways to ensure familiarity and simplicity of the app is to have consistent colors throughout the application. I found it a great advice to limit yourself to 1 or 2 colors.</p><p>There are a few tools online to generate color palettes so the colors would fit together nicely.</p><p>Chosen colors should be put in a common place so it could be easily accessible.</p><pre><code class="language-swift">struct Theme {
    static let primary = UIColor(red: 255/255, green: 82/255, blue: 82/255, alpha: 1.0)
    static let primaryLight = Theme.primary.withAlphaComponent(0.9)
    static let backgroundColor = UIColor(red: 239/255, green: 239/255, blue: 244/255, alpha: 1.0)
}
</code></pre><h1>UI</h1><p>Apple provides great resources for getting started. <a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a> is a great starting point for understanding the thinking behind Apple's choices as well as their preferences. Users have certain expectations and habits when using any application and it's important not to distract them with an unexpected behavior.</p><p>We'll take the inspiration from already existing <em>AppStore</em> app. The main screen of this app has a feed that we want to display in our travel application as well.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_example.png" alt="App Scren Example" width="300"/><p>Apple also provides us with <a href="https://developer.apple.com/design/resources/">design resources</a> that contain <a href="https://www.sketch.com">Sketch</a> files with designs of already existing applications. When learning to sketch or design something, I found it really beneficial to have these in front of me.</p><p>After tweaking these screens and applying our color palette we can create the first version of our design.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_real.png" alt="Feed Screen" width="300"/><p>It displays the essential information such as <em>origin</em>, <em>destination</em>, <em>dates</em> and <em>price</em>. We can also show images which provide visual information about the destination.</p><h1>App Icon</h1><p>Application icon is also a huge part of first impression of any application. We can use same given <a href="https://developer.apple.com/design/resources/">design resources</a> that include examples of created app icons.</p><p>We can use a little bit of imagination and tweak given icons on Sketch to give it a look of a travel or flight application.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.gif" alt="Making of App Icon" width="300"/><p>The resulting icon looks like this.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.png" alt="App Icon" width="300"/><p>We can use <a href="https://makeappicon.com">makeappicon.com</a> to generate all the necessary sizes of the icon so it could be used for different screen sizes as well as on AppStore.</p><h1>What's next?</h1><p>We saw how it's possible to create a clean design of an application without having much knowledge or spending too much time. Especially for small side projects, it's important to concentrate on main functionality and simply use best practices and examples when creating UIs.</p><p>In the next part of the series we'll shift our attention back to the development of our application. We'll see the approach for creating new screens and keeping the view and its logic cleanly separated.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</guid><title>"Building a real-world iOS app (Part 3): Fetching and parsing data from API"</title><description></description><link>https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</link><pubDate>Mon, 18 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In the <a href="https://www.staskus.io/tutorial/ios/swift/aerogami_series_part_2/">previous part</a> we discovered a way to separate our application into frameworks and setup the architecture of our app to support dependency injection. In this part of the series we'll be fetching and parsing data from the backend using Alamofire and Codable.</p><h1>API Client</h1><p>Although in the scope of this tutorial we'll be using mocked data, the application will be completely ready to support calls to REST APIs.</p><h3>Protocol</h3><p>We define our <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelAPIKit/APIClient.swift">APIClient</a> protocol that serves as a lean interface between data fetching classes and actual implementation.</p><pre><code class="language-swift">import RxSwift

public protocol APIClient {
    func get(path: String) -&gt; Observable&lt;Any&gt;
}
</code></pre><p>It returns <code>Observable&lt;Any&gt;</code> which is a part of <code>RxSwift</code>. We won't be going through the basics of <code>RxSwift</code>, so it's beneficial to take a look <a href="https://github.com/ReactiveX/RxSwift">official documentation</a> before continuing.</p><h3>Implementation</h3><p>The actual implementation is in <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">BaseAPIClient</a>, which uses <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> for making HTTP requests. The only method <code>get(path: String)</code> makes <code>GET</code> request by concating given path to a base URL.</p><pre><code class="language-swift">import RxAlamofire
import RxSwift

public class BaseAPIClient: APIClient {
    private let baseUrl: String

    public init(baseUrl: String) {
        self.baseUrl = baseUrl
    }

    public func get(path: String) -&gt; Observable&lt;Any&gt; {
        return RxAlamofire
            .requestJSON(.get, "\(baseUrl)/\(path)")
            .map { $1 }
    }
}
</code></pre><h3>Mock</h3><p>If you clone the <a href="https://github.com/nitesuit/aerogami-ios">repository</a>, it will use <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">MockAPIClient</a> which takes data from files. Because it uses the same public interface, <code>MockAPIClient</code> and <code>BaseAPIClient</code> can be interchanged depending on needs. See <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelApplication/Application/Assembly/ApplicationAssembly.swift">ApplicationAssembly</a> which assigns dependencies for <code>APIClient</code> interface. Depending on different configuration, it can assign any of these two. This little example perfectly illustrates the power of <code>dependency injection</code> and usage of <code>protocols</code>.<br><br># Data</p><p>The main entity in this project is a <code>Trip</code>. It describes the origin and destination of the flight as well as price and dates.</p><pre><code class="language-js">{  
   "currency":"EUR",
   "created_at":1547991979887,
   "airlines":"FR",
   "departure_at":1552848000000,
   "destination":{  
      "city":"Malaga",
      "country_code":"ES",
      "airport_code":"AGP"
   },
   "flight_number":4048,
   "departure":{  
      "city":"Copenhagen",
      "country_code":"DK",
      "airport_code":"CPH"
   },
   "return_at":1553153100000,
   "price":72,
   "id":"c4449ff0-1cb9-11e9-b9f8-b3ba95b35000",
   "expires_at":1739200281000
}
</code></pre><p><a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelApplication/Application/Mocking/TripMock.json">See full Trips JSON file</a></p><p>We'll define our entities inside <code>TravelKit</code> framework. They should be made public, so they could be reached inside other frameworks. We'll use excellent <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> type that starting from Swift 4 provides a powerful and clean way to encode and decode data.</p><p>Take a look at <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelKit/Repositories/Trip/Trip.swift">Trip</a> class. We don't need to define keys of each values if they match. It's possible to define what naming strategies are used during decoding or encoding process. For example, <code>.convertFromSnakeCase</code> strategy, as its name suggests, converts keys from snake case and assigns values automatically if they match.</p><pre><code class="language-swift">import Foundation

public struct Trip: Codable, Equatable {
    public var id: String = ""
    public var currency: String = ""
    public var price = 0

    public var airlines = ""
    public var flightNumber = 0

    public var destination: TripLocation!
    public var departure: TripLocation!

    public var createdAt = Date()
    public var departureAt = Date()
    public var returnAt = Date()
    public var expiresAt = Date()
    
    public init() {}
}

public struct TripLocation: Codable, Equatable {
    public var city: String!
    public var countryCode: String!
    public var airportCode: String!
    
    public init() {}
}
</code></pre><p>After receiving <code>JSON</code> data we can define <code>decoder</code> and automatically parse values.</p><pre><code class="language-swift">    public static var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        decoder.dateDecodingStrategy = .millisecondsSince1970
        return decoder
    }()

    let trips = try? decoder.decode([Trip].self, from: data)
</code></pre><p>With this simple and straightforward Codable API our data is cleanly parsed into statically typed object or array of objects after <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelDataKit/Repositories/Trip/Remote/APITripDataStore.swift">fetching from API</a>.</p><h1>Repositories</h1><p>Classes that are used to fetch data will be called repositories. In <code>TravelKit</code> we'll only define the protocols of these repositories. Our UI framework <code>TravelFeatureKit</code> will only know about <code>TravelKit</code> and protocols of repositories thus the implementations, defined in <code>TravelDataKit</code>, will be easily changeable.</p><p>Our <code>TripRepository</code> protocol defines the only way to fetch trips.</p><pre><code class="language-swift">import RxSwift

public protocol TripRepository {
    func getTrips(in region: String?) -&gt; Observable&lt;[Trip]&gt;
}
</code></pre><p>Because our UI framework will only know about this protocol, we will be able to provide different types of implementations. <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/TripRepository.swift">TripRepository</a> implementation defined in <code>TravelDataKit</code> calls the <code>API</code> to fetch data and parses it using <code>Coadable</code>. However, <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/FavoriteTripRepository.swift">FavoriteTripRepository</a> which also implements <code>TripRepository</code> interface, uses <code>UserDefaults</code> to fetch locally liked <code>Trips</code>. It allows us to generate 2 completely different screens in our app. One showing the current feed of flights fetched from the API and another of liked and locally saved trips. Here <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelFeatureKit/Features/Favorites/FavoritesAssembly.swift">FavoritesAssembly</a> simply injects necessary dependencies needed for <em>favorites</em> to a <code>FavoriteFeed</code> feature.</p><h1>Design</h1><p>Before continuing creating the app, we'll see how we can quickly create simple application designs using Sketch or similar tools. In the next part of the series we'll overview the approach.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</guid><title>"Building a real-world iOS app (Part 2): Separating application into frameworks"</title><description></description><link>https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</link><pubDate>Sun, 17 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In this part of the series we'll overview how to properly setup the application.</p><h1>Creating Frameworks</h1><p>As we talked in the <a href="https://www.staskus.io/tutorial/ios/swift/aerogami_series_part_1/">previous part</a>, we'll begin the creation of the project by creating 3 separate frameworks inside our XCode project (<code>TravelKit</code>, <code>TravelDataKit</code>, <code>TravelFeatureKit</code>). An article on <a href="https://www.raywenderlich.com/5109-creating-a-framework-for-ios">raywenderlich.com</a> has a thorough explanation of the whole process.</p><p>After creating frameworks, project navigator should look something like in the picture below.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part2/project_frameworks.png" alt="Frameworks in the Project Navigator" width="300"/><h1>Setting up CocoaPods</h1><p>We'll be using <a href="https://cocoapods.org">CocoaPods</a> for managing dependencies in our project. Although setting up CocoaPods is fairly straightforward, there can be some difficulties when having local frameworks involved. The configuration is defined in <code>Podfile</code> which is located in the root folder of the project.</p><p><code>Podfile</code> will be configured in a way that is clean and clear so it would not get messy when number of dependencies in the project grow. Essentially, we'll define the reusable pods at the top of the file and group different groups of pods that can be reused for different frameworks.</p><p>The part of <code>Podfile</code> that defines pods of <code>TravelKit</code>.</p><pre><code class="language-ruby">platform :ios, '11.0'
use_frameworks!
inhibit_all_warnings!

deployment_target = '11.0'

workspace 'TravelApplication.xcworkspace'

#Versions
$swinjectVersion =                    '~&gt; 2.4'
$swiftDateVersion =                   '~&gt; 5.0'
&lt;...&gt;

def shared_TravelKit_pods
    pod 'RxSwift',                    $rxSwiftVersion
    pod 'SwiftDate',                  $swiftDateVersion
end

target 'TravelKit' do
    project 'TravelKit.xcodeproj'
    platform :ios, deployment_target

    shared_TravelKit_pods

  target 'TravelKitTests' do
    project 'TravelKit.xcodeproj'
    inherit! :search_paths

    shared_testing_pods
  end
end
&lt;...&gt;
</code></pre><p>These different shared pods should be assembled and used of the actual application target.</p><pre><code class="language-ruby">&lt;...&gt;
def shared_Apps_pods
  shared_TravelKit_pods
  &lt;...&gt;
end

target 'TravelApplication' do
    project 'TravelApplication.xcodeproj'
    platform :ios, deployment_target
    shared_Apps_pods
end
&lt;...&gt;
</code></pre><p>The full <a href="https://github.com/nitesuit/aerogami-ios/blob/master/Podfile">Podfile</a> can be found on <code>GitHub</code> as the rest of the project.</p><h1>Dependency Injection</h1><p>I prefer to think early about the way dependencies will be managed inside the application. Although dependency injection can be achieved without 3rd party libraries, for this project we'll use <a href="https://github.com/Swinject/Swinject">Swinject</a> that has easy to use interfaces for managing dependencies.</p><p>Our classes will use <code>initializer injection</code> thus all the dependencies will be given through the initializer. The classes will be initialized in assemblies. Assembly is a <code>Swinject</code> class which has access to a container of already injected dependencies and provides a way to register new dependencies.</p><p>For example, this is how the assembly of the <code>Feed</code> that displays the list of flights might looks like:</p><pre><code class="language-swift">import Foundation
import Swinject
import TravelKit

public class FeedAssembly: Assembly {

    public init() {
    }

    public func assemble(container: Container) {
        container.register(FeedConfigurator.self) { r in
            FeedConfigurator(
                regionRepository: r.resolve(RegionRepository.self)!,
                tripRepository: r.resolve(TripRepository.self)!,
                airportRepository: r.resolve(AirportRepository.self)!,
                tripImageRepository: r.resolve(TripImageRepository.self)!
                )
            }
            .initCompleted { (resolver, feedConfigurator) in
                feedConfigurator.bookTripConfigurator = resolver.resolve(BookTripConfigurator.self)!
            }
            .inObjectScope(.container)
    }
}
</code></pre><p>Here, we inject <code>FeedConfigurator</code> class. It is essentially a factory class for the whole <code>Feed</code> feature and its view. <code>Swinject</code> automatically passes the dependencies such as <code>RegionRepository</code> or <code>TripRepository</code>. We expect these dependencies to be injected in another assembly so we can resolve it here.</p><p>Our application will have <code>AssemblerFactory</code> that will contain all the different assemblies of the application and create them during initialization process.</p><pre><code class="language-swift">import Foundation
import Swinject
import TravelFeatureKit
import TravelDataKit

class AssemblerFactory {

    func create() -&gt; Assembler {
        let assemblies: [Assembly] = [
            ApplicationAssembly(),
            RegionRepositoryAssembly(),
            TripRepositoryAssembly(),
            AirportRepositoryAssembly(),

            MainAssembly(),
            FavoritesAssembly(),
            FeedAssembly(),
            BookTripAssembly(),
            BookURLRepositoryAssembly(affiliateId: Constants.affiliateId)
        ]

        let assembler = Assembler(assemblies)

        return assembler
    }
}
</code></pre><p>We use this assembly to create the first <code>ViewController</code> of the application and set it as <code>rootViewController</code>. See <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelApplication/Application/ApplicationLoader.swift">ApplicationLoader</a>.</p><pre><code class="language-swift">  self.assembler = AssemblerFactory().create()
  let rootConfigurator = assembler.resolver.resolve(MainConfigurator.self)!
  let rootViewController = rootConfigurator.createViewController()
  window?.rootViewController = rootViewController
  window?.makeKeyAndVisible()
</code></pre><p>In the following parts of the series we'll be creating classes for fetching and presenting data that will use assemblies for injecting dependencies. We'll see more closely how having proper dependency injection allows code to be more reusable, safe and testable.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</guid><title>"Building a real-world iOS app (Part 1): Introduction"</title><description></description><link>https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</link><pubDate>Mon, 11 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When learning any new technology I find it beneficial to follow a real world example. In this tutorial series we'll be creating and releasing an iOS application. The application will be created by showing a real thinking process, going through essential steps and providing the motivation behind them. Although every single line of code won't be covered, all of it will be always available on <a href="https://github.com/nitesuit/aerogami-ios">GitHub</a>.</p><h1>Prerequisites</h1><p>Prior knowledge of iOS development and Swift syntax is needed.</p><h1>Introduction</h1><h2>Our Project</h2><p>We'll be creating a flight discovery application. The users of our application should be able to:</p><ol><li>See the <em>feed</em> of <em>flights</em></li><li>See the <em>date</em>, <em>price</em>, <em>origin</em> and <em>destination</em> of each <em>flight</em></li><li>Book the <em>flight</em>.</li></ol><p>In the scope of this project we won't be concerned about the source of information. Our application will use mocked flight information data. However, the structure of the application will support an easy integration with any Rest API.</p><h2>Our Approach</h2><p>Throughout the series we'll cover these topics one-by-one:</p><ol><li>Data Fetching and Parsing</li><li>Testing</li><li>Code Separation into Frameworks</li><li>Design using Sketch</li><li>Clean Swift Architecture</li><li>Building the UI and Displaying the Data</li><li>Release Process</li></ol><h2>The Final Product</h2><p>Here is the sneak peek of how the final product will look like. The full codebase can be found on <a href="https://github.com/nitesuit/aerogami-ios">GitHub</a>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/screenshot.png" alt="Application Screenshot" width="200"/><h1>High Level View</h1><p>Before we start, it's beneficial to understand how we're going to approach the creation of this application.</p><h2>Separation of Concerns</h2><p>Essentially our application should be able to perform 3 main tasks:</p><ol><li>Fetch data</li><li>Parse data</li><li>Display data</li></ol><p>We'll separate these different concerns into frameworks for our code to be decoupled and flexible. The primitive diagram of the architecture is displayed in the picture bellow. We'll define data models and protocols in <code>TravelKit</code>. This framework will contain data fetching protocols, which will be implemented in <code>TravelDataKit</code>. DataKit, as its name suggests, will be used for fetching, persisting and providing data. User interface will only know about data models and protocols and won't be concerned about the implementation. We'll call this framework <code>TravelFeatureKit</code>. The entry point of our application will initialize the dependencies required for all the frameworks and present the root view described in <code>TravelFeatureKit</code>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/architecture.png" alt="Application Architecture" width="300"/><p>In the next part of the series we'll continue by explaining how to create frameworks and setup the base of the application.</p>]]></content:encoded></item></channel></rss>