<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Povilas Staškus</title><description>Senior iOS Engineer @Automattic</description><link>https://www.staskus.io</link><language>en</language><lastBuildDate>Mon, 2 Oct 2023 16:43:37 +0300</lastBuildDate><pubDate>Mon, 2 Oct 2023 16:43:37 +0300</pubDate><ttl>250</ttl><atom:link href="https://www.staskus.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-06-23-app-clip</guid><title>App Clips: A first glance at the new way to access an iOS app</title><description></description><link>https://www.staskus.io/posts/2020-06-23-app-clip</link><pubDate>Tue, 23 Jun 2020 18:00:00 +0300</pubDate><content:encoded><![CDATA[<p>During <a href="https://developer.apple.com/wwdc20/">WWDC20</a> Apple is introducing new <a href="https://developer.apple.com/app-clips/">App Clips</a> feature. As it's described in the landing page:</p><blockquote><p>An app clip is a small part of your app that’s discoverable at the moment it’s needed.</p></blockquote><p>Apple already suggested some possible use cases such as ordering from a take-out restaurant or renting a scooter. And App Clips will be discovered and invoked by using new App Clip Codes, NFC Tags, QR Codes, Messages, or as place cards in Maps.</p><p>It looks like a great move forward in reducing friction and getting an app into users' hands as fast as possible.</p><p>We'll take a look at the initial steps of how these App Clips could be implemented and introduced in the project.</p><h2>Prerequisites</h2><p>Xcode 12 or higher.</p><h2>Getting Started</h2><p>We start by creating a new project and selecting the creation of a new target.</p><img src="https://www.staskus.io/images/app-clip/new_target.png" alt="App Clip New Target" width="600"/><p>We select a new App Clip target and add it to our application.</p><img src="https://www.staskus.io/images/app-clip/new_target_app_clip.png" alt="App Clip New Target" width="600"/><h2>Add Associated Domain</h2><p>We need to provide an associated domain for both App and App Clip targets. If App is not installed the link will open App Clip. Otherwise full App will be opened instead.</p><p>We do it by selecting <em>Target -&gt; Signing &amp; Capabilities</em>, clicking + sign, and choosing Associated Domains.</p><img src="https://www.staskus.io/images/app-clip/associated_domains.png" alt="Creating Associated Domain" width="600"/><p>Next, we enter our associated domain value which must follow pattern of <em>appclips:domain</em>. In this instance, we can enter <em>appclips:example.com</em>.</p><img src="https://www.staskus.io/images/app-clip/associated_domains_example.png" alt="Associated Domains Example" width="600"/><h2>Running App Clip target</h2><p>App Clip target can be run and debugged just like an App target.</p><p>We can open <code>ContentView.swift</code> inside an App Clip target, make changes, and run.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello, App Clip!"</span>).<span class="call">padding</span>()
    }
}
</code></pre><img src="https://www.staskus.io/images/app-clip/hello_app_clip.png" alt="Hello App Clip Simulator Screen" width="300"/><h2>Configuring App Clip</h2><p>App Clip is invoked via URL which can contain context-related information and be used in the configuration.</p><p>Let's say we want to provide a user with a more personalized greeting message after App Clip was invoked. We can pass binding <code>name</code> variable to <code>ContentView</code>.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@Binding var</span> name: <span class="type">String</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello,</span> \(name)<span class="string">"</span>).<span class="call">padding</span>()
    }
}
</code></pre><p>This example uses a new App lifecycle in SwiftUI which enables entire apps to be written completely in SwiftUI.</p><p>Information about invocation is passed through lifecycle events. We can use <code>onContinueUserActivity</code> to be notified about App Clip being launched with parameters.</p><p>More information about using legacy lifecycles can be found on <a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Access the Invocation URL section</a>.</p><p>After that, we take the incoming URL and its first path component. Now first path parameter passed through URL will be set as a name.</p><pre><code><span class="keyword">@main
struct</span> AppClipSneakPeekClipApp: <span class="type">App</span> {
    <span class="keyword">@State var</span> name = <span class="string">""</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> {
        <span class="type">WindowGroup</span> {
            <span class="type">ContentView</span>(name: $name).<span class="call">onContinueUserActivity</span>(<span class="type">NSUserActivityTypeBrowsingWeb</span>, perform: respondTo)
        }
    }

    <span class="keyword">func</span> respondTo(<span class="keyword">_</span> activity: <span class="type">NSUserActivity</span>?) {
        <span class="keyword">guard let</span> name = <span class="call">firstParameterValue</span>(from: activity) <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="keyword">self</span>.<span class="property">name</span> = name
    }

    <span class="keyword">private func</span> firstParameterValue(from activity: <span class="type">NSUserActivity</span>?) -&gt; <span class="type">String</span>? {
        <span class="comment">// Parsing components from URL</span>
        <span class="keyword">guard let</span> activity = activity <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        <span class="keyword">guard let</span> incomingURL = activity.<span class="property">webpageURL</span> <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        <span class="keyword">guard let</span> components = <span class="type">NSURLComponents</span>(url: incomingURL, resolvingAgainstBaseURL: <span class="keyword">true</span>) <span class="keyword">else</span> { <span class="keyword">return nil</span> }

        <span class="comment">// Taking first parameter: example.com/?parameter=Lisa</span>
        <span class="keyword">return</span> components.<span class="property">queryItems</span>?.<span class="property">first</span>?.<span class="property">value</span>
    }
}
</code></pre><h2>Testing</h2><p>Launching AppClip target now does not show any name value. It makes sense as we didn't pass any URL with parameters to our app.</p><p>We can automatically test it by providing <em>Environment Variable</em> for App Clip scheme. It can be done by selecting <code>App Clip scheme -&gt; Edit Scheme -&gt; Run</code> and set the value of <em>_XCAppClipURL</em> of test URL value. We set it to <em>https://example.com/?parameter=Lisa</em> to have a first parameter value.</p><img src="https://www.staskus.io/images/app-clip/testing.png" alt="Adding Environment Variable" width="600"/><p>If we launch the application now, the value is received through lifecycle event and updated inside a view.</p><img src="https://www.staskus.io/images/app-clip/testing_success.png" alt="iOS Simulator with result" width="300"/><h3>What about App Clip Card?</h3><p>App Clip Card itself that is shown with a suggestion to open an App Card is not developed through Xcode. The information displayed in this card can be configured through <a href="https://appstoreconnect.apple.com/login">App Store Connect</a>. Developers will be able to change a header image, subtitle, and title on the action button.</p><h2>Where do we go from here?</h2><p>App Clip looks like a promising addition to the ecosystem and it will be interesting to see how it will be used and adopted by both developers and users.</p><p>The example project can be found on <a href="https://github.com/staskus/AppClipSneakPeekApp">GitHub</a>.</p><p>Apple provides a lot of helpful resources for going more in-depth into App Clips.</p><ul><li><a href="https://developer.apple.com/documentation/app_clips">Developing a Great App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/creating_an_app_clip">Creating an App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Responding to Invocation</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Configuring Your App Clip’s Launch Experience</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Testing Your App Clip’s Launch Experience</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-01-26-publish</guid><title>Migrating from Jekyll to Publish: A site generator for Swift developers</title><description></description><link>https://www.staskus.io/posts/2020-01-26-publish</link><pubDate>Sun, 26 Jan 2020 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/JohnSundell/Publish">Publish</a> is a static site generator built for Swift developers. We'll be migrating a static blog generation from <a href="https://jekyllrb.com">Jekyll</a> to Publish. The previous version of a blog was generated using Jekyll and a provided theme without putting too much effort in understanding the whole creation process. This time I decided to dig deeper into understanding Publish and remembering long forgotten <em>HTML</em> and <em>CSS</em> skills.</p><p>We'll be trying to create a similar style blog that was created using Jekyll. It should remain adaptable for bigger or smaller screen sizes:</p><h4>Previous desktop version</h4><img src="https://www.staskus.io/images/publish/previous_1.png" alt="Previous desktop version of a blog" width="500"/><h4>Previous mobile version</h4><img src="https://www.staskus.io/images/publish/previous_2.png" alt="Previous mobile version of a blog" width="300"/><h2>Getting Started</h2><p>After running the steps described in a <a href="https://github.com/JohnSundell/Publish">Publish repository</a> we end up with a sample project that showcases the main parts and features of Publish.</p><p>In the folder structure we can see <code>posts</code> folder that contains an example post. I copy-pasted my blog posts <code>.md</code> files from old Jekyll blog to see if it works. We only need to change couple fields to make it work. The only difference is a metadata format on top of <code>.md</code> file. By removing quotes from strings, brackets from arrays and renaming categories to tags we can get Jekyll articles immediately generated into a new blog.</p><img src="https://www.staskus.io/images/publish/blog_1.png" alt="Previous desktop version of a blog" width="500"/><h2>Website</h2><p>If we open up <code>main.swift</code> file we see:</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>In Publish a website is a simple Swift struct that should contain mandatory fields required by a <code>Website</code> protocol as well as any additional fields that might be needed.</p><p>As this blog contains personal information as well as links to social media accounts, I included them in a <code>Blog</code> structure.</p><pre><code><span class="keyword">struct</span> Blog: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> posts
        <span class="keyword">case</span> about
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
    	<span class="comment">// Additional field in post .md metadata</span>
        <span class="keyword">var</span> excerpt: <span class="type">String</span>
    }

    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.staskus.io"</span>)!
    <span class="keyword">var</span> title = <span class="string">"staskus.io"</span>
    <span class="keyword">var</span> name = <span class="string">"Povilas Staškus"</span>
    <span class="keyword">var</span> description = <span class="string">"iOS Developer"</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="keyword">nil</span> }
    <span class="keyword">var</span> socialMediaLinks: [<span class="type">SocialMediaLink</span>] { [.<span class="dotAccess">location</span>, .<span class="dotAccess">email</span>, .<span class="dotAccess">linkedIn</span>, .<span class="dotAccess">github</span>, .<span class="dotAccess">twitter</span>] }
}
</code></pre><h2>Theme</h2><p>Basic <code>foundation</code> theme is used after generating a website for the first time. However, it's only there to give an example of how custom site theme should be created.</p><p>A <code>Theme</code> is built by conforming to <code>HTMLFactory</code> protocol.</p><p>Not all the pages are needed to be created for your site to be fully functioning. For a blog we must have: 1) an index page, that shows header, sidebar and list of posts. 2) item page, that will show full post.</p><pre><code><span class="keyword">class</span> BlogHTMLFactory: <span class="type">HTMLFactory</span> {

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>,
                       context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of an Index Page</span>
    }

    <span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Section</span>&lt;<span class="type">Site</span>&gt;,
                         context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Section Index Page that displays section items</span>
    }

    <span class="keyword">func</span> makeItemHTML(for item: <span class="type">Item</span>&lt;<span class="type">Site</span>&gt;,
                      context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Post Page</span>
    }

    <span class="keyword">func</span> makePageHTML(for page: <span class="type">Page</span>,
                      context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Section Page</span> 
    }

    <span class="keyword">func</span> makeTagListHTML(for page: <span class="type">TagListPage</span>,
                         context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    	<span class="comment">// Returning HTML of a Page with list of available tags</span>
    }

    <span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">TagDetailsPage</span>,
                            context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    	<span class="comment">// Returning HTML of a Page for a specific tag</span>
    }
}
</code></pre><p>Although we can write <code>HTML</code> code using Swift, the styling of the site is done using <code>CSS.</code> For the creation of this blog, I decided to use <a href="https://purecss.io">Pure.css</a>. The desired blog theme is quite minimalist and the features that <a href="https://purecss.io">Pure.css</a> provides seem more than enough to achieve what we want. Even after many years without any <code>CSS</code> and <code>HTML</code> experience it was possible to make pretty decent layout. For the rest of this article, we won't be focusing on that. The code can be found on <a href="https://github.com/staskus/Blog">GitHub</a> for those who are interested.</p><h3>Index Page</h3><p><code>makeIndexHTML</code> builds HTML of an index page. The structure is the same as writing plain HTML tags. We set <em>language</em>, <em>head</em> and then structure layout inside <em>body</em>.</p><p>Body uses <code>.grid</code> node that creates Pure.css grid in which we can structure our layout. We have <code>.header</code>, <code>.sidebar</code>, <code>.posts</code> and <code>.footer</code> that are put one after the other.</p><pre><code><span class="keyword">class</span> BlogHTMLFactory: <span class="type">HTMLFactory</span> {

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>,
                       context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="type">HTML</span>(
            .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
            .<span class="call">head</span>(for: context.<span class="property">site</span>),
            .<span class="call">body</span>(
                .<span class="call">grid</span>(
                    .<span class="call">header</span>(for: context.<span class="property">site</span>),
                    .<span class="call">sidebar</span>(for: context.<span class="property">site</span>),
                    .<span class="call">posts</span>(
                        for: context.<span class="call">allItems</span>(
                            sortedBy: \.<span class="property">date</span>,
                            order: .<span class="dotAccess">descending</span>
                        ),
                        on: context.<span class="property">site</span>,
                        title: <span class="string">"Recent posts"</span>
                    ),
                    .<span class="call">footer</span>(for: context.<span class="property">site</span>)
                )
            )
        )
    }
}
</code></pre><p>Any node can be written as a <code>static</code> func extension of a <code>Node</code>. <code>Context == HTML.BodyContext</code> indicate that this node can be only used inside <em>body</em>. It's a nice and clean way to declare new nodes, as they can be then used using dot syntax.</p><pre><code><span class="keyword">extension</span> <span class="type">Node</span> <span class="keyword">where</span> <span class="type">Context</span> == <span class="type">HTML</span>.<span class="type">BodyContext</span> {
    <span class="keyword">static func</span> grid(<span class="keyword">_</span> nodes: <span class="type">Node</span>...) -&gt; <span class="type">Node</span> {
        .<span class="call">div</span>(
            .<span class="call">id</span>(<span class="string">"layout"</span>),
            .<span class="call">class</span>(<span class="string">"pure-g"</span>),
            .<span class="call">group</span>(nodes)
        )
    }
}
</code></pre><h3>Post</h3><p>A post can be declared the same way as any other node. On the top, we show the title of the post. Below, we show date. We can use any powerful features that Swift infrastructure provides us. In this instance, we use <code>DateFormatter</code> to format a date. In a similar way any more complex or sophisticated logic could be used inside this code.</p><pre><code><span class="keyword">extension</span> <span class="type">Node</span> <span class="keyword">where</span> <span class="type">Context</span> == <span class="type">HTML</span>.<span class="type">BodyContext</span> {
    <span class="keyword">static func</span> post(for item: <span class="type">Item</span>&lt;<span class="type">Blog</span>&gt;, on site: <span class="type">Blog</span>) -&gt; <span class="type">Node</span> {
        <span class="keyword">return</span> .<span class="call">pageContent</span>(
            .<span class="call">h2</span>(
                .<span class="call">class</span>(<span class="string">"post-title"</span>),
                .<span class="call">a</span>(
                    .<span class="call">href</span>(item.<span class="property">path</span>),
                    .<span class="call">text</span>(item.<span class="property">title</span>)
                )
            ),
            .<span class="call">p</span>(
                .<span class="call">class</span>(<span class="string">"post-meta"</span>),
                .<span class="call">text</span>(<span class="type">DateFormatter</span>.<span class="property">blog</span>.<span class="call">string</span>(from: item.<span class="property">date</span>))
            ),
            .<span class="call">tagList</span>(for: item, on: site),
            .<span class="call">div</span>(
                .<span class="call">class</span>(<span class="string">"post-description"</span>),
                .<span class="call">div</span>(
                    .<span class="call">contentBody</span>(item.<span class="property">body</span>)
                )
            )
        )
    }
}
</code></pre><h3>Finishing the theme</h3><p>We can make our theme accessible by creating <code>Theme</code> object and passing our <code>BlogHTMLFactory</code>. Declaring it as a <em>static var</em> inside an extension allows reaching it more conveniently.</p><pre><code><span class="keyword">extension</span> <span class="type">Theme</span> <span class="keyword">where</span> <span class="type">Site</span> == <span class="type">Blog</span> {
    <span class="keyword">static var</span> blog: <span class="type">Self</span> {
        <span class="type">Theme</span>(htmlFactory: <span class="type">BlogHTMLFactory</span>())
    }
}
</code></pre><h2>Generating the site</h2><p>We've seen how by creating nodes we can step by step create pages for our blog. However, I would argue that the biggest power of Publish comes from <code>plugins</code> and additional building steps that we can create or use.</p><p><a href="https://github.com/JohnSundell/Splash">Splash</a> is a Swift syntax highlighter for blogs that has a plugin built for Publish. During the blog generation process, this plugin uses markdown parser to identify code inside <code>.md</code> files and apply syntax highlighting.</p><p>We can use or build any steps that might do additional checks, append necessary information or simply tweak a site in any way needed.</p><pre><code><span class="keyword">import</span> SplashPublishPlugin

<span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">blog</span>,
    additionalSteps: [.<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"staskus/nitesuit.github.io"</span>))],
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><h2>Result</h2><p>Publish worked seamlessly during development process. It provided all the convenience of Swift strong type system and helped stay focused while trying to figure unfamiliar web development workflows. Although Publish still misses many features that established static site generators have, it serves perfectly for its intended audience - Swift developers. Now that all the parts of the site are well understood, Publish together with Swift gives a lot of power for future improvements.</p><p>The code of the blog can be found on <a href="https://github.com/staskus/Blog">GitHub</a>.</p><h4>New desktop version</h4><img src="https://www.staskus.io/images/publish/blog_new_2.png" alt="New desktop version of a blog" width="500"/><h4>New mobile version</h4><img src="https://www.staskus.io/images/publish/blog_new_1.png" alt="New mobile version of a blog" width="300"/>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</guid><title>Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views</title><description></description><link>https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</link><pubDate>Sun, 24 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When starting to develop any application it's beneficial to think early about the way code can be testable and whether it would be scalable or maintainable. Many iOS applications have suffered from what is called <em>Massive View Controller</em> problem. By putting all the code that fetches, maps, presents and styles into one ViewController it very quickly overgrows in size and complexity. A lot of solutions where introduced to tackle this problem such as MVVM, MVVM + ReactiveCocoa or VIPER. In this application we'll be using <a href="https://clean-swift.com">Clean Swift</a> approach for breaking up massive view controllers into testable and maintainable parts.</p><h2>Data Structures</h2><h3>Data</h3><p><code>Struct</code> containing <em>raw data</em>.</p><pre><code>     <span class="keyword">struct</span> Data: <span class="type">Equatable</span> {
        <span class="keyword">let</span> regions: [<span class="type">Region</span>]
        <span class="keyword">let</span> trips: [<span class="type">Trip</span>]
    }
</code></pre><h3>View Model</h3><p><code>Struct</code> containing <em>State</em> (loading, error, empty, loaded) and mapped data that is used by <em>View Controllers</em> for configuring views.</p><pre><code>     <span class="keyword">struct</span> ViewModel: <span class="type">FeatureViewModel</span> {
        <span class="keyword">let</span> state: <span class="type">ViewState</span>&lt;<span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>&gt;
        <span class="keyword">let</span> title: <span class="type">String</span>

        <span class="keyword">struct</span> Content: <span class="type">FeatureContentViewModel</span>, <span class="type">Equatable</span> {
            <span class="keyword">var</span> rows: [<span class="type">FeedCardViewModel</span>]
            <span class="keyword">let</span> availableRegions: [<span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>.<span class="type">Region</span>]
            <span class="keyword">let</span> selectedRegion: <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>.<span class="type">Region</span>?

            <span class="keyword">struct</span> Region: <span class="type">Equatable</span> {
                <span class="keyword">let</span> id: <span class="type">String</span>
                <span class="keyword">let</span> name: <span class="type">String</span>
            }

            <span class="keyword">var</span> hasContent: <span class="type">Bool</span> {
                <span class="keyword">return</span> !rows.<span class="property">isEmpty</span>
            }
        }
    }
</code></pre><h3>Action</h3><p><code>Enum</code> with actions that <em>View Controller</em> can do and <em>Interactor</em> can handle.</p><pre><code>     <span class="keyword">enum</span> Action {
        <span class="keyword">case</span> load
        <span class="keyword">case</span> changeRegion(regionId: <span class="type">String</span>?)
    }
</code></pre><h3>Route</h3><p><code>Enum</code> with destinations that <em>View Controller</em> can route to.</p><pre><code>     <span class="keyword">enum</span> Route: <span class="type">Equatable</span> {
        <span class="keyword">case</span> book(<span class="type">Trip</span>)
    }
</code></pre><h2>Components</h2><h3>Interactor</h3><p>Receives an action, performs work and sends raw data to presenter.</p><ul><li>Input - <em>Action</em></li><li>Output - <em>Data</em></li><li>Uses - <em>Presenter</em></li></ul><h3>Presenter</h3><p>Receives raw data and maps it into <em>View Model</em></p><ul><li>Input - <em>Data</em></li><li>Output - <em>View Model</em></li></ul><h3>View Controller</h3><p>Receives <em>View Model</em> and configures a view according to it. Sends actions to <em>Interactor</em>.</p><ul><li>Input - <em>View Model</em></li><li>Output - <em>Action</em></li><li>Uses - <em>Interactor</em>, <em>Router</em></li></ul><h3>Router</h3><p>Receives <em>Route</em> object from <em>View Controller</em>, that contains information about next destination, and opens next <em>View Controller</em> using <em>Configurator</em></p><ul><li>Input - <em>Route</em></li><li>Uses - <em>Configurator</em></li></ul><h3>Configurator</h3><p>Takes an input and creates configured <em>View Controller</em> with other components.</p><ul><li>Input - Optional configuration data.</li><li>Output - <em>View Controller</em></li><li>Creates - <em>Interactor</em>, <em>Presenter</em>, <em>View Controller</em>, <em>Router</em></li></ul><h2>Feature</h2><p>The group of these components is called <code>Feature</code>. <a href="https://clean-swift.com">Clean Swift</a> provides with XCode templates that allow to generate all of these components together. We are using <a href="https://github.com/staskus/aerogami-ios/tree/master/templates/plop/Feature">plop templates</a> for feature generation. All of this allows to avoid writing boilerplate code and concentrate on actual code of the feature.</p><h2>Feed Example</h2><p><code>Feed</code> is a main <a href="https://github.com/staskus/aerogami-ios/tree/master/TravelFeatureKit/Features/Feed">feature</a> of the application. We're going to see how all of these different components is used to create a complete feature.</p><h3>Feed Interactor</h3><p><code>Feed Interactor</code> uses repositories of <em>Region</em>, <em>Trip</em> and <em>Airport</em> for loading data.</p><p><code>dispatch</code> function is an entry point of any <code>Interactor</code>.</p><pre><code>     <span class="keyword">func</span> dispatch(<span class="keyword">_</span> action: <span class="type">Feed</span>.<span class="type">Action</span>) {
        <span class="keyword">switch</span> action {
        <span class="keyword">case</span> .<span class="dotAccess">load</span>:
            contentState = .<span class="call">loading</span>(data: contentState.<span class="property">data</span>)
            <span class="call">load</span>()
        <span class="keyword">case</span> .<span class="dotAccess">changeRegion</span>(<span class="keyword">let</span> regionId):
            <span class="call">changeRegion</span>(id: regionId)
        }
    }
</code></pre><p>We can see when <code>FeedInteractor</code> receives <em>load</em> action it sets current state to <em>loading</em> and calls <code>load()</code> method. It combines <code>RegionRepository</code> and <code>TripRepository</code>, maps it to <em>Data</em> object and passes it to <code>FeedPresenter</code> by setting <em>contentState</em>.</p><pre><code>     <span class="keyword">func</span> load() {
        <span class="keyword">let</span> selectedRegion = regionRepository.<span class="call">getSelectedRegion</span>()

        <span class="type">Observable</span>.<span class="call">combineLatest</span>(
            <span class="keyword">self</span>.<span class="property">regionRepository</span>.<span class="call">getRegions</span>(),
            <span class="keyword">self</span>.<span class="property">tripRepository</span>.<span class="call">getTrips</span>(in: selectedRegion?.<span class="property">id</span>)
            )
            .<span class="call">map</span> { (regions, trips) -&gt; <span class="type">Feed</span>.<span class="type">Data</span> <span class="keyword">in
                return</span> <span class="type">Feed</span>.<span class="type">Data</span>(
                    regions: regions,
                    trips: trips,
                    selectedRegionId: selectedRegion?.<span class="property">id</span>,
                    tripImages: []
                )
            }
            .<span class="call">subscribe</span>(
                onNext: { data <span class="keyword">in
                    self</span>.<span class="property">contentState</span> = .<span class="call">loaded</span>(data: data, error: <span class="keyword">nil</span>)
                    <span class="keyword">self</span>.<span class="call">loadImages</span>(for: data.<span class="property">trips</span>)
                },
                onError: { error <span class="keyword">in
                    self</span>.<span class="property">contentState</span> = .<span class="call">error</span>(error: .<span class="call">loading</span>(reason: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">errorGenericTitle</span>()))
                }
            )
            .<span class="call">disposed</span>(by: disposeBag)
    }
</code></pre><h3>Feed Presenter</h3><p><a href="https://github.com/staskus/aerogami-ios/blob/master/TravelFeatureKit/Features/Feed/FeedPresenter.swift">Feed Presenter</a> essentially takes <code>Feed.Data</code> and returns <code>Feed.ViewModel</code>.</p><pre><code>     <span class="keyword">func</span> makeContentViewModel(content: <span class="type">Feed</span>.<span class="type">Data</span>) <span class="keyword">throws</span> -&gt; <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span> {
        <span class="keyword">return</span> <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>(
            rows: <span class="call">makeFeedCardRows</span>(content),
            availableRegions: <span class="call">makeAvailableRegions</span>(content),
            selectedRegion: <span class="call">makeSelectedRegion</span>(content)
        )
    }
</code></pre><p>We can see that <em>struct</em> such as <code>FeedCardViewModel</code> is fairly complicated and comprehensively describes for a table view row what needs to be displayed. It ensures that there is absolutely no business logic, mapping or formatting done in a view as it's simply sets these properties to appropriate variables.</p><pre><code>     <span class="keyword">private func</span> makeFeedCardRows(<span class="keyword">_</span> content: <span class="type">Feed</span>.<span class="type">Data</span>) -&gt; [<span class="type">FeedCardViewModel</span>] {
        <span class="keyword">return</span> <span class="call">getSortedTrips</span>(content).<span class="call">map</span> { trip <span class="keyword">in</span>
            currencyFormatter.<span class="property">currencyCode</span> = trip.<span class="property">currency</span>
            <span class="keyword">return</span> <span class="type">FeedCardViewModel</span>(
                direction: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">feedBothWaysTitle</span>(),
                trip: <span class="call">makeTripString</span>(trip),
                price: <span class="call">formatCurrency</span>(trip),
                dateRange: <span class="call">dateRange</span>(trip),
                routeName: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">feedBookTitle</span>(),
                imageUrl: <span class="call">makeTripImageURL</span>(trip, content: content),
                route: <span class="type">Feed</span>.<span class="type">Route</span>.<span class="call">book</span>(trip),
                isExpired: trip.<span class="property">expiresAt</span> &lt;= <span class="type">Date</span>()
            )
        }
    }
</code></pre><h3>Feed View Controller</h3><p>View Controller in this architecture is a very lean and clean class. It does what view <em>should</em> do: present data, handle user actions and delegate these actions to 'interactor'.</p><p><em>display()</em> lets <code>FeedViewController</code> know that the state and <code>Feed.ViewModel</code> was updated. Different views then can use parts of view model to configure themselves.</p><pre><code>     <span class="keyword">func</span> display() {
        <span class="keyword">guard let</span> viewModel = viewModel?.<span class="property">state</span>.<span class="property">viewModel</span> <span class="keyword">else</span> { <span class="keyword">return</span> }

        tableView.<span class="call">reloadData</span>()
        headerView.<span class="call">configure</span>(with: viewModel.<span class="property">selectedRegion</span>)
    }
</code></pre><p><code>Feed.Action</code> is sent to <code>Feed.Interactor</code> when anything meaningful happens in <code>FeedViewController.</code> For example, loading data when view appears.</p><pre><code>     <span class="keyword">override func</span> viewWillAppear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
        <span class="keyword">super</span>.<span class="call">viewWillAppear</span>(animated)

        interactor.<span class="call">subscribe</span>()
        interactor.<span class="call">dispatch</span>(<span class="type">Feed</span>.<span class="type">Action</span>.<span class="property">load</span>)
    }
</code></pre><p><code>Feed.Route</code> is sent to <code>Feed.Router</code> when <code>FeedViewController</code> wants to transition to other view controller.</p><pre><code>     <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, didSelectRowAt indexPath: <span class="type">IndexPath</span>) {
        <span class="keyword">guard let</span> cellViewModel = viewModel?.<span class="property">state</span>.<span class="property">viewModel</span>?.<span class="property">rows</span>[indexPath.<span class="property">row</span>] <span class="keyword">else</span> { <span class="keyword">return</span> }

        router.<span class="call">route</span>(to: cellViewModel.<span class="property">route</span>)
    }
</code></pre><h3>Feed Router</h3><p><code>FeedRouter</code> handles <em>route</em> actions and opens other view controllers. It uses <code>BookTripConfigurator</code> for building <code>BookTripViewController</code>.</p><pre><code><span class="keyword">class</span> FeedRouter {

    <span class="keyword">private let</span> bookTripConfigurator: <span class="type">BookTripConfigurator</span>

    <span class="keyword">weak var</span> viewController: <span class="type">FeedViewController</span>?

    <span class="keyword">init</span>(bookTripConfigurator: <span class="type">BookTripConfigurator</span>) {
        <span class="keyword">self</span>.<span class="property">bookTripConfigurator</span> = bookTripConfigurator
    }

    <span class="keyword">func</span> route(to route: <span class="type">Feed</span>.<span class="type">Route</span>) {
        <span class="keyword">switch</span> route {
        <span class="keyword">case</span> .<span class="dotAccess">book</span>(<span class="keyword">let</span> trip):
            <span class="keyword">let</span> bookTripViewController = bookTripConfigurator.<span class="call">createViewController</span>(trip: trip)
            bookTripViewController.<span class="property">modalPresentationStyle</span> = .<span class="dotAccess">overCurrentContext</span>
            bookTripViewController.<span class="property">modalTransitionStyle</span> = .<span class="dotAccess">coverVertical</span>
            viewController?.<span class="property">tabBarController</span>?.<span class="call">present</span>(bookTripViewController, animated: <span class="keyword">true</span>, completion: <span class="keyword">nil</span>)
        }
    }
}
</code></pre><h2>Usage</h2><p>For understanding this flow easier we can imagine a hypothetical scenario of <code>Feed</code> feature.</p><ol><li>AppDelegate uses <code>FeedConfigurator</code> and calls <code>createViewController()</code> to create <code>FeedViewController</code></li><li><code>FeedViewController</code> on <code>viewWillAppear</code> calls <code>interactor.dispatch(Feed.Action.load)</code> to trigger <code>load</code> action</li><li><code>FeedInteractor</code> handles <code>load</code> action and uses <code>TripRepository</code> to load an array of <code>Trips</code> from the backend. It passes an array of <code>Trips</code> to <code>FeedPresenter</code>.</li><li><code>FeedPresenter</code> takes an array of <code>Trips</code> and maps it to <code>FeedViewModel</code> by formatting and localizing text, loading images and splitting it into fields that view needs to know about.</li><li><code>FeedViewController</code>'s method <code>display()</code> is triggered and table view is loaded with new data.</li></ol><p>Although this all may seem too much at first, it actually provides developers with huge clarity when building and maintaining the project. Moreover, all these different components have clear inputs and outputs than can be unit tested. With the growing complexity of the feature it becomes convenient to simply check <code>Action</code> to see all the different things that <code>ViewController</code> does or analyse <code>Presenter</code> to understand what kind of data is actually presented.</p><h3>Result</h3><p>In these series we've seen how to build iOS application by separating it into different frameworks, loading data from API and mapping it using <code>Codable</code>, sketching UIs following Apple's guidelines and develop it all on top of <em>Clean</em> architecture. All of these steps allow the app to be scalable, maintainable and testable.<br><br><img src="https://www.staskus.io/images/aerogami-tutorial/part5/app_demo.gif" alt="App Demo" width="300"/></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</guid><title>Building a real-world iOS app (Part 4): Design</title><description></description><link>https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</link><pubDate>Wed, 20 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>User experience (UX) and design is an integral part of any application. As a developer, I don't have much knowledge or "feeling" towards good looking designs. Moreover, truly great user experience requires many iterations of development and feedback. In this part we'll see how we can take example from Apple's mobile apps and design guidelines to create a familiar looking application.</p><h2>Colors</h2><p>We'll begin to design by choosing the color palette of our application. One of the best ways to ensure familiarity and simplicity of the app is to have consistent colors throughout the application. I found it a great advice to limit yourself to 1 or 2 colors.</p><p>There are a few tools online to generate color palettes so the colors would fit together nicely.</p><p>Chosen colors should be put in a common place so it could be easily accessible.</p><pre><code><span class="keyword">struct</span> Theme {
    <span class="keyword">static let</span> primary = <span class="type">UIColor</span>(red: <span class="number">255</span>/<span class="number">255</span>, green: <span class="number">82</span>/<span class="number">255</span>, blue: <span class="number">82</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
    <span class="keyword">static let</span> primaryLight = <span class="type">Theme</span>.<span class="property">primary</span>.<span class="call">withAlphaComponent</span>(<span class="number">0.9</span>)
    <span class="keyword">static let</span> backgroundColor = <span class="type">UIColor</span>(red: <span class="number">239</span>/<span class="number">255</span>, green: <span class="number">239</span>/<span class="number">255</span>, blue: <span class="number">244</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
}
</code></pre><h1>UI</h1><p>Apple provides great resources for getting started. <a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a> is a great starting point for understanding the thinking behind Apple's choices as well as their preferences. Users have certain expectations and habits when using any application and it's important not to distract them with an unexpected behavior.</p><p>We'll take the inspiration from already existing <em>AppStore</em> app. The main screen of this app has a feed that we want to display in our travel application as well.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_example.png" alt="App Scren Example" width="300"/><p>Apple also provides us with <a href="https://developer.apple.com/design/resources/">design resources</a> that contain <a href="https://www.sketch.com">Sketch</a> files with designs of already existing applications. When learning to sketch or design something, I found it really beneficial to have these in front of me.</p><p>After tweaking these screens and applying our color palette we can create the first version of our design.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_real.png" alt="Feed Screen" width="300"/><p>It displays the essential information such as <em>origin</em>, <em>destination</em>, <em>dates</em> and <em>price</em>. We can also show images which provide visual information about the destination.</p><h2>App Icon</h2><p>Application icon is also a huge part of first impression of any application. We can use same given <a href="https://developer.apple.com/design/resources/">design resources</a> that include examples of created app icons.</p><p>We can use a little bit of imagination and tweak given icons on Sketch to give it a look of a travel or flight application.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.gif" alt="Making of App Icon" width="300"/><p>The resulting icon looks like this.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.png" alt="App Icon" width="300"/><p>We can use <a href="https://makeappicon.com">makeappicon.com</a> to generate all the necessary sizes of the icon so it could be used for different screen sizes as well as on AppStore.</p><h2>What's next?</h2><p>We saw how it's possible to create a clean design of an application without having much knowledge or spending too much time. Especially for small side projects, it's important to concentrate on main functionality and simply use best practices and examples when creating UIs.</p><p>In the next part of the series we'll shift our attention back to the development of our application. We'll see the approach for creating new screens and keeping the view and its logic cleanly separated.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</guid><title>Building a real-world iOS app (Part 3): Fetching and parsing data from API</title><description></description><link>https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</link><pubDate>Mon, 18 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In the <a href="2019-03-17-aerogami_series_part_2">previous part</a> we discovered a way to separate our application into frameworks and setup the architecture of our app to support dependency injection. In this part of the series we'll be fetching and parsing data from the backend using Alamofire and Codable.</p><h2>API Client</h2><p>Although in the scope of this tutorial we'll be using mocked data, the application will be completely ready to support calls to REST APIs.</p><h3>Protocol</h3><p>We define our <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/APIClient.swift">APIClient</a> protocol that serves as a lean interface between data fetching classes and actual implementation.</p><pre><code><span class="keyword">import</span> RxSwift

<span class="keyword">public protocol</span> APIClient {
    <span class="keyword">func</span> get(path: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;
}
</code></pre><p>It returns <code>Observable&lt;Any&gt;</code> which is a part of <code>RxSwift</code>. We won't be going through the basics of <code>RxSwift</code>, so it's beneficial to take a look <a href="https://github.com/ReactiveX/RxSwift">official documentation</a> before continuing.</p><h3>Implementation</h3><p>The actual implementation is in <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">BaseAPIClient</a>, which uses <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> for making HTTP requests. The only method <code>get(path: String)</code> makes <code>GET</code> request by concating given path to a base URL.</p><pre><code><span class="keyword">import</span> RxAlamofire
<span class="keyword">import</span> RxSwift

<span class="keyword">public class</span> BaseAPIClient: <span class="type">APIClient</span> {
    <span class="keyword">private let</span> baseUrl: <span class="type">String</span>

    <span class="keyword">public init</span>(baseUrl: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">baseUrl</span> = baseUrl
    }

    <span class="keyword">public func</span> get(path: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt; {
        <span class="keyword">return</span> <span class="type">RxAlamofire</span>
            .<span class="call">requestJSON</span>(.<span class="dotAccess">get</span>, <span class="string">"</span>\(baseUrl)<span class="string">/</span>\(path)<span class="string">"</span>)
            .<span class="call">map</span> { $1 }
    }
}
</code></pre><h3>Mock</h3><p>If you clone the <a href="https://github.com/staskus/aerogami-ios">repository</a>, it will use <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">MockAPIClient</a> which takes data from files. Because it uses the same public interface, <code>MockAPIClient</code> and <code>BaseAPIClient</code> can be interchanged depending on needs. See <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelApplication/Application/Assembly/ApplicationAssembly.swift">ApplicationAssembly</a> which assigns dependencies for <code>APIClient</code> interface. Depending on different configuration, it can assign any of these two. This little example perfectly illustrates the power of <code>dependency injection</code> and usage of <code>protocols</code>.</p><h2>Data</h2><p>The main entity in this project is a <code>Trip</code>. It describes the origin and destination of the flight as well as price and dates.</p><pre><code>{
   <span class="string">"currency"</span>:<span class="string">"EUR"</span>,
   <span class="string">"created_at"</span>:<span class="number">1547991979887</span>,
   <span class="string">"airlines"</span>:<span class="string">"FR"</span>,
   <span class="string">"departure_at"</span>:<span class="number">1552848000000</span>,
   <span class="string">"destination"</span>:{
      <span class="string">"city"</span>:<span class="string">"Malaga"</span>,
      <span class="string">"country_code"</span>:<span class="string">"ES"</span>,
      <span class="string">"airport_code"</span>:<span class="string">"AGP"</span>
   },
   <span class="string">"flight_number"</span>:<span class="number">4048</span>,
   <span class="string">"departure"</span>:{
      <span class="string">"city"</span>:<span class="string">"Copenhagen"</span>,
      <span class="string">"country_code"</span>:<span class="string">"DK"</span>,
      <span class="string">"airport_code"</span>:<span class="string">"CPH"</span>
   },
   <span class="string">"return_at"</span>:<span class="number">1553153100000</span>,
   <span class="string">"price"</span>:<span class="number">72</span>,
   <span class="string">"id"</span>:<span class="string">"c4449ff0-1cb9-11e9-b9f8-b3ba95b35000"</span>,
   <span class="string">"expires_at"</span>:<span class="number">1739200281000</span>
}
</code></pre><p><a href="https://github.com/staskus/aerogami-ios/blob/master/TravelApplication/Application/Mocking/TripMock.json">See full Trips JSON file</a></p><p>We'll define our entities inside <code>TravelKit</code> framework. They should be made public, so they could be reached inside other frameworks. We'll use excellent <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> type that starting from Swift 4 provides a powerful and clean way to encode and decode data.</p><p>Take a look at <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelKit/Repositories/Trip/Trip.swift">Trip</a> class. We don't need to define keys of each values if they match. It's possible to define what naming strategies are used during decoding or encoding process. For example, <code>.convertFromSnakeCase</code> strategy, as its name suggests, converts keys from snake case and assigns values automatically if they match.</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">public struct</span> Trip: <span class="type">Codable</span>, <span class="type">Equatable</span> {
    <span class="keyword">public var</span> id: <span class="type">String</span> = <span class="string">""</span>
    <span class="keyword">public var</span> currency: <span class="type">String</span> = <span class="string">""</span>
    <span class="keyword">public var</span> price = <span class="number">0</span>

    <span class="keyword">public var</span> airlines = <span class="string">""</span>
    <span class="keyword">public var</span> flightNumber = <span class="number">0</span>

    <span class="keyword">public var</span> destination: <span class="type">TripLocation</span>!
    <span class="keyword">public var</span> departure: <span class="type">TripLocation</span>!

    <span class="keyword">public var</span> createdAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> departureAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> returnAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> expiresAt = <span class="type">Date</span>()

    <span class="keyword">public init</span>() {}
}

<span class="keyword">public struct</span> TripLocation: <span class="type">Codable</span>, <span class="type">Equatable</span> {
    <span class="keyword">public var</span> city: <span class="type">String</span>!
    <span class="keyword">public var</span> countryCode: <span class="type">String</span>!
    <span class="keyword">public var</span> airportCode: <span class="type">String</span>!

    <span class="keyword">public init</span>() {}
}
</code></pre><p>After receiving <code>JSON</code> data we can define <code>decoder</code> and automatically parse values.</p><pre><code>     <span class="keyword">public static var</span> decoder: <span class="type">JSONDecoder</span> = {
        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()
        decoder.<span class="property">keyDecodingStrategy</span> = .<span class="dotAccess">convertFromSnakeCase</span>
        decoder.<span class="property">dateDecodingStrategy</span> = .<span class="dotAccess">millisecondsSince1970</span>
        <span class="keyword">return</span> decoder
    }()

    <span class="keyword">let</span> trips = <span class="keyword">try</span>? decoder.<span class="call">decode</span>([<span class="type">Trip</span>].<span class="keyword">self</span>, from: data)
</code></pre><p>With this simple and straightforward Codable API our data is cleanly parsed into statically typed object or array of objects after <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelDataKit/Repositories/Trip/Remote/APITripDataStore.swift">fetching from API</a>.</p><h2>Repositories</h2><p>Classes that are used to fetch data will be called repositories. In <code>TravelKit</code> we'll only define the protocols of these repositories. Our UI framework <code>TravelFeatureKit</code> will only know about <code>TravelKit</code> and protocols of repositories thus the implementations, defined in <code>TravelDataKit</code>, will be easily changeable.</p><p>Our <code>TripRepository</code> protocol defines the only way to fetch trips.</p><pre><code><span class="keyword">import</span> RxSwift

<span class="keyword">public protocol</span> TripRepository {
    <span class="keyword">func</span> getTrips(in region: <span class="type">String</span>?) -&gt; <span class="type">Observable</span>&lt;[<span class="type">Trip</span>]&gt;
}
</code></pre><p>Because our UI framework will only know about this protocol, we will be able to provide different types of implementations. <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/TripRepository.swift">TripRepository</a> implementation defined in <code>TravelDataKit</code> calls the <code>API</code> to fetch data and parses it using <code>Coadable</code>. However, <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/FavoriteTripRepository.swift">FavoriteTripRepository</a> which also implements <code>TripRepository</code> interface, uses <code>UserDefaults</code> to fetch locally liked <code>Trips</code>. It allows us to generate 2 completely different screens in our app. One showing the current feed of flights fetched from the API and another of liked and locally saved trips. Here <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelFeatureKit/Features/Favorites/FavoritesAssembly.swift">FavoritesAssembly</a> simply injects necessary dependencies needed for <em>favorites</em> to a <code>FavoriteFeed</code> feature.</p><h2>Design</h2><p>Before continuing creating the app, we'll see how we can quickly create simple application designs using Sketch or similar tools. In the next part of the series we'll overview the approach.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</guid><title>Building a real-world iOS app (Part 2): Separating application into frameworks</title><description></description><link>https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</link><pubDate>Sun, 17 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In this part of the series we'll overview how to properly setup the application.</p><h2>Creating Frameworks</h2><p>As we talked in the <a href="https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1">previous part</a>, we'll begin the creation of the project by creating 3 separate frameworks inside our XCode project (<code>TravelKit</code>, <code>TravelDataKit</code>, <code>TravelFeatureKit</code>). An article on <a href="https://www.raywenderlich.com/5109-creating-a-framework-for-ios">raywenderlich.com</a> has a thorough explanation of the whole process.</p><p>After creating frameworks, project navigator should look something like in the picture below.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part2/project_frameworks.png" alt="Frameworks in the Project Navigator" width="300"/><h2>Setting up CocoaPods</h2><p>We'll be using <a href="https://cocoapods.org">CocoaPods</a> for managing dependencies in our project. Although setting up CocoaPods is fairly straightforward, there can be some difficulties when having local frameworks involved. The configuration is defined in <code>Podfile</code> which is located in the root folder of the project.</p><p><code>Podfile</code> will be configured in a way that is clean and clear so it would not get messy when number of dependencies in the project grow. Essentially, we'll define the reusable pods at the top of the file and group different groups of pods that can be reused for different frameworks.</p><p>The part of <code>Podfile</code> that defines pods of <code>TravelKit</code>.</p><pre><code>platform :ios, '<span class="number">11.0</span>'
use_frameworks!
inhibit_all_warnings!

deployment_target = '<span class="number">11.0</span>'

workspace '<span class="type">TravelApplication</span>.<span class="property">xcworkspace</span>'

#Versions
$swinjectVersion =                    '~&gt; <span class="number">2.4</span>'
$swiftDateVersion =                   '~&gt; <span class="number">5.0</span>'
&lt;...&gt;

def shared_TravelKit_pods
    pod '<span class="type">RxSwift</span>',                    $rxSwiftVersion
    pod '<span class="type">SwiftDate</span>',                  $swiftDateVersion
end

target '<span class="type">TravelKit</span>' <span class="keyword">do</span>
    project '<span class="type">TravelKit</span>.<span class="property">xcodeproj</span>'
    platform :ios, deployment_target

    shared_TravelKit_pods

  target '<span class="type">TravelKitTests</span>' <span class="keyword">do</span>
    project '<span class="type">TravelKit</span>.<span class="property">xcodeproj</span>'
    inherit! :search_paths

    shared_testing_pods
  end
end
&lt;...&gt;
</code></pre><p>These different shared pods should be assembled and used of the actual application target.</p><pre><code>&lt;...&gt;
def shared_Apps_pods
  shared_TravelKit_pods
  &lt;...&gt;
end

target '<span class="type">TravelApplication</span>' <span class="keyword">do</span>
    project '<span class="type">TravelApplication</span>.<span class="property">xcodeproj</span>'
    platform :ios, deployment_target
    shared_Apps_pods
end
&lt;...&gt;
</code></pre><p>The full <a href="https://github.com/staskus/aerogami-ios/blob/master/Podfile">Podfile</a> can be found on <code>GitHub</code> as the rest of the project.</p><h2>Dependency Injection</h2><p>I prefer to think early about the way dependencies will be managed inside the application. Although dependency injection can be achieved without 3rd party libraries, for this project we'll use <a href="https://github.com/Swinject/Swinject">Swinject</a> that has easy to use interfaces for managing dependencies.</p><p>Our classes will use <code>initializer injection</code> thus all the dependencies will be given through the initializer. The classes will be initialized in assemblies. Assembly is a <code>Swinject</code> class which has access to a container of already injected dependencies and provides a way to register new dependencies.</p><p>For example, this is how the assembly of the <code>Feed</code> that displays the list of flights might looks like:</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Swinject
<span class="keyword">import</span> TravelKit

<span class="keyword">public class</span> FeedAssembly: <span class="type">Assembly</span> {

    <span class="keyword">public init</span>() {
    }

    <span class="keyword">public func</span> assemble(container: <span class="type">Container</span>) {
        container.<span class="call">register</span>(<span class="type">FeedConfigurator</span>.<span class="keyword">self</span>) { r <span class="keyword">in</span>
            <span class="type">FeedConfigurator</span>(
                regionRepository: r.<span class="call">resolve</span>(<span class="type">RegionRepository</span>.<span class="keyword">self</span>)!,
                tripRepository: r.<span class="call">resolve</span>(<span class="type">TripRepository</span>.<span class="keyword">self</span>)!,
                airportRepository: r.<span class="call">resolve</span>(<span class="type">AirportRepository</span>.<span class="keyword">self</span>)!,
                tripImageRepository: r.<span class="call">resolve</span>(<span class="type">TripImageRepository</span>.<span class="keyword">self</span>)!
                )
            }
            .<span class="call">initCompleted</span> { (resolver, feedConfigurator) <span class="keyword">in</span>
                feedConfigurator.<span class="property">bookTripConfigurator</span> = resolver.<span class="call">resolve</span>(<span class="type">BookTripConfigurator</span>.<span class="keyword">self</span>)!
            }
            .<span class="call">inObjectScope</span>(.<span class="dotAccess">container</span>)
    }
}
</code></pre><p>Here, we inject <code>FeedConfigurator</code> class. It is essentially a factory class for the whole <code>Feed</code> feature and its view. <code>Swinject</code> automatically passes the dependencies such as <code>RegionRepository</code> or <code>TripRepository</code>. We expect these dependencies to be injected in another assembly so we can resolve it here.</p><p>Our application will have <code>AssemblerFactory</code> that will contain all the different assemblies of the application and create them during initialization process.</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Swinject
<span class="keyword">import</span> TravelFeatureKit
<span class="keyword">import</span> TravelDataKit

<span class="keyword">class</span> AssemblerFactory {

    <span class="keyword">func</span> create() -&gt; <span class="type">Assembler</span> {
        <span class="keyword">let</span> assemblies: [<span class="type">Assembly</span>] = [
            <span class="type">ApplicationAssembly</span>(),
            <span class="type">RegionRepositoryAssembly</span>(),
            <span class="type">TripRepositoryAssembly</span>(),
            <span class="type">AirportRepositoryAssembly</span>(),

            <span class="type">MainAssembly</span>(),
            <span class="type">FavoritesAssembly</span>(),
            <span class="type">FeedAssembly</span>(),
            <span class="type">BookTripAssembly</span>(),
            <span class="type">BookURLRepositoryAssembly</span>(affiliateId: <span class="type">Constants</span>.<span class="property">affiliateId</span>)
        ]

        <span class="keyword">let</span> assembler = <span class="type">Assembler</span>(assemblies)

        <span class="keyword">return</span> assembler
    }
}
</code></pre><p>We use this assembly to create the first <code>ViewController</code> of the application and set it as <code>rootViewController</code>. See <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelApplication/Application/ApplicationLoader.swift">ApplicationLoader</a>.</p><pre><code>   <span class="keyword">self</span>.<span class="property">assembler</span> = <span class="type">AssemblerFactory</span>().<span class="call">create</span>()
  <span class="keyword">let</span> rootConfigurator = assembler.<span class="property">resolver</span>.<span class="call">resolve</span>(<span class="type">MainConfigurator</span>.<span class="keyword">self</span>)!
  <span class="keyword">let</span> rootViewController = rootConfigurator.<span class="call">createViewController</span>()
  window?.<span class="property">rootViewController</span> = rootViewController
  window?.<span class="call">makeKeyAndVisible</span>()
</code></pre><p>In the following parts of the series we'll be creating classes for fetching and presenting data that will use assemblies for injecting dependencies. We'll see more closely how having proper dependency injection allows code to be more reusable, safe and testable.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</guid><title>Building a real-world iOS app (Part 1): Introduction</title><description></description><link>https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</link><pubDate>Mon, 11 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When learning any new technology I find it beneficial to follow a real world example. In this tutorial series we'll be creating and releasing an iOS application. The application will be created by showing a real thinking process, going through essential steps and providing the motivation behind them. Although every single line of code won't be covered, all of it will be always available on <a href="https://github.com/staskus/aerogami-ios">GitHub</a>.</p><h2>Prerequisites</h2><p>Prior knowledge of iOS development and Swift syntax is needed.</p><h2>Introduction</h2><h3>Our Project</h3><p>We'll be creating a flight discovery application. The users of our application should be able to:</p><ol><li>See the <em>feed</em> of <em>flights</em></li><li>See the <em>date</em>, <em>price</em>, <em>origin</em> and <em>destination</em> of each <em>flight</em></li><li>Book the <em>flight</em>.</li></ol><p>In the scope of this project we won't be concerned about the source of information. Our application will use mocked flight information data. However, the structure of the application will support an easy integration with any Rest API.</p><h3>Our Approach</h3><p>Throughout the series we'll cover these topics one-by-one:</p><ol><li>Data Fetching and Parsing</li><li>Testing</li><li>Code Separation into Frameworks</li><li>Design using Sketch</li><li>Clean Swift Architecture</li><li>Building the UI and Displaying the Data</li><li>Release Process</li></ol><h3>The Final Product</h3><p>Here is the sneak peek of how the final product will look like. The full codebase can be found on <a href="https://github.com/staskus/aerogami-ios">GitHub</a>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/screenshot.png" alt="Application Screenshot" width="200"/><h2>High Level View</h2><p>Before we start, it's beneficial to understand how we're going to approach the creation of this application.</p><h3>Separation of Concerns</h3><p>Essentially our application should be able to perform 3 main tasks:</p><ol><li>Fetch data</li><li>Parse data</li><li>Display data</li></ol><p>We'll separate these different concerns into frameworks for our code to be decoupled and flexible. The primitive diagram of the architecture is displayed in the picture bellow. We'll define data models and protocols in <code>TravelKit</code>. This framework will contain data fetching protocols, which will be implemented in <code>TravelDataKit</code>. DataKit, as its name suggests, will be used for fetching, persisting and providing data. User interface will only know about data models and protocols and won't be concerned about the implementation. We'll call this framework <code>TravelFeatureKit</code>. The entry point of our application will initialize the dependencies required for all the frameworks and present the root view described in <code>TravelFeatureKit</code>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/architecture.png" alt="Application Architecture" width="300"/><p>In the next part of the series we'll continue by explaining how to create frameworks and setup the base of the application.</p>]]></content:encoded></item></channel></rss>