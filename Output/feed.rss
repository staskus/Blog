<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Povilas Staškus</title><description>iOS Developer</description><link>https://www.staskus.io</link><language>en</language><lastBuildDate>Thu, 28 Apr 2022 15:20:56 +0300</lastBuildDate><pubDate>Thu, 28 Apr 2022 15:20:56 +0300</pubDate><ttl>250</ttl><atom:link href="https://www.staskus.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.staskus.io/notes/Recursion%20and%20Dynamic%20Programming</guid><title>Recursion and Dynamic Programming</title><description></description><link>https://www.staskus.io/notes/Recursion%20and%20Dynamic%20Programming</link><pubDate>Thu, 28 Apr 2022 15:20:47 +0300</pubDate><content:encoded><![CDATA[<h2>Recursion</h2><p>Hints for problems that are good candidates for recursion: <em> Compute the nth element to... </em> Write code to list the first n... * Implement a method to compute all...</p><p>Recursive problems are space-intensive and take at least O(n) of memory. The same problems can be solved iteratively although it's usually more complex.</p><h2>Dynamic Programming</h2><p>Dynamic programming is useful when trying to optimize something <strong>given a constraint</strong>. We can use DP when the problem can be broken into subproblems and they don't depend on each other.</p><ol><li>Every DP solution involes a grid</li><li>The values in the grid cells are what we try to optimize</li><li>Each cell is a subproblem</li></ol><p>Approaches: <em> Bottom-Up: Start by solving the most simple case </em> Top-Down: Start with more complex and think about how to split them into subproblems * Half-and-Half: Dividing the data set in half to solve the problem and then merging together the results</p><h2>Example problems</h2><h3>Tribonacci Number</h3><img src="https://www.staskus.io/images/notes/b8daa97dce2af0a8feb01d20e075456e68904da809bc44e9afb26ac5a82ca17e.png" alt="LeetCode.com"/><p>Such a problem can also be solved iteratively. When we use memoization we can notice that we only need to know the last 3 numbers. Instead of saving all the numbers in the dictionary, we can only save the last 3 in the variable:</p><pre><code><span class="comment">// Time - O(n), Space - 0(1)</span>
<span class="keyword">func</span> tribonacci(<span class="keyword">_</span> n: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">var</span> memo0 = <span class="number">0</span>
    <span class="keyword">var</span> memo1 = <span class="number">1</span>
    <span class="keyword">var</span> memo2 = <span class="number">1</span>
    
    <span class="keyword">guard</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">0</span> }
    <span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">1</span> }
    
    <span class="keyword">var</span> temp = <span class="number">0</span>
    
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">3</span>...n {
        temp = memo0 + memo1 + memo2
        memo0 = memo1
        memo1 = memo2
        memo2 = temp
    }
    
    <span class="keyword">return</span> temp
}
</code></pre><p>We can also save time instead of space by adding the results into an array before returning the value. This is only applicable if we know the upper bound. Let's say we know that n will be a maximum 40, then we can precompute those 40 values and whenever anyone asks for tribonacci we just return a result.</p><pre><code><span class="comment">// Time - O(1), Space - O(n)</span> 
<span class="keyword">func</span> tribonacci(<span class="keyword">_</span> n: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">guard</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">0</span> }
    <span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">1</span> }
    
    <span class="keyword">var</span> nums: [<span class="type">Int</span>] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">3</span>...n {
        nums.<span class="call">append</span>(nums[i-<span class="number">1</span>] + nums[i-<span class="number">2</span>] + nums[i-<span class="number">3</span>])
    } 

    <span class="keyword">return</span> nums[n]
}
</code></pre><h3>Unique Paths with Obstacles in Grid</h3><p>When starting from (0,0) how many unique paths there are to reach (n-1, n-1) if the path does not encounter obstacles?</p><p>We can use the grid itself as a way to convey information. We first set values of the first column and the first row. If they aren't any obstacles the value is 1, if there're the value is 0. Then we can iterate from the rest of the grid and the value of the cell are the sum of two values from the left and the top. The result at the (n-1, n-1) is the number of unique paths.</p><p>O(M×N), O(1)</p><h3>Divide 2 integers only using addition and subtraction</h3><p>This brute force solution is to do the iteration and sum divisor until we get a number larger than the dividend. This is not efficient.</p><p>The more efficient solution is to use <strong>exponential search</strong> which in spirit is similar to a binary search.</p><h3>Unique permutations with duplicate input</h3><p>If we are given an array of numbers with possible duplications and we need to provide all the possible permutations, we need to start by creating a frequency table of each number (character). This way if we get [1, 1, 1, 1, 1] don't crate duplicating permutations.</p><p>O(n!)</p><h3>Generate Parenthesis</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>This requires a <em>backtracking</em> recursive algorithm. With this concrete issue, the hard part is the calculation of time complexity.</p><p>It's better to know that this is a backtracking algorithm, that has generally a performance O(2^n). In this concrete scenario, we have less complexity, as we don't need to explore all the permutations of parenthesis due to the relationship of closed/opened parenthesis.</p><pre><code><span class="keyword">private var</span> max = <span class="number">0</span>

<span class="keyword">func</span> generateParenthesis(<span class="keyword">_</span> n: <span class="type">Int</span>) -&gt; [<span class="type">String</span>] {****
    max = n
    <span class="keyword">var</span> result: [<span class="type">String</span>] = []
    <span class="call">backtrack</span>(&amp;result, <span class="number">0</span>, <span class="number">0</span>)
    <span class="keyword">return</span> result
}

<span class="keyword">private func</span> backtrack(<span class="keyword">_</span> result: <span class="keyword">inout</span> [<span class="type">String</span>],
                        <span class="keyword">_</span> opening: <span class="type">Int</span>,
                        <span class="keyword">_</span> closing: <span class="type">Int</span>,
                        <span class="keyword">_</span> current: <span class="type">String</span> = <span class="string">""</span>) {
                    
    <span class="keyword">if</span> current.<span class="property">count</span> == max * <span class="number">2</span> {
        result.<span class="call">append</span>(current)
        <span class="keyword">return</span>
    }
    
    <span class="keyword">if</span> opening &lt; max {
        <span class="keyword">var</span> current = current
        current.<span class="call">append</span>(<span class="string">"("</span>)
        <span class="call">backtrack</span>(&amp;result, opening + <span class="number">1</span>, closing, current)
    }
    
    <span class="keyword">if</span> closing &lt; opening {
        <span class="keyword">var</span> current = current
        current.<span class="call">append</span>(<span class="string">")"</span>)
        <span class="call">backtrack</span>(&amp;result, opening, closing + <span class="number">1</span>, current)
    }
}
</code></pre><h3>Coin Change</h3><p>Given the set of coins (1, 2, 5) in how many ways we can combine it to a given sum (100).</p><p>The trick for a quick solution is this algorithm.</p><p>We calculate the number of combinations for a given amount by adding to it already calculates combinations for x-coin amount <code>combinations[x] += combinations[x - coin]</code>.</p><pre><code><span class="keyword">var</span> combinations = <span class="type">Array</span>(repeating: <span class="number">0</span>, count: amount + <span class="number">1</span>)
        combinations[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// algo requires it</span>
        
        <span class="keyword">for</span> coin <span class="keyword">in</span> coins {
            <span class="keyword">if</span> coin &lt;= amount {
                <span class="keyword">for</span> x <span class="keyword">in</span> coin..&lt;amount+<span class="number">1</span> {
                    combinations[x] += combinations[x - coin]
                }
            }
        }
        
        <span class="keyword">return</span> combinations[amount]
</code></pre><h3>Coin Change</h3><p>Given the array of coins, return the fewest number of coins that you need to make up that amount.</p><h3>Dynamic Programming - top down approach</h3><p>Use memoization and recursion:</p><pre><code><span class="comment">// Dynamic programming - top down approach
// Time: O(S*n) where S is the amount and n is denomination count
// Space complexity O(s) for memo</span>
<span class="keyword">func</span> coinChange(<span class="keyword">_</span> coins: [<span class="type">Int</span>], <span class="keyword">_</span> amount: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">var</span> memo: [<span class="type">Int</span>: <span class="type">Int</span>] = [:]
    <span class="keyword">return</span> <span class="call">coinsChange</span>(coins, amount, &amp;memo)
}

<span class="keyword">private func</span> coinsChange(<span class="keyword">_</span> coins: [<span class="type">Int</span>], <span class="keyword">_</span> remaining: <span class="type">Int</span>, <span class="keyword">_</span> memo: <span class="keyword">inout</span> [<span class="type">Int</span>: <span class="type">Int</span>]) -&gt; <span class="type">Int</span> {
    <span class="keyword">if</span> remaining &lt; <span class="number">0</span> { <span class="keyword">return</span> -<span class="number">1</span> }
    <span class="keyword">if</span> remaining == <span class="number">0</span> { <span class="keyword">return</span> <span class="number">0</span> }
    
    <span class="keyword">if let</span> previouslyCalculatedCount = memo[remaining] {
        <span class="keyword">return</span> previouslyCalculatedCount
    }
    
    <span class="keyword">var</span> minValue = <span class="type">Int</span>.<span class="property">max</span>
    
    <span class="keyword">for</span> coin <span class="keyword">in</span> coins {
        <span class="keyword">let</span> result = <span class="call">coinsChange</span>(coins, remaining - coin, &amp;memo)
        <span class="keyword">if</span> result &gt;= <span class="number">0</span> &amp;&amp; result &lt; minValue {
            minValue = result + <span class="number">1</span>
        }
    }
    
    memo[remaining] = minValue == <span class="type">Int</span>.<span class="property">max</span> ? -<span class="number">1</span> : minValue
    <span class="keyword">return</span> memo[remaining]!
}
</code></pre><h3>Dynamic Programming - Bottom up approach</h3><p>The key is understanding this line <code>counts[currentAmount] = min(counts[currentAmount], counts[currentAmount - coins[coinIndex]] + 1)</code></p><p>If we get a number not equal to max in <code>counts[currentAmount - coins[coinIndex]]</code> it means that we already calculated a minimum amount and we can just add one coin <code>coin[coinIndex]</code> .</p><pre><code><span class="comment">// Dynamic programming - bottom up approach</span>

<span class="keyword">func</span> coinChange(<span class="keyword">_</span> coins: [<span class="type">Int</span>], <span class="keyword">_</span> amount: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">guard</span> amount &gt; <span class="number">0</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">0</span> }
    
    <span class="keyword">let</span> max = amount + <span class="number">1</span>
    <span class="keyword">var</span> counts: [<span class="type">Int</span>] = <span class="type">Array</span>(repeating: max, count: amount + <span class="number">1</span>)
    counts[<span class="number">0</span>] = <span class="number">0</span>
    
    <span class="keyword">for</span> currentAmount <span class="keyword">in</span> <span class="number">1</span>...amount {
        <span class="keyword">for</span> coinIndex <span class="keyword">in</span> <span class="number">0</span>..&lt;coins.<span class="property">count</span> {
            <span class="keyword">if</span> coins[coinIndex] &lt;= currentAmount {
                counts[currentAmount] = <span class="call">min</span>(counts[currentAmount], counts[currentAmount - coins[coinIndex]] + <span class="number">1</span>)
            }
        }
    }
    
    <span class="keyword">return</span> counts[amount] == max ? -<span class="number">1</span> : counts[amount]
}
</code></pre><h3>Optimal Set Of Camping</h3><p>Given list of items:</p><pre><code><span class="keyword">let</span> items = [
    <span class="type">Item</span>(name: <span class="string">"Water"</span>, weight: <span class="number">3</span>, value: <span class="number">10</span>), 
    <span class="type">Item</span>(name: <span class="string">"Book"</span>, weight: <span class="number">1</span>, value: <span class="number">3</span>), 
    <span class="type">Item</span>(name: <span class="string">"Food"</span>, weight: <span class="number">2</span>, value: <span class="number">9</span>),
    <span class="type">Item</span>(name: <span class="string">"Jacket"</span>, weight: <span class="number">2</span>, value: <span class="number">5</span>), 
    <span class="type">Item</span>(name: <span class="string">"Camera"</span>, weight: <span class="number">1</span>, value: <span class="number">6</span>), 
]
</code></pre><p>and a bag limit of <code>capacity</code>. Find which items to take to maximize the total value.</p><pre><code><span class="keyword">struct</span> Item {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> weight: <span class="type">Int</span>
    <span class="keyword">let</span> value: <span class="type">Int</span>
}

<span class="keyword">func</span> optimalSetOfItems(<span class="keyword">_</span> capacity: <span class="type">Int</span>, <span class="keyword">_</span> items: [<span class="type">Item</span>]) -&gt; [<span class="type">Item</span>] {

    <span class="comment">// We need to keep both total values and all items corresponding to the total value
    // We increase the capacity by one, so we wouldn't need to handle a case where we look back at dp table</span>
    <span class="keyword">var</span> dpItems: [[[<span class="type">Item</span>]]] = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: [], count: capacity + <span class="number">1</span>), count: items.<span class="property">count</span> + <span class="number">1</span>)
    <span class="keyword">var</span> dpValues: [[<span class="type">Int</span>]] = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: <span class="number">0</span>, count: capacity + <span class="number">1</span>), count: items.<span class="property">count</span> + <span class="number">1</span>)

    <span class="keyword">for</span> itemIndex <span class="keyword">in</span> <span class="number">1</span>...items.<span class="property">count</span> {

        <span class="comment">// A key to dynamic programming, we iterate through all capacities</span>
        <span class="keyword">for</span> currentCapacity <span class="keyword">in</span> <span class="number">1</span>...capacity {
                <span class="keyword">let</span> item = items[itemIndex - <span class="number">1</span>]

                <span class="comment">// Skip if an item is heavier than the current capacity</span>
                <span class="keyword">if</span> item.<span class="property">weight</span> &lt;= currentCapacity {
                    
                    <span class="comment">// We already know the best possible value from all the items up to [itemIndex - 1]</span>
                    <span class="keyword">let</span> totalPreviousValue = dpValues[itemIndex - <span class="number">1</span>][currentCapacity]

                    <span class="comment">// Take current item value
                    // We already know the best possible value for the remaining weight. We calculated it for the previous item
                    // Sum those 2 values</span>
                    <span class="keyword">let</span> totalPotentialValue = dpValues[itemIndex - <span class="number">1</span>][currentCapacity - item.<span class="property">weight</span>] + item.<span class="property">value</span>

                    <span class="comment">// Check if our new value is larger than the total for the previous item</span>
                    <span class="keyword">if</span> totalPreviousValue &gt; totalPotentialValue {
                        <span class="comment">// If previous value is larger, set the same value and same items</span>
                        dpItems[itemIndex][currentCapacity] = dpItems[itemIndex - <span class="number">1</span>][currentCapacity]
                        dpValues[itemIndex][currentCapacity] =  totalPreviousValue
                    } <span class="keyword">else</span> {
                        <span class="comment">// Else set new set of items and the new value</span>
                        dpItems[itemIndex][currentCapacity] = dpItems[itemIndex - <span class="number">1</span>][currentCapacity - item.<span class="property">weight</span>] + [item]
                        dpValues[itemIndex][currentCapacity] = totalPotentialValue
                    }
            }
        }  
    }

    <span class="keyword">return</span> dpItems[items.<span class="property">count</span>][capacity]
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Useful%20Algorithms</guid><title>Useful algorithms and data structures</title><description></description><link>https://www.staskus.io/notes/Useful%20Algorithms</link><pubDate>Thu, 28 Apr 2022 15:20:43 +0300</pubDate><content:encoded><![CDATA[<h2>The Fourier transform</h2><ul><li>Separate a song into its frequences</li><li>Compress songs and images</li><li>Earthquake prediction</li><li>DNA analysis</li></ul><h2>Searching, inserting, deleting</h2><ul><li>B-trees</li><li>Red-black trees</li><li>Heaps</li><li>Splay trees</li></ul><h2>Search Engines</h2><ul><li>Inverted indexes</li></ul><h2>Parallel algorithms</h2><ul><li>MapReduce (Using it through Apache Hadoop)<ul></ul></li></ul><h2>Bloom filters and HyperLogLog</h2><p>They are used when fast access is needed to a large set of data and hash tables would be just too large.</p><ul><li>Bloom filters give a probabilistic answer but they take up very little space compared to a hash table</li><li>HyperLogLog approximates the number of unique elements in a set. It doesn't give an exact answer but it takes only a fraction of the memory.</li></ul><h2>The SHA algorithms</h2><h3>Simhash</h3><p>A locality-sensitive hash. Similar values give similar hashes. Used by Google to detect duplicates while crawling the web, it could be used to check if a student was copying an essay from the web or check for copyrighted content.</p><h3>Diffie-Hellman key exchange</h3><p>Allows encrypting a message so it can only be read by the person you sent the message to.</p><p>It uses two keys: public and private. The message is encrypted by a public key but only a private key can decrypt it.</p><p>RSA is a successor of this algorithm.</p><h3>Linear programming</h3><p>Linear programming is used to maximize a result given some constraints. It uses <strong>Simplex</strong> algorithm. All graph problems are just a subset of linear programming.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/K-nearest%20neighbors</guid><title>k-nearest neighbors</title><description></description><link>https://www.staskus.io/notes/K-nearest%20neighbors</link><pubDate>Thu, 28 Apr 2022 12:47:23 +0300</pubDate><content:encoded><![CDATA[<p>k-nearest neighbors (KNN) algorithm is used for classification.</p><h2>Feature extraction</h2><p>To classify a set of values and find k-nearest neighbors we first need to find some features (like size or color).</p><p>No matter how many features there are, we can calculate the distance by applying formula: <strong>sqrt((a1-a2)^2 + (b1-b2)^2 + (c1-c2)^2 ... + (h1-h2)^2 )</strong>. For a more niuanced result that takes into account how the user rates everything in general <strong>Cosine similarity</strong> is used to find closest neighbors.</p><h2>Classification</h2><p>Categorization into a group.</p><h2>Regression</h2><p>Prediction of a response.</p><h2>Examples</h2><h3>Optical Character Recognition</h3><p>How do understand a text from a photo? One of the ways is to use KNN algorithm and analyzes different features of the characters (curves, lines).</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Trees%20and%20Graphs</guid><title>Trees and Graphs</title><description></description><link>https://www.staskus.io/notes/Trees%20and%20Graphs</link><pubDate>Wed, 27 Apr 2022 09:44:04 +0300</pubDate><content:encoded><![CDATA[<h1>Trees</h1><p><strong>Tree</strong> - a data structure composed of nodes. Each tree has a root node, each child has zero or more child nodes and doesn't have cycles.</p><p><strong>Leaf Node</strong> - a node with no children.</p><h2>Binary trees</h2><p><strong>Binary Tree</strong> - each node has up to two children.</p><p><strong>Binary Search Tree</strong> - when <em>every</em> node is specifically ordered.</p><p><strong>Complete Binary Tree</strong> - every level is filled except the last level. Last level filling from left to right.</p><p><strong>Full Binary Tree</strong> - each node has either zero or two children</p><p><strong>Perfect Binary Tree</strong> - full, complete and all nodes at the same level.</p><h3>Traversal</h3><h4>In-Order</h4><p>First visit the left branch, then the current node then the right branch.</p><pre><code><span class="keyword">func</span> traverseInOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">traverseInOrder</span>(node?.<span class="property">left</span>)
        <span class="call">visit</span>(node) <span class="comment">// for example just print</span>
        <span class="call">traverseInOrder</span>(node?.<span class="property">right</span>)
    }
}
</code></pre><h4>Pre-Order</h4><p>First visit the current node, then the others.</p><pre><code><span class="keyword">func</span> traversePreOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">visit</span>(node)
        <span class="call">traversePreOrder</span>(node?.<span class="property">left</span>)
        <span class="call">traversePreOrder</span>(node?.<span class="property">right</span>)
    }
}
</code></pre><h4>Post-Order</h4><p>First visit left and right branches, then the current node.</p><pre><code><span class="keyword">func</span> traversePostOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">traversePostOrder</span>(node?.<span class="property">left</span>)
        <span class="call">traversePostOrder</span>(node?.<span class="property">right</span>)
        <span class="call">visit</span>(node)
    }
}
</code></pre><h2>Balancing</h2><p><strong>Balanced tree</strong> - doesn't mean that right and left sides are of the same size. It means that its balance might allow for specific effective operations such as O(log n) insert and find.</p><h2>Binary Heaps</h2><p><strong>Min-heap</strong> - is a complete binary tree where each node is smaller than its children. The root is the minimum element in the tree.</p><h3>Insert</h3><p>We insert at the rightmost empty spot and then go up by swapping with the parent until it's smaller than its parent.</p><p>O(log n)</p><h3>Get Minimum Element</h3><p>It's always at the top.</p><h3>Remove Minimum Element</h3><ol><li>Remove the top element</li><li>Replace it with the bottommost-rightmost element</li><li>Go from the top to the bottom swapping it with the children until it reaches its place</li></ol><p>O(log n)</p><h2>Trie (Prefix Tree)</h2><p>An n-ary tree where characters are stored at each node. * node indicates a complete word. Each node can have children the number of the size of the alphabet.</p><p>Usage: <em> Storing the entire language for quick prefix lookups. </em> Lists of valid words</p><h1>Graphs</h1><p>A graph is a collection of nodes with edges between some of them.</p><p><strong>Connected graph</strong> - if there's a path between every pair of vertices.</p><p><strong>Acyclic graph</strong> - a graph without cycles</p><h2>Adjacency List</h2><p>A way to represent a graph</p><pre><code><span class="keyword">class</span> Graph {
    <span class="keyword">var</span> nodes: [<span class="type">Node</span>]
}

<span class="keyword">class</span> Node {
    <span class="keyword">var</span> val: <span class="type">Int</span>
    <span class="keyword">var</span> children: [<span class="type">Node</span>]
}
</code></pre><h2>Adjacency Matrix</h2><pre><code>matrix[i][j] == <span class="keyword">true</span> <span class="comment">// represents that there's an edge between i and j nodes</span>
</code></pre><h2>Search</h2><h3>Depth-first search (DFS)</h3><p>Explore each branch completely before moving to the next branch, meaning going deep first.</p><p>DFS is to visit every node in the graph.</p><p>To implement we can use recursion or a stack (which recursion uses underneath).</p><pre><code>     <span class="keyword">func</span> searchDFS(<span class="keyword">_</span> root: <span class="type">Node</span>?) {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="call">visit</span>(root)
        root.<span class="property">visited</span> = <span class="keyword">true

        for</span> node <span class="keyword">in</span> root.<span class="property">children</span> {
            <span class="keyword">if</span> !node.<span class="property">visited</span> {
                <span class="call">seachDFS</span>(node)
            }
        }
    }
</code></pre><h3>Breadth-first search (BFS)</h3><p>Explore each neighbor before moving to the children, meaning going wide first.</p><p>BFS is used to find the shortest (or any) path between 2 nodes.</p><p>To implement we need to use a queue (FIFO) data structure to ensure we search wide first.</p><pre><code>     <span class="keyword">func</span> searchBFS(<span class="keyword">_</span> root: <span class="type">Node</span>?) {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="keyword">let</span> queue = <span class="type">Queue</span>()
        root.<span class="property">marked</span> = <span class="keyword">true</span>
        queue.<span class="call">enqueue</span>(root) <span class="comment">// Add to the end</span>

        <span class="keyword">while</span> !queue.<span class="call">isEmpty</span> {
            <span class="keyword">let</span> node = queue.<span class="call">dequeue</span>() <span class="comment">// Take from the front</span>
            <span class="call">visit</span>(node)

            <span class="keyword">for</span> child <span class="keyword">in</span> node.<span class="property">children</span> {
                <span class="keyword">if</span> !child.<span class="property">marked</span> {
                    child.<span class="property">marked</span> = <span class="keyword">true</span>
                    queue.<span class="call">enqueue</span>(child)
                }
            }
        }
    }
</code></pre><p>3 facts to know about BFS: 1. Inorder traversal of BST is an array sorted in the ascending order. 2. Successor = "after node", i.e. the next node in "In order traversal (Left -&gt; Node -&gt; Previous)", or the smallest node after the current one. 3. Predecessor = "before node", i.e. the previous node "In order traversal (Left -&gt; Node -&gt; Previous)", or the largest node before the current one.</p><h3>Bidirectional Search</h3><p>Find the shorted path between 2 nodes by performing 2 simultaneous BFS from both nodes.</p><h2>Example problems to know how to solve:</h2><h3>Convert Sorted Array to Binary Search Tree</h3><p>Keep splitting the sorted array in half so the root would be the middle element.</p><pre><code><span class="comment">// O(n) time complexity, O(logn) space complexity</span>

<span class="keyword">class</span> Solution {
    <span class="keyword">func</span> sortedArrayToBST(<span class="keyword">_</span> nums: [<span class="type">Int</span>]) -&gt; <span class="type">TreeNode</span>? {
        <span class="keyword">return</span> <span class="call">createMinimalBST</span>(nums, start: <span class="number">0</span>, end: nums.<span class="property">count</span> - <span class="number">1</span>)
    }
    
    <span class="keyword">private func</span> createMinimalBST(<span class="keyword">_</span> nums: [<span class="type">Int</span>], start: <span class="type">Int</span>, end: <span class="type">Int</span>) -&gt; <span class="type">TreeNode</span>? {
        <span class="keyword">guard</span> start &lt;= end <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        
        <span class="keyword">let</span> mid = ((start + end) / <span class="number">2</span>)
    
        <span class="keyword">return</span> <span class="type">TreeNode</span>(
            nums[mid],
            <span class="call">createMinimalBST</span>(nums, start: start, end: mid - <span class="number">1</span>),
            <span class="call">createMinimalBST</span>(nums, start: mid + <span class="number">1</span>, end: end)
            )
    }
}
</code></pre><h3>Given a binary tree, return the level order traversal of its nodes</h3><p>It can be done using a simple recursion or a BFS. BFS allows printing easier level by level. In both cases, we need to save the "level" in the queue or pass it during the recursion.</p><h3>Check if Binary Tree is balanced</h3><p>A balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p><p>Calculating the height of each branch is not fully effective. We need to introduce an "early exit" the moment we find one branch not being balanced.</p><pre><code><span class="comment">// O(N) time and O(H) space because of the early exit
// We first go as deep left as possible and then increase the height when going up. The moment we find the difference between left and right more than 1, we throw an error.</span>
<span class="keyword">class</span> Solution {
    <span class="keyword">enum</span> TreeError: <span class="type">Error</span> {
        <span class="keyword">case</span> notBalanced
    }
    
    <span class="keyword">func</span> isBalanced(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
        
        <span class="keyword">do</span> {
            <span class="keyword">try</span> <span class="call">checkHeight</span>(root)
            <span class="keyword">return true</span>
        } <span class="keyword">catch</span> {
            <span class="keyword">return false</span>
        }
    }
    
    <span class="keyword">@discardableResult
    private func</span> checkHeight(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) <span class="keyword">throws</span> -&gt; <span class="type">Int</span> {      
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> -<span class="number">1</span> }

        <span class="keyword">let</span> left = <span class="keyword">try</span> <span class="call">checkHeight</span>(root.<span class="property">left</span>) <span class="comment">// Throwing error as an early exit</span>
        <span class="keyword">let</span> right =  <span class="keyword">try</span> <span class="call">checkHeight</span>(root.<span class="property">right</span>)
        
        <span class="keyword">if</span> (<span class="call">abs</span>(left - right) &lt; <span class="number">2</span>) {
            <span class="keyword">return</span> <span class="call">max</span>(left, right) + <span class="number">1</span>
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">TreeError</span>.<span class="property">notBalanced</span>
        }
    }
}
</code></pre><h3>Validate Binary Search Tree</h3><pre><code><span class="type">A</span> valid <span class="type">BST</span> <span class="keyword">is</span> defined <span class="keyword">as</span> follows:

* <span class="type">The</span> left subtree of a node contains only nodes with keys less than the node's key.
* <span class="type">The</span> right subtree of a node contains only nodes with keys greater than the node's key.
* <span class="type">Both</span> the left and right subtrees must also be binary search trees.
</code></pre><img src="https://www.staskus.io/images/notes/86b326043320bbd1a5d8d05117e1187489c2d15b285e3a773dd4476c23e2dc14.png" alt="Leetcode.com"/><p>We have 2 main routes to take.</p><p>First one is more intuitive, traverse the tree recursively, passing valid ranges and then validating them against the current value:</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
    
    <span class="keyword">return</span> <span class="call">isValidBST</span>(root.<span class="property">left</span>, -<span class="type">Int</span>.<span class="property">max</span>..&lt;root.<span class="property">val</span>) &amp;&amp; <span class="call">isValidBST</span>(root.<span class="property">right</span>, root.<span class="property">val</span>+<span class="number">1</span>..&lt;<span class="type">Int</span>.<span class="property">max</span>)
}

<span class="keyword">private func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?, <span class="keyword">_</span> allowedRange: <span class="type">Range</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
            
    <span class="keyword">if</span> !allowedRange.<span class="call">contains</span>(root.<span class="property">val</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">return</span> <span class="call">isValidBST</span>(root.<span class="property">left</span>, allowedRange.<span class="property">lowerBound</span>..&lt;root.<span class="property">val</span>) &amp;&amp; <span class="call">isValidBST</span>(root.<span class="property">right</span>, root.<span class="property">val</span>+<span class="number">1</span>..&lt;allowedRange.<span class="property">upperBound</span>)
}
</code></pre><p>Using DFS Inorder traversal is a more interesting solution. <code>Left -&gt; Node -&gt; Right</code>. Traversing like this we expect each node to have a larger value if it is a binary search tree.</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">private var</span> previous: <span class="type">Int</span>?

<span class="keyword">func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
<span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
    
    <span class="comment">// Left</span>
    <span class="keyword">if</span> !<span class="call">isValidBST</span>(root.<span class="property">left</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="comment">// Node</span>
    <span class="keyword">if let</span> previous = previous, previous &gt;= root.<span class="property">val</span> {
        <span class="keyword">return false</span>
    }
    previous = root.<span class="property">val</span>
    
    <span class="comment">// Right</span>
    <span class="keyword">if</span> !<span class="call">isValidBST</span>(root.<span class="property">right</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">return true</span>
}
</code></pre><h3>Find a successor (next node) in a binary search tree</h3><ul><li>Successor = "after node", i.e. the next node in the inorder traversal, or the smallest node after the current one.</li></ul><ul><li>Predecessor = "before node", i.e. the previous node in the inorder traversal, or the largest node before the current one.</li></ul><p>So to find a successor we either need to go: - One right node and as many left nodes as possible - If no right node exists, go up the tree until the node is the left child of the parent and return the parent</p><h3>Course Schedule</h3><p>Given the list of courses and dependency list of which courses must come before the others, return a list of course order.</p><p>This issue can be solved with DFS with some caveats. <em> We might not have one graph, there might be multiple graphs. So we might need to do multiple DFS until all nodes (courses) have been visited. </em> Once we reach the end of the graph then we add that node to the <strong>beginning</strong> of the course schedule. * If cycles are found, it's impossible to create a schedule. Cycles can be avoided by <strong>visited</strong> and <strong>visiting</strong> (or gray and black) node marking.</p><h3>Lowest Common Ancestor in a Binary Tree of 2 nodes</h3><p>The idea is to do a DFS recursive search throughout the tree. At each point we make 2 recursive calls (to the left and to the right). At the moment where <strong>both</strong> left and right branches result in a node being found, or any of the branches result in a node being found <strong>and</strong> the current node is a node we are looking for, we return a node.</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">private func</span> findNode(from node: <span class="type">TreeNode</span>?, to p: <span class="type">TreeNode</span>, orTo q: <span class="type">TreeNode</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> node = node <span class="keyword">else</span> {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">let</span> left = <span class="call">findNode</span>(from: node.<span class="property">left</span>, to: p, orTo: q) ? <span class="number">1</span> : <span class="number">0</span>
    <span class="keyword">let</span> right = <span class="call">findNode</span>(from: node.<span class="property">right</span>, to: p, orTo: q) ? <span class="number">1</span> : <span class="number">0</span>
    <span class="keyword">let</span> current = node.<span class="property">val</span> == p.<span class="property">val</span> || node.<span class="property">val</span> == q.<span class="property">val</span> ? <span class="number">1</span> : <span class="number">0</span>
    
    <span class="comment">// If any two are correct</span>
    <span class="keyword">if</span> left + right + current &gt;= <span class="number">2</span> {
        ancestor = node
    }
    
    <span class="keyword">return</span> left + right + current &gt; <span class="number">0</span>
}
</code></pre><h3>Number of Ways to Reorder Array to Get Same BST</h3><p>How many times we can reorder the same given array to get the same BST.</p><p>The intuition: <em> The first array element needs to be the same to have the same root </em> Smaller elements need to keep the same relative position to other small elements * Larger elements need to keep the same relative position to other large elements</p><p>The solution: <em> Divide and conquer. Keep splitting given array into 2 arrays with larger numbers than the first one and smaller numbers than the first one. Calculate the number of combination for each array </em> Combinatorics nCk (to find the number of ways selecting k things out of n things) * Multiply all the results recursively</p><p>Problems in Swift: <em> No built-in way to calculate nCk </em> No built-in way to calculate using large numbers BigInt</p><p>The gist of the algorithm</p><pre><code><span class="keyword">func</span> numOfWays(<span class="keyword">_</span> nums: [<span class="type">Int</span>]) -&gt; <span class="type">Int</span> {
    <span class="keyword">func</span> divideAndConquer(<span class="keyword">_</span> sublist: [<span class="type">Int</span>]) -&gt; <span class="type">Int</span> {
        <span class="keyword">if</span> sublist.<span class="property">count</span> &lt;= <span class="number">2</span> {
            <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// base case</span>
        }
        
        <span class="keyword">let</span> root = sublist[<span class="number">0</span>]
        
        <span class="keyword">let</span> left = sublist.<span class="call">filter</span> { $0 &lt; root }
        <span class="keyword">let</span> right = sublist.<span class="call">filter</span> { $0 &gt; root }
        
        <span class="keyword">return</span> <span class="call">nCk</span>(left.<span class="property">count</span> + right.<span class="property">count</span>, left.<span class="property">count</span>) * <span class="call">divideAndConquer</span>(left) * <span class="call">divideAndConquer</span>(right)
    }
    
    <span class="keyword">return</span> (<span class="call">divideAndConquer</span>(nums) - <span class="number">1</span>) <span class="comment">// With big trees the result will overflow</span>
}

<span class="keyword">func</span> nCk(<span class="keyword">_</span> n: <span class="type">Int</span>, <span class="keyword">_</span> k: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="comment">//C (n , k) = n! / [ (n-k)! k! ]</span>
    
    <span class="keyword">if</span> (k &gt; n) { <span class="keyword">return</span> <span class="number">0</span> }
    <span class="keyword">var</span> result = <span class="number">1</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="call">min</span>(k, n-k) {
        result = (result * (n - i))/(i + <span class="number">1</span>)
    }
    <span class="keyword">return</span> result
}
</code></pre><h3>Path Sum</h3><p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</p><p>This problem can be solved using a <strong>prefix sum</strong> technique.</p><img src="https://www.staskus.io/images/notes/4b53bbaf1ca1cab5b0a3959afb3ae6aaeefd5c8bf7772fb509f1d80a00ca5492.png" alt="LeetCode.com"/><p><strong>Prefix sum</strong> technique can be used to solve problems such as: * Find a number of arrays/matrices/tree paths that sum to a target</p><p>It's easier to understand the explanation using sum of arrays:</p><pre><code><span class="keyword">class</span> Solution {
    <span class="keyword">func</span> subarraySum(<span class="keyword">_</span> nums: [<span class="type">Int</span>], <span class="keyword">_</span> k: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
        <span class="keyword">var</span> count = <span class="number">0</span>
        <span class="keyword">var</span> sumCount: [<span class="type">Int</span>: <span class="type">Int</span>] = [:]
        <span class="keyword">var</span> sum = <span class="number">0</span>
        
        <span class="keyword">for</span> num <span class="keyword">in</span> nums {
            sum += num
            
            <span class="comment">// Special case if we find sum at the first position</span>
            <span class="keyword">if</span> sum == k {
                count += <span class="number">1</span>
            }
            
            <span class="comment">// This is the most important part
            // Let's say we have array [10, 5, 3] and target sum 8
            // When we come to 3, the sum is 18 and 18 - target sum = 10
            // In this case we encounter sum 10 for the second time, it means that in-between we had numbers that summed up to target sum (8). 
            // Counter-intuitive but super clever</span>
            count += sumCount[sum - k, default: <span class="number">0</span>] 
            
            sumCount[sum, default: <span class="number">0</span>] += <span class="number">1</span>
        }
        
        <span class="keyword">return</span> count
    }
}
</code></pre><h3>Course Schedule</h3><p>Given the number of courses and a list of prerequisites (the courses that depend on each other) determine if it's possible to create a schedule.</p><p>This task is asking to find cycles in a graph. If a cycle exists, it means the schedule cannot be formed. Perform a DFS, if we encounter a node that was already visited in the same path, the cycle exists.</p><h3>Invert Binary Tree</h3><p>To invert a binary tree we need to replace the left and right nodes at each step of the tree. We can use both recursive and iterative approaches. Time and space complexity in both cases is O(n)</p><pre><code><span class="comment">// If we use iterative approach, we can use queues
// O(n), O(n)</span>
<span class="keyword">func</span> invertTree(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">TreeNode</span>? {
    <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return nil</span> }
    
    <span class="keyword">let</span> right = <span class="call">invertTree</span>(root.<span class="property">right</span>)
    <span class="keyword">let</span> left = <span class="call">invertTree</span>(root.<span class="property">left</span>)
    
    root.<span class="property">left</span> = right
    root.<span class="property">right</span> = left

    <span class="keyword">return</span> root
}
</code></pre><h3>Lowest Common Ancestor of a Binary Search Tree</h3><p>Because this is a binary search tree the solution can be iterative. At each point we can either go left or right depending on the p, q and root values. When p and q values are between the root, the root is our lowest common ancestor.</p><pre><code><span class="comment">// O(n) O(1)</span>
<span class="keyword">func</span> lowestCommonAncestor(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?, <span class="keyword">_</span> p: <span class="type">TreeNode</span>?, <span class="keyword">_</span> q: <span class="type">TreeNode</span>?) -&gt; <span class="type">TreeNode</span>? {
    <span class="keyword">guard let</span> p = p, <span class="keyword">let</span> q = q <span class="keyword">else</span> { <span class="keyword">return nil</span> }
    
    <span class="keyword">var</span> root = root
    
    <span class="keyword">while</span> root != <span class="keyword">nil</span> {
        <span class="keyword">let</span> rootVal = root!.val
        <span class="keyword">let</span> pVal = p.<span class="property">val</span>
        <span class="keyword">let</span> qVal = q.<span class="property">val</span>
        
        <span class="keyword">if</span> pVal &gt; rootVal &amp;&amp; qVal &gt; rootVal {
            root = root!.right
        } <span class="keyword">else if</span> pVal &lt; rootVal &amp;&amp; qVal &lt; rootVal {
            root = root!.left
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> root
        }
    }
    
    <span class="keyword">return nil</span>
}
</code></pre><h3>Implement Trie (prefix tree)</h3><p>This data structure is used to implement autocomplete, spell checker, IP routing, T9 predictive text, solve word games, and many more.</p><p>Trie is a rooted tree that has: - Maximum of X links to children (X could be for example 26, the number of lowercase letters in an English alphabet) - A boolean field that specifies if the node is the end or not</p><p>Main functions of a trie: 1. Insert word (Time complexity O(m), Space complexity O(m)). Where m - length of the word 2. Search word (Time complexity O(m), Space complexity O(1)) 3. Search prefix (Same as word, but we don't check if the last letter is the end)</p><p>Implementation:</p><p>A TrieNode. A node that holds a list of its links. We could use HashTable or Array of fixed size.</p><pre><code><span class="keyword">class</span> TrieNode {
    <span class="keyword">var</span> links: [<span class="type">Character</span>: <span class="type">TrieNode</span>] = [:]
    <span class="keyword">var</span> isEnd = <span class="keyword">false
    
    func</span> getNode(<span class="keyword">_</span> char: <span class="type">Character</span>) -&gt; <span class="type">TrieNode</span>? {
        <span class="keyword">return</span> links[char]
    }
    
    <span class="keyword">@discardableResult
    func</span> createNode(<span class="keyword">_</span> char: <span class="type">Character</span>) -&gt; <span class="type">TrieNode</span> {
        <span class="keyword">let</span> node = <span class="type">TrieNode</span>()
        links[char] = node
        <span class="keyword">return</span> node
    }
}
</code></pre><p>A Trie.</p><p>To insert, we just start with the root and keep adding links. To search, we start with the root, and look if each node has a character as a link.</p><pre><code><span class="keyword">class</span> Trie {
    <span class="keyword">private var</span> root = <span class="type">TrieNode</span>()
    
    <span class="keyword">func</span> insert(<span class="keyword">_</span> word: <span class="type">String</span>) {
        <span class="keyword">var</span> currentNode = root
        
        <span class="keyword">for</span> letter <span class="keyword">in</span> word {
            <span class="keyword">if let</span> node = currentNode.<span class="call">getNode</span>(letter) {
                currentNode = node
            } <span class="keyword">else</span> {
                currentNode = currentNode.<span class="call">createNode</span>(letter)
            }
        }
        
        currentNode.<span class="property">isEnd</span> = <span class="keyword">true</span>
    }
    
    <span class="keyword">func</span> search(<span class="keyword">_</span> word: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">guard let</span> node = <span class="call">findEndNode</span>(word) <span class="keyword">else</span> {
            <span class="keyword">return false</span>
        }
        
        <span class="keyword">return</span> node.<span class="property">isEnd</span>
    }
    
    <span class="keyword">func</span> startsWith(<span class="keyword">_</span> prefix: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return</span> <span class="call">findEndNode</span>(prefix) != <span class="keyword">nil</span>
    }

    <span class="comment">// MARK: - Private</span>
    
    <span class="keyword">private func</span> findEndNode(<span class="keyword">_</span> word: <span class="type">String</span>) -&gt; <span class="type">TrieNode</span>? {
        <span class="keyword">var</span> currentNode = root
        <span class="keyword">for</span> letter <span class="keyword">in</span> word {
            <span class="keyword">if let</span> node = currentNode.<span class="call">getNode</span>(letter) {
                currentNode = node
            } <span class="keyword">else</span> {
                <span class="keyword">return nil</span>
            }
        }
        
        <span class="keyword">return</span> currentNode
    }
}
</code></pre><h3>Number of Islands in a Grid</h3><p>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.</p><pre><code><span class="type">Input</span>: grid = [
  [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],
  [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],
  [<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],
  [<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]
]
<span class="type">Output</span>: <span class="number">3</span>
</code></pre><p>We need to look at it as a graph problem and solve either with: 1. DFS 2. BFS 3. Union Find</p><p>DFS Solution:</p><pre><code><span class="keyword">func</span> numIslands(<span class="keyword">_</span> grid: [[<span class="type">Character</span>]]) -&gt; <span class="type">Int</span> {
    <span class="keyword">var</span> numberOfIslands = <span class="number">0</span>
    <span class="keyword">var</span> grid = grid
    
    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>..&lt;grid.<span class="property">count</span> {
        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="number">0</span>..&lt;grid[row].count {
            <span class="keyword">if</span> grid[row][col] == <span class="string">"1"</span> {
                <span class="call">markIslandAsVisited</span>(&amp;grid, row, col)
                numberOfIslands += <span class="number">1</span>
            }
        }
    }
    
    <span class="keyword">return</span> numberOfIslands
}

<span class="keyword">@discardableResult
private func</span> markIslandAsVisited(<span class="keyword">_</span> grid: <span class="keyword">inout</span> [[<span class="type">Character</span>]], <span class="keyword">_</span> row: <span class="type">Int</span>, <span class="keyword">_</span> col: <span class="type">Int</span>) {
    <span class="keyword">guard</span> row &gt;= <span class="number">0</span>, row &lt; grid.<span class="property">count</span>, col &gt;= <span class="number">0</span> , col &lt; grid[<span class="number">0</span>].count <span class="keyword">else</span> {
        <span class="keyword">return</span>
    }
    
    <span class="keyword">guard</span> grid[row][col] == <span class="string">"1"</span> <span class="keyword">else</span> {
        <span class="keyword">return</span>
    } 
    
    grid[row][col] = <span class="string">"0"</span>
    
    [(row - <span class="number">1</span>, col), (row, col - <span class="number">1</span>), (row + <span class="number">1</span>, col), (row, col + <span class="number">1</span>)].<span class="call">forEach</span> { newRow, newCol <span class="keyword">in</span> 
        markIslandAsVisited(&amp;grid, newRow, newCol)
    }
    
    <span class="keyword">return</span>
}
</code></pre><h3>Combination Sum</h3><p>Given array of candidates and a target sum, return a list of unique combinations of candidates that sum to target.</p><p>We use backtracking algorithm.</p><p>Time complexity - <strong>O(N^((t/m)+1))</strong>, where t- target value and m - minimal value.</p><p>This is from theory that the maximum number of nodes in N-ary tree of T/M height is O(N^((t/m)+1))</p><p>If 8 - target, and 2 - minimum then O(N^4+1).</p><p>Space - O(t/m)</p><pre><code>     <span class="keyword">func</span> combinationSum(<span class="keyword">_</span> candidates: [<span class="type">Int</span>], <span class="keyword">_</span> target: <span class="type">Int</span>) -&gt; [[<span class="type">Int</span>]] {
        <span class="comment">// unique = skip if there are 2 same numbers, leetcode already ensures it</span>
        
        <span class="keyword">var</span> combinations: [[<span class="type">Int</span>]] = []
        
        <span class="call">combinationSum</span>(candidates, target, [], &amp;combinations)
        
        <span class="keyword">return</span> combinations
    }
    
    <span class="keyword">private func</span> combinationSum(<span class="keyword">_</span> candidates: [<span class="type">Int</span>], 
                                <span class="keyword">_</span> remaining: <span class="type">Int</span>, 
                                <span class="keyword">_</span> currentCombination: [<span class="type">Int</span>], 
                                <span class="keyword">_</span> combinations: <span class="keyword">inout</span> [[<span class="type">Int</span>]]) {
        <span class="call">print</span>(remaining)
        <span class="keyword">guard</span> remaining &gt;= <span class="number">0</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
        
        <span class="keyword">if</span> remaining == <span class="number">0</span> {
            combinations.<span class="call">append</span>(currentCombination)
            <span class="keyword">return</span>
        }
        
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;candidates.<span class="property">count</span> {
            <span class="call">combinationSum</span>(<span class="type">Array</span>(candidates[i..&lt;candidates.<span class="property">count</span>]), 
                           remaining - candidates[i], 
                           currentCombination + [candidates[i]], 
                           &amp;combinations)
        }
    }
</code></pre><h1>Additional Information</h1><h2>Spanning Tree</h2><p>A spanning tree is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.</p><p>A minimum spanning tree is a spanning tree with the minimum possible total edge weight in a “weighted undirected graph”.</p><p>Tree - doesn't have cycles</p><p>Cut Property - choosing crossing edge between 2 cuts with the lowest weight</p><h3>Minimum Spanning Tree</h3><p><strong>“Kruskal’s algorithm”</strong> is an algorithm to construct a “minimum spanning tree” of a “weighted undirected graph”. 1) Take all possible edges 2) sort by weight 3) pick one by one if the cycle is not created (!uf.connected).</p><p><strong>Prims Algorithm:</strong> - 1) Pick starting node, see which unvisited node we can visit most cheaply. 2) pick visited nodes, see which unvisited node we can visit most cheaply 3) repeat until all nodes are visited. We need to use min-heap to pick the lowest weighted edge - However, in some cases using min-heap is not effective enough so we need to look ways around it (Min Cost to Connect All Points) as even effective sorting adds log(n) of time complexity.</p><p>Heap is not a Priority Queue, but a way to implement a Priority Queue.</p><p>Heap is a special type of binary tree. Insertion, deletion O(log n). Max, minimum - O(1): - Min Heap. - Max Heap</p><p>BFS - Always find the shortest path first. Finding a path in the grid is a usual task.</p><h2>Single source shortest path problem</h2><p>Edge Relaxation operation is a key in solving the "single source shortest path problem" - If A-D distance is 3, but A-C-D is 2 by performing edge relaxation we note that the distance between A-D is actually 2</p><p><strong>Dijkstra's algorithm</strong>. Can only be used to solve the problem with non-negative weights</p><ul><li>In time complexity we have 2 properties: V - number of vertices and E - number of edges. If we use the Fibonacci heap to extract minimum element total complexity O(E + VlogV). If we use Binary heap time complexity would be O(V+ ElogV).</li><li>Space complexity O(V)</li></ul><p><strong>Steps:</strong> 1. Start at the ending vertex by marking it with a distance of 0 (call it <em>currentVertex</em>) 2. Identify all of the vertices connected to <em>currentVertex</em> with weights. If we already identified vertex, only change weight if a new one is smaller 3. Label <em>currentVertex</em> as visited 4. Find smallest identifier vertice and repeat 2 5. Once labeled a beginning vertex - stop</p><p><strong>Bellman-Ford algorithm</strong>. Can solve with any weights.</p><p>“Bellman-Ford algorithm” is only applicable to “graphs” with no “negative weight cycles”.</p><p>We find a negative cycle if after performing Nth edge relaxation (we normally just need to do N-1) we still find a shorter path.</p><ul><li>Time complexity O(V * E)</li><li>Space complexity O(V)</li></ul><p>Positive Weight Cycle: If during each cycle the path weight increases. The shortest path is after the first cycle</p><p>Negative Weight Cycle: If during each cycle the path weight decreases. There's no shortest path then</p><p><strong>Bellman-Ford:</strong> 1. Have previous and current arrays 2. Each iteration simply set current cost to be minimum of already existing or previous + cost current[destination] = min(current[destination], previous[origin] + cost) 3. At the end of iteration set previous = current</p><p>Essentially, <strong>Bellman-Ford</strong> algorithm is a dynamic programming solution optimized for space and time. If 2 loops in the row we get the same result, we can return it as the shortest path.</p><p>If a question has a constraint of going through k edges, then we just use a dynamic programming approach</p><h2>Dynamic Programming</h2><p><strong>Dynamic Programming (DP)</strong> is an algorithmic technique for solving an optimization problem by breaking it down into simpler subproblems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its subproblems.</p><p>Solving shortest path problem using Dynamic Programming: - Asking: Can I find the shortest path using at most 1 edge? Can I find the shortest path using at most 2 edges, etc until N-1 edges</p><p><strong>Dynamic Programming</strong> 1. Look if the same problem can be split into some smaller problems in a tree structure. Then it means we can solve it using recursion. We need to know the base case to return early from recursion. 2. Make it work brute force way 3. Optimize it using “memoization” (creating dict or set for efficiency)</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Arrays%20and%20Strings</guid><title>Array and Strings</title><description></description><link>https://www.staskus.io/notes/Arrays%20and%20Strings</link><pubDate>Fri, 22 Apr 2022 17:10:45 +0300</pubDate><content:encoded><![CDATA[<h2>Hash Tables</h2><p>We can implement hash tables using the combination of arrays and linked lists.</p><ol><li>We compute hash code and % it from array length</li><li>At each array position there's a linked list to deal with collisions</li><li>When retrieving values find a linked list by a key (hash &amp; index) and then search through a linked list for a key</li></ol><p>Although the worst-case scenario due to collisions is 0(n), a good implementation that keeps collisions at a minimum is considered to be O(1)</p><h2>Resizable Arrays</h2><p>Some programming languages have only fixed-size arrays and use different types of data structures like ArrayList which expands in size dynamically. It does this by doubling its size after reaching a limit.</p><h2>Example tasks to know how to solve:</h2><h3>Two Sum</h3><p>A very popular problem with a lot of variations.</p><h4>If numbers array is already sorted</h4><p>If the numbers array is already sorted, we can use 2 pointer approach, where one starts at the end and the other at the start. If they both sum to a target, we have found our solution. If our sum is smaller, we need to increase leftIndex. If our sum is larget, we need to decrease our rightIndex.</p><pre><code><span class="comment">// O(n) O(1)</span>
<span class="keyword">func</span> twoSum(<span class="keyword">_</span> numbers: [<span class="type">Int</span>], <span class="keyword">_</span> target: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] {
    <span class="keyword">var</span> lowIndex = <span class="number">0</span>
    <span class="keyword">var</span> highIndex = numbers.<span class="property">count</span> - <span class="number">1</span>
    
    <span class="keyword">while</span> lowIndex &lt; <span class="call">highIndex</span> {
        <span class="keyword">let</span> sum = numbers[lowIndex] + numbers[highIndex]
        <span class="keyword">if</span> sum == target {
            <span class="keyword">return</span> [lowIndex, highIndex]
        } <span class="keyword">else if</span> sum &gt; target {
            highIndex -= <span class="number">1</span>
        } <span class="keyword">else</span> {
            lowIndex += <span class="number">1</span>
        }
    }
    
    <span class="keyword">return</span> []
}
</code></pre><h4>If numbers array is not sorted</h4><ol><li>We calculate the remaining value</li><li>If it's already in the map, we return indices</li><li>Else, save the current number in the map</li></ol><pre><code><span class="comment">// O(n) O(n)</span>
<span class="keyword">func</span> twoSum(<span class="keyword">_</span> numbers: [<span class="type">Int</span>], <span class="keyword">_</span> target: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] {
    <span class="keyword">var</span> map: [<span class="type">Int</span>: <span class="type">Int</span>] = [:]
    
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;numbers.<span class="property">count</span> {
        <span class="keyword">let</span> remaining = target - numbers[i]
        
        <span class="keyword">if let</span> remainingIndex = map[remaining] {
            <span class="keyword">return</span> [remainingIndex, i]
        }
        
        map[numbers[i]] = i
    }
    
    <span class="keyword">return</span> []
}
</code></pre><h3>Three Sum</h3><p>Such task is a continuation of Two Sum. We should find ways to call Two Sum logic for elements in a Three Sum problem. Naturally, the time complexity grows to O(n^2).<br>### Determine if String has unique characters</p><p>We can use Sets or Hashmaps. If we can only use Arrays clarify the limitations of an alphabet. If it's the English alphabet we can create an array of size 26 (size 128 if including all ASCII characters) and the element's position would be <em>character.asciiValue - 'a'.asciiValue</em>.</p><h3>Given two strings decide if one is a permutation of the other</h3><p>We can sort and check if they are equal with time complexity O(nlogn) and space complexity O(1).</p><p>We can use hashtables with time complexity O(n) and space complexity O(n).</p><p>If the alphabet has limitations (as explained before) we can use fixed-size arrays with a space complexity of O(1).</p><h3>Check if a string is a permutation of a palindrome</h3><p>In such a task is important to nail down what exactly is a palindrome. It has no more than one odd number-letter count. We can again use fixed-size arrays to make letter counts.</p><h3>Check if 2 strings are one edit (insert, remove, replace) away</h3><p>It's important to exit early from clear invalid cases. Then go through a long string and return false if found more than one difference.</p><h3>Compressing the string into its letter counts without using extra space</h3><p>What is helpful is using a concept of a <em>read pointer</em> and a <em>write pointer</em>. While we make calculations going together with <em>read pointer</em>, <em>write pointer</em> can execute changes on the string without making some positioning calculations.</p><h3>Rotate Matrix without using extra space</h3><p><strong>A very popular problem</strong></p><p>Having drawn examples helps with finding the patterns of how matrices work.</p><p>2 main options for solving: <em> Transpose (flip diagonally) and Reflect (left to right / top to bottom) </em> Rotate squares inside a matrix (Which I choose as it uses twice as less iterations)</p><p>Each matrix has n/2 (where n is a number of elements in a row) squares. We need to iterate through all the squares and swap elements at the corners of those squares.</p><img src="https://www.staskus.io/images/notes/f53df9570974ef456f0347b2fe8bb8e09876c4c0c4910f51a3fb2bfb42ffc5fb.png" alt="<a href="https://www.enjoyalgorithms.com/blog/rotate-a-matrix-by-90-degrees-in-an-anticlockwise-direction">picture 1</a>"/><p>After exchanging the upper layer, we move into inner layer circles (in larger matrices)</p><p>Example of turning the matrix 90 degrees</p><pre><code><span class="keyword">let</span> n = matrix.<span class="property">count</span>
        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="number">0</span>..&lt;n/<span class="number">2</span> {
    <span class="comment">// Going through elements in the layer. The deeper the layer, the less the elements</span>
    <span class="keyword">for</span> pos <span class="keyword">in</span> layer..&lt;n-<span class="number">1</span>-layer {
        <span class="keyword">let</span> temp = matrix[layer][pos]
        matrix[layer][pos] = matrix[n-<span class="number">1</span>-pos][layer]
        matrix[n-<span class="number">1</span>-pos][layer] = matrix[n-<span class="number">1</span>-layer][n-<span class="number">1</span>-pos]
        matrix[n-<span class="number">1</span>-layer][n-<span class="number">1</span>-pos] = matrix[pos][n-<span class="number">1</span>-layer]
        matrix[pos][n-<span class="number">1</span>-layer] = temp
    }
}
</code></pre><h3>Zero Matrix</h3><p>If the element is 0, its entire row and column should be zero.</p><p>In such a task optimal solution is using constant space, meaning changing matrix in place. The challenge is coming up with the flag to notify which rows and columns need to be turned to zeros. Usually, we can set flags at the beginning of rows and columns and iterate through the matrix 2 times.</p><h3>Best Time to Buy and Sell Stock</h3><p>Given the array of values, find the smallest value to buy and the largest to sell.</p><p>We can use 2 pointers approach. If the price of the left pointer is larger than a price of a right pointer, we move with the left pointer forward. Else, we calculate a possible sell price.</p><pre><code><span class="keyword">class</span> Solution {
    <span class="comment">// TimeComplexity O(n)
    // SpaceComplexity 0(1)</span>
    <span class="keyword">func</span> maxProfit(<span class="keyword">_</span> prices: [<span class="type">Int</span>]) -&gt; <span class="type">Int</span> {
        <span class="comment">// 2 pointer approach
        // If right finds smaller, left moves to the right</span>
        
        <span class="keyword">var</span> leftPtr = <span class="number">0</span>
        <span class="keyword">var</span> rightPtr = <span class="number">0</span>
        <span class="keyword">var</span> maxValue = <span class="number">0</span>
        
        <span class="keyword">while</span> rightPtr &lt; prices.<span class="call">count</span> {
            <span class="keyword">if</span> prices[leftPtr] &gt;= prices[rightPtr] {
                leftPtr = rightPtr
            } <span class="keyword">else</span> {
                maxValue = <span class="call">max</span>(maxValue, prices[rightPtr] - prices[leftPtr])
            }
        
            rightPtr += <span class="number">1</span>  
        }
        
        <span class="keyword">return</span> maxValue
    }
}
</code></pre><h3>Valid Palindrome</h3><p>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p><p>"A man, a plan, a canal: Panama" is a palindrome in this case.</p><p>There are 2 main approaches: <em> Filter the original, create a reverse string, compare reversed with the original (O(n), O(n)) </em> 2 pointer approach. One from left to right, the other from right to left, skip non-alphanumeric characters. (O(n), O(1))</p><pre><code><span class="keyword">func</span> isPalindrome(<span class="keyword">_</span> s: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">let</span> letters = <span class="type">Array</span>(s)
    <span class="keyword">var</span> leftIndex = <span class="number">0</span>
    <span class="keyword">var</span> rightIndex = letters.<span class="property">count</span> - <span class="number">1</span>
    
    <span class="keyword">while</span> leftIndex &lt; <span class="call">rightIndex</span> {
        <span class="keyword">let</span> leftLetter = <span class="type">Character</span>(letters[leftIndex].<span class="call">lowercased</span>())
        <span class="keyword">let</span> rightLetter = <span class="type">Character</span>(letters[rightIndex].<span class="call">lowercased</span>())
        
        <span class="keyword">if</span> !leftLetter.<span class="property">isNumber</span> &amp;&amp; !leftLetter.<span class="property">isLetter</span> {
            leftIndex += <span class="number">1</span>
            <span class="keyword">continue</span>
        }
        
        <span class="keyword">if</span> !rightLetter.<span class="property">isNumber</span> &amp;&amp; !rightLetter.<span class="property">isLetter</span> {
            rightIndex -= <span class="number">1</span>
            <span class="keyword">continue</span>
        }
        
        <span class="keyword">if</span> leftLetter != rightLetter {
            <span class="keyword">return false</span>
        }
        
        leftIndex += <span class="number">1</span>
        rightIndex -= <span class="number">1</span>
    }
    
    <span class="keyword">return true</span>
}
</code></pre><h3>Maximum Subarray</h3><p>Find a subarray that sums to the maximum value and return this value.</p><pre><code><span class="comment">// "Dynamic Programming, Kadane's Algorithm"
// I came up on my own, no need to memorize.
// The idea is that we can dismiss "maxCandidate" if adding it to the sum is still less than the sum because it contributes negatively to the total.

// O(n), O(1)</span>
<span class="keyword">func</span> maxSubArray(<span class="keyword">_</span> nums: [<span class="type">Int</span>]) -&gt; <span class="type">Int</span> {        
    <span class="keyword">var</span> maxNum = -<span class="type">Int</span>.<span class="property">max</span>
    <span class="keyword">var</span> maxCandidate = <span class="number">0</span>
    
    <span class="keyword">for</span> num <span class="keyword">in</span> nums {
        maxCandidate = <span class="call">max</span>(num, maxCandidate + num)
        maxNum = <span class="call">max</span>(maxCandidate, maxNum)  
    }
    
    <span class="keyword">return</span> maxNum
}
</code></pre><h3>Find k closest(smallest, largest) points in array</h3><p>Options: 1. Sorting - O(n logn), O(1) 2. Max heap - O(n + klogn), O(n) 3. Binary Search - O(n), O(n) 4. Quick Select - O(n), O(1)</p><p>We strive for O(n) time complexity, and O(1) space complexity.</p><p>Anytime we are tasked with finding the k (or kth) [smallest/largest/etc.] element(s), we should always consider whether the <strong>QuickSelect</strong> algorithm can be applied.</p><p>Unlike the QuickSort algorithm, the QuickSelect algorithm roughly halves the remaining elements needed to process at each iteration, so the total number of processes will average at 2N hich results in an average time complexity of O(N). The worst case is O(n^2) though.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Sorting</guid><title>Sorting</title><description></description><link>https://www.staskus.io/notes/Sorting</link><pubDate>Thu, 21 Apr 2022 20:47:50 +0300</pubDate><content:encoded><![CDATA[<h1>Sorting Algorithms</h1><h2>Bubble Sort</h2><p>Time: O(n$^2$), Memory: O(1)</p><ol><li>Go through the array</li><li>Swap 2 elements</li><li>Continue until the array is sorted</li></ol><h2>Selection Sort</h2><p>Time: O(n$^2$), Memory O(1)</p><ol><li>Look through the array</li><li>Find the smallest element and move it to the front</li><li>Repeat</li></ol><h2>Insertion Sort</h2><p>Insertion sort is fast if the array is already sorted or the dataset is really small.</p><p>Time: O(n$^2$)</p><pre><code><span class="comment">// http://raywenderlich.github.io/swift-algorithm-club/Insertion%20Sort/</span>

<span class="keyword">func</span> insertionSort(<span class="keyword">_</span> array: [<span class="type">Int</span>]) -&gt; [<span class="type">Int</span>] {
  <span class="keyword">var</span> a = array
  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>..&lt;a.<span class="property">count</span> {
    <span class="keyword">var</span> y = x
    <span class="keyword">let</span> temp = a[y]
    <span class="keyword">while</span> y &gt; <span class="number">0</span> &amp;&amp; temp &lt; a[y - <span class="number">1</span>] {
      a[y] = a[y - <span class="number">1</span>]                <span class="comment">// 1</span>
      y -= <span class="number">1</span>
    }
    a[y] = temp                      <span class="comment">// 2</span>
  }
  <span class="keyword">return</span> a
}
</code></pre><h2>Merge Sort</h2><p>Time: O(n log(n)), Memory: O(n)</p><ol><li>Divide the array in half until the array is the size of 1</li><li>Merge them back together in a sorted way</li></ol><p>Merge sort is more efficient and works faster than quicksort in the case of larger array sizes or datasets.</p><img src="https://www.staskus.io/images/notes/7e695531912858f96e685ace9f097d2692be7ebcd2c4e9808388f7a07f171669.png" alt="De-Coding Technical Interview Process - Emma Bostian"/><pre><code><span class="keyword">func</span> mergeSort(<span class="keyword">_</span> array: [<span class="type">Int</span>]) -&gt; [<span class="type">Int</span>] {
    <span class="keyword">guard</span> array.<span class="property">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> { <span class="keyword">return</span> array }
    
    <span class="keyword">let</span> middleIndex = array.<span class="property">count</span> / <span class="number">2</span>

    <span class="keyword">let</span> leftSide = <span class="call">mergeSort</span>(<span class="type">Array</span>(array[<span class="number">0</span>..&lt;middleIndex]))
    <span class="keyword">let</span> rightSide = <span class="call">mergeSort</span>(<span class="type">Array</span>(array[middleIndex...]))

    <span class="keyword">return</span> <span class="call">merge</span>(leftSide, rightSide)
}

<span class="keyword">func</span> merge(<span class="keyword">_</span> leftArray: [<span class="type">Int</span>], <span class="keyword">_</span> rightArray: [<span class="type">Int</span>]) -&gt; [<span class="type">Int</span>] {
    <span class="keyword">var</span> leftIndex = <span class="number">0</span>
    <span class="keyword">var</span> rightIndex = <span class="number">0</span>

    <span class="keyword">var</span> orderedArray: [<span class="type">Int</span>] = []

    <span class="comment">// Append one by one in a sorted way
    // Because we start merging from one element arrays, we are guaranteed that elements will be sorted</span>

    <span class="keyword">while</span> leftIndex &lt; leftArray.<span class="property">count</span> &amp;&amp; rightIndex &lt; rightArray.<span class="property">count</span> {
        <span class="keyword">if</span> leftArray[leftIndex] &lt; rightArray[rightIndex] {
            orderedArray.<span class="call">append</span>(leftArray[leftIndex])
            leftIndex += <span class="number">1</span>
        } <span class="keyword">else if</span> leftArray[leftIndex] &gt; rightArray[rightIndex] {
            orderedArray.<span class="call">append</span>(rightArray[rightIndex])
            rightIndex += <span class="number">1</span>
        } <span class="keyword">else</span> {
            orderedArray.<span class="call">append</span>(leftArray[leftIndex])
            leftIndex += <span class="number">1</span>
            orderedArray.<span class="call">append</span>(rightArray[rightIndex])
            rightIndex += <span class="number">1</span>
        }
    }

    <span class="comment">// If the left is larger, add the remaining left array elements</span>

    <span class="keyword">while</span> leftIndex &lt; leftArray.<span class="call">count</span> {
        orderedArray.<span class="call">append</span>(leftArray[leftIndex])
        leftIndex += <span class="number">1</span>
    }

    <span class="comment">// If the right is larger, add the remaining right array elements</span>

    <span class="keyword">while</span> rightIndex &lt; rightArray.<span class="call">count</span> {
        orderedArray.<span class="call">append</span>(rightArray[rightIndex])
        rightIndex += <span class="number">1</span>
    }

    <span class="keyword">return</span> orderedArray
}
</code></pre><h2>Quick Sort</h2><p>Time: average - O(n log(n)), worst - O(n$^2$). Memory: O(log(n))</p><ol><li>Pick a random element (pivot). There're theories on which element is better to pick. Else, just pick a mid element.</li><li>Split an array into three parts: less than the pivot, equal to the pivot, larger than the pivot</li><li>Merge them back together</li></ol><p>Quicksort is more efficient and works faster than merge sort in case of smaller array sizes or datasets.</p><img src="https://www.staskus.io/images/notes/fa7d4a6f8a071d1f4a6f1e3e9572c148813a06ed4f917a948a40f932f719b073.png" alt="http://raywenderlich.github.io/swift-algorithm-club/Quicksort/"/><img src="https://www.staskus.io/images/notes/80f6b547b2282e1625e834be09bfa310ff0bb1f97819d40ace9eb9b28633f2e3.png" alt="De-Coding Technical Interview Process - Emma Bostian"/><p>In-place:</p><pre><code><span class="keyword">func</span> quickSort(<span class="keyword">_</span> array: <span class="keyword">inout</span> [<span class="type">Int</span>]) {
    <span class="call">quickSort</span>(&amp;array, <span class="number">0</span>, array.<span class="property">count</span> - <span class="number">1</span>)
}

<span class="keyword">func</span> quickSort(<span class="keyword">_</span> array: <span class="keyword">inout</span> [<span class="type">Int</span>], <span class="keyword">_</span> left: <span class="type">Int</span>, <span class="keyword">_</span> right: <span class="type">Int</span>) {
    <span class="keyword">let</span> index = <span class="call">partition</span>(&amp;array, left, right)

    <span class="keyword">if</span> left &lt; index - <span class="number">1</span> {
        <span class="call">quickSort</span>(&amp;array, left, index - <span class="number">1</span>)
    }

    <span class="keyword">if</span> right &gt; index {
        <span class="call">quickSort</span>(&amp;array, index, right)
    }
}

<span class="keyword">func</span> partition(<span class="keyword">_</span> array: <span class="keyword">inout</span> [<span class="type">Int</span>], <span class="keyword">_</span> left: <span class="type">Int</span>, <span class="keyword">_</span> right: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">let</span> pivot = array[(left + right) / <span class="number">2</span>]

    <span class="keyword">var</span> left = left
    <span class="keyword">var</span> right = right

    <span class="keyword">while</span> left &lt;= <span class="call">right</span> {
        <span class="keyword">while</span> array[left] &lt; <span class="call">pivot</span> {
            left += <span class="number">1</span>
        }

        <span class="keyword">while</span> array[right] &gt; <span class="call">pivot</span> {
            right -= <span class="number">1</span>
        }

        <span class="keyword">if</span> left &lt;= right {
            array.<span class="call">swapAt</span>(left, right)
            left += <span class="number">1</span>
            right -= <span class="number">1</span>
        }
    }

    <span class="keyword">return</span> left
}
</code></pre><p>Creating additional arrays (Easy implementation)</p><pre><code><span class="comment">// Naive implementation. Creating a new array for every partition.
// Might be acceptable, better know this one than not know at all</span>

<span class="keyword">func</span> quickSort2(<span class="keyword">_</span> array: [<span class="type">Int</span>]) -&gt; [<span class="type">Int</span>] {
    <span class="keyword">if</span> array.<span class="property">count</span> &lt; <span class="number">2</span> { <span class="keyword">return</span> array }

    <span class="keyword">let</span> pivotIndex = array.<span class="property">count</span> + ((<span class="number">0</span> - array.<span class="property">count</span>) / <span class="number">2</span>)
    <span class="keyword">let</span> pivot = array[pivotIndex]
    <span class="keyword">var</span> less: [<span class="type">Int</span>] = []
    <span class="keyword">var</span> greater: [<span class="type">Int</span>] = []

    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;array.<span class="property">count</span> {
        <span class="keyword">if</span> i != pivotIndex {
            array[i] &gt; pivot ? greater.<span class="call">append</span>(array[i]) : less.<span class="call">append</span>(array[i])
        }
    }

    <span class="keyword">return</span> <span class="call">quickSort2</span>(less) + [pivot] + <span class="call">quickSort2</span>(greater)
}
</code></pre><h2>Heap Sort</h2><p>Time: O(n log(n))</p><h2>Counting Sort</h2><p>Time Complexity: O(n+k) where n is the number of elements in input array and k is the range of input. Space: O(n+k)</p><p>It can be used to sort strings where the range of characters is clearly limited.</p><ol><li>Create an array representing counts of each character (ASCII / lowercase English)</li><li>Store a count of each character</li><li>Build a new string</li></ol><pre><code><span class="keyword">func</span> countingSort(<span class="keyword">_</span> array: [<span class="type">Int</span>])-&gt; [<span class="type">Int</span>] {
    <span class="keyword">guard</span> array.<span class="property">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> {<span class="keyword">return</span> []}

    <span class="comment">// Step 1
    // Create an array to store the count of each element</span>
    <span class="keyword">let</span> maxElement = array.<span class="call">max</span>() ?? <span class="number">0</span>

    <span class="keyword">var</span> countArray = [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: <span class="type">Int</span>(maxElement + <span class="number">1</span>))
    <span class="keyword">for</span> element <span class="keyword">in</span> array {
        countArray[element] += <span class="number">1</span>
    }

    <span class="comment">// Step 2
    // Set each value to be the sum of the previous two values</span>
    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span> ..&lt; countArray.<span class="property">count</span> {
        <span class="keyword">let</span> sum = countArray[index] + countArray[index - <span class="number">1</span>]
        countArray[index] = sum
    }

    <span class="comment">// Step 3
    // Place the element in the final array as per the number of elements before it
    // Loop through the array in reverse to keep the stability of the new sorted array
    // (For Example: 7 is at index 3 and 6, thus in sortedArray the position of 7 at index 3 should be before 7 at index 6</span>
    <span class="keyword">var</span> sortedArray = [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: array.<span class="property">count</span>)
    <span class="keyword">for</span> index <span class="keyword">in</span> stride(from: array.<span class="property">count</span> - <span class="number">1</span>, through: <span class="number">0</span>, by: -<span class="number">1</span>) {
        <span class="keyword">let</span> element = array[index]
        countArray[element] -= <span class="number">1</span>
        sortedArray[countArray[element]] = element
    }
    <span class="keyword">return</span> sortedArray
}
</code></pre><h2>Radix Sort</h2><p>Time: O(kn) where k - number of passes of the sorting algorithm</p><p>This sort is usually used for integers as we iterate through each digit of the number grouping numbers by digit.</p><h3>Example Tasks</h3><h3>Merge Sorted Array</h3><p>Given 2 sorted arrays, merge them in place. Prerequisite: the second array is the size of the final array with preappended zeros at the end.</p><pre><code><span class="comment">// O(n + m), O(1)</span>
<span class="keyword">func</span> merge(<span class="keyword">_</span> nums1: <span class="keyword">inout</span> [<span class="type">Int</span>], <span class="keyword">_</span> m: <span class="type">Int</span>, <span class="keyword">_</span> nums2: [<span class="type">Int</span>], <span class="keyword">_</span> n: <span class="type">Int</span>) {
    <span class="keyword">var</span> p1 = m - <span class="number">1</span>
    <span class="keyword">var</span> p2 = n - <span class="number">1</span>
    
    <span class="keyword">for</span> p <span class="keyword">in</span> stride(from: nums1.<span class="property">count</span> - <span class="number">1</span>, through: <span class="number">0</span>, by: -<span class="number">1</span>) {
        <span class="keyword">if</span> p2 &lt; <span class="number">0</span> {
            <span class="keyword">break</span>
        }
        
        <span class="keyword">if</span> p1 &gt;= <span class="number">0</span>, nums1[p1] &gt; nums2[p2] {          
            nums1[p] = nums1[p1]
            p1 -= <span class="number">1</span>
        } <span class="keyword">else</span> {
            nums1[p] = nums2[p2]
            p2 -= <span class="number">1</span>
        }
    }
}
</code></pre><h2>Group Anagrams</h2><p>The easiest way to group array of anagrams into array of anagram arrays is to use a <em>hashmap</em> and key as sorted string. However, the time complexity is not ideal.</p><pre><code><span class="comment">// Time Complexity:  O ( N K log ⁡ K ) O(NKlogK), where  N N is the length of strs, and  K K is the maximum length of a string in strs. The outer loop has complexity  O ( N ) O(N) as we iterate through each string. Then, we sort each string in  O ( K log ⁡ K ) O(KlogK) time
// O(NK)</span>
<span class="keyword">func</span> groupAnagrams(<span class="keyword">_</span> strs: [<span class="type">String</span>]) -&gt; [[<span class="type">String</span>]] {
    <span class="keyword">var</span> groupedAnagrams: [<span class="type">String</span>: [<span class="type">String</span>]] = [:]
    
    <span class="keyword">for</span> string <span class="keyword">in</span> strs {
        groupedAnagrams[<span class="type">String</span>(string.<span class="call">sorted</span>()), default: []].<span class="call">append</span>(string)
    }
    
    <span class="keyword">return</span> <span class="type">Array</span>(groupedAnagrams.<span class="property">values</span>)
}   
</code></pre><p>If the problem only uses only a specific set of characters (ASCII), we can create a key out of character counts. The inner loop is faster than sorting a string (K vs KlogK)</p><pre><code>     <span class="keyword">func</span> groupAnagrams(<span class="keyword">_</span> strs: [<span class="type">String</span>]) -&gt; [[<span class="type">String</span>]] {
        <span class="keyword">var</span> groupedAnagrams: [<span class="type">String</span>: [<span class="type">String</span>]] = [:]
        
        <span class="keyword">for</span> string <span class="keyword">in</span> strs {
            <span class="keyword">let</span> characterCount = <span class="call">stringToCharacterCount</span>(string)
            <span class="keyword">let</span> key = <span class="call">characterCountToKey</span>(characterCount)
            groupedAnagrams[key, default: []].<span class="call">append</span>(string)
        }
        
        <span class="keyword">return</span> <span class="type">Array</span>(groupedAnagrams.<span class="property">values</span>)
    }
    
    <span class="keyword">private func</span> stringToCharacterCount(<span class="keyword">_</span> string: <span class="type">String</span>) -&gt; [<span class="type">Int</span>] {
        <span class="keyword">var</span> count: [<span class="type">Int</span>] = <span class="type">Array</span>(repeating: <span class="number">0</span>, count: <span class="number">26</span>)
        
        <span class="keyword">var</span> characterToNumber: (<span class="type">Character</span>) -&gt; <span class="type">Int</span> = {
            <span class="type">Int</span>($0.<span class="property">asciiValue</span>!) - <span class="type">Int</span>(<span class="type">Character</span>(<span class="string">"a"</span>).<span class="property">asciiValue</span>!)
        }
        
        <span class="keyword">for</span> character <span class="keyword">in</span> <span class="type">Array</span>(string) {
            count[<span class="call">characterToNumber</span>(character)] += <span class="number">1</span>
        }
        
        <span class="keyword">return</span> count
    }
    
    <span class="keyword">private func</span> characterCountToKey(<span class="keyword">_</span> characterCount: [<span class="type">Int</span>]) -&gt; <span class="type">String</span> {
        <span class="keyword">var</span> string = <span class="string">""</span>
        
        <span class="keyword">for</span> count <span class="keyword">in</span> characterCount {
            string += <span class="string">"#\(count)"</span>
        }
        
        <span class="keyword">return</span> string
    }
}
</code></pre><p>Also it's possible to use <em>counting sort</em> for an optimal solution.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Searching</guid><title>Searching</title><description></description><link>https://www.staskus.io/notes/Searching</link><pubDate>Thu, 21 Apr 2022 20:47:50 +0300</pubDate><content:encoded><![CDATA[<h2>Binary Search</h2><p>In binary search, we look for an element in a sorted array by comparing x to the middle of the array. If x is less we search on the left, if x is more we search on the right. We repeat until we find the x, or there are no more partitions we can make.</p><pre><code><span class="keyword">func</span> binarySearch(<span class="keyword">_</span> array: [<span class="type">Int</span>], <span class="keyword">_</span> x: <span class="type">Int</span>) -&gt; <span class="type">Int</span>? {
    <span class="keyword">var</span> low = <span class="number">0</span>
    <span class="keyword">var</span> high = array.<span class="property">count</span> - <span class="number">1</span>
    <span class="keyword">var</span> mid = <span class="number">0</span>

    <span class="keyword">while</span> low &lt;= <span class="call">high</span> {
        mid = low + high / <span class="number">2</span>

        <span class="keyword">if</span> array[mid] &gt; x {
            high = mid - <span class="number">1</span>
        } <span class="keyword">else if</span> array[mid] &lt; {
            low = mid + <span class="number">1</span>
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> mid
        }

        <span class="keyword">return nil</span>
    }
}
</code></pre><h2>Quick Select</h2><p>Time: average and best - O(n), worst - O(n^2). Space - O(1).</p><p>Used to find the k or kth smallest/largest elements. It is a deviation of a quick sort.</p><ol><li>Pick a pivot (for example mid element)</li><li>Add smaller elements to <strong>less</strong> array, increase index <strong>p</strong> every time we find a smaller element</li><li>Put the pivot into <strong>p</strong> position</li><li>We will have <em>less</em> array, pivot and <em>greater</em> array</li><li>What we know at this point is that an element in <strong>p</strong> position is the pth largest value</li><li>If we need to find k smallest values, if k == p, all the elements in <strong>less</strong> array are the smallest values</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Linked%20Lists</guid><title>Linked Lists</title><description></description><link>https://www.staskus.io/notes/Linked%20Lists</link><pubDate>Wed, 13 Apr 2022 17:16:39 +0300</pubDate><content:encoded><![CDATA[<p>In a linked list, each node points to the next node in the linked list. In a doubly-linked-list, each node also points to the previous node.</p><p>The benefit of a linked list is that items are added and removed in constant time.</p><h2>The Runner Technique</h2><p>Iterate through the linked list with two pointers simultaneously, one going faster than the other.</p><h2>Recursion</h2><p>Many linked list problems are solved with recursion. The only caveat is that it takes at least O(n) space.</p><h2>Example tasks to know how to solve:</h2><h3>Remove nth element from the end</h3><p>We could use the 2 runner technique to solve this issue. We can have one pointer always nth the elements behind it. When the first pointer reaches the end, we have a second pointer point to the nth element from the end that we need to remove.</p><h3>Partition a linked list by value</h3><p>It could be done by creating 2 linked lists one with values larger than the given value and the other one with smaller values and in the end, merging those lists.</p><h3>Check if singly-linked-list values construct a palindrome</h3><p>To do this in place with O(1) space complexity we need to work directly on the list.</p><ul><li>Using the runner technique: fast and slow pointers. When the fast reaches the end, the slow reaches the middle</li><li>Reverse the linked list from the middle</li><li>Compare values one by one, from the start and the middle</li></ul><h3>Find the intersection of two linked lists</h3><ul><li>A medium solution would be to put nodes into a hashtable and compare</li><li>The best solution is to calculate the lengths of two linked lists and then compare the nodes at the same starting point</li></ul><p>Here's a clever way to find an intersection. The trick is to set the value of one of the current nodes to the head of the other list when the end is reached:</p><pre><code>     <span class="keyword">func</span> getIntersectionNode(<span class="keyword">_</span> headA: <span class="type">ListNode</span>?, <span class="keyword">_</span> headB: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? { 
        <span class="keyword">var</span> currentA = headA
        <span class="keyword">var</span> currentB = headB
        
        <span class="keyword">while</span> currentA !== <span class="call">currentB</span> {
            currentA = currentA == <span class="keyword">nil</span> ? headB : currentA?.<span class="property">next</span>
            currentB = currentB == <span class="keyword">nil</span> ? headA : currentB?.<span class="property">next</span>
        }
        
        <span class="keyword">return</span> currentA
    }
</code></pre><h3>Detecting a loop in a linked list</h3><ul><li>A medium solution putting nodes into a hashtable (set). Have in mind that in Swift nodes have to be <code>Hashable</code> or simply wrapped in the <code>ObjectIdentifier</code> so we would compare references</li><li>The best solution is to detect a loop using the runner technique. If there's a loop, they will eventually meet. The harder part to understand is finding <strong>the start of the loop</strong>. It will be exactly between the <em>head</em> and the <em>collision</em> point. Therefore going step by step from the <em>head</em> and the <em>collision</em> the next collision will happen at <em>the start of the loop</em>.</li></ul><pre><code>   <span class="keyword">func</span> colissionNode(<span class="keyword">_</span> head: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? {
        <span class="keyword">var</span> slow = head
        <span class="keyword">var</span> fast = head
        
        <span class="keyword">while</span> fast?.<span class="property">next</span> != <span class="keyword">nil</span> {
            slow = slow?.<span class="property">next</span>
            fast = fast?.<span class="property">next</span>?.<span class="property">next</span>
            
            <span class="keyword">if</span> slow === fast {
                <span class="keyword">return</span> slow
            }
        }
        
        <span class="keyword">return nil</span>
    }
</code></pre><p>If we do the math we can see that F = b, therefore going step by step from the start and from the point h we will reach the start of the loop: <img src="https://www.staskus.io/images/notes/67ea9a4463080be07ce89fc92ba437d53482bdce56217f6ff1ffe17e021bf200.png" alt="LeetCode.com"/><br><br>### Merge two sorted lists</p><p>We can do that recursively and iteratively. By doing it iteratively we save space and have constant space complexity.</p><p>The algorithm relies on 3 concepts: - Creating a prehead, that we use as a beginning of our merged list - Keeping the previous pointer, that allows merging step by step - In the end, connect to a non-merged part of a list. It can happen when lists are not of the same size.</p><pre><code><span class="comment">// Time Complexity O(n+m)
// Space Complexity O(1)</span>
<span class="keyword">func</span> mergeTwoLists(<span class="keyword">_</span> list1: <span class="type">ListNode</span>?, <span class="keyword">_</span> list2: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? {
    <span class="keyword">guard let</span> list1 = list1 <span class="keyword">else</span> { <span class="keyword">return</span> list2 }
    <span class="keyword">guard let</span> list2 = list2 <span class="keyword">else</span> { <span class="keyword">return</span> list1 }
    
    <span class="keyword">var</span> list1Ptr: <span class="type">ListNode</span>? = list1
    <span class="keyword">var</span> list2Ptr: <span class="type">ListNode</span>? = list2
    <span class="keyword">var</span> previousPtr: <span class="type">ListNode</span>?
    <span class="keyword">var</span> prehead: <span class="type">ListNode</span>? = <span class="type">ListNode</span>(-<span class="number">1</span>)
    
    previousPtr = prehead
    
    <span class="keyword">while</span> list1Ptr != <span class="keyword">nil</span>, list2Ptr != <span class="keyword">nil</span> {            
        <span class="keyword">if</span> list1Ptr!.val &lt;= list2Ptr!.val {
            previousPtr?.<span class="property">next</span> = list1Ptr
            list1Ptr = list1Ptr?.<span class="property">next</span>
        } <span class="keyword">else</span> {
            previousPtr?.<span class="property">next</span> = list2Ptr
            list2Ptr = list2Ptr?.<span class="property">next</span>
        }
        
        previousPtr = previousPtr?.<span class="property">next</span>
    }
    
    previousPtr?.<span class="property">next</span> = list1Ptr == <span class="keyword">nil</span> ? list2Ptr : list1Ptr
    
    <span class="keyword">return</span> prehead?.<span class="property">next</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Strings</guid><title>String manipulation</title><description></description><link>https://www.staskus.io/notes/Strings</link><pubDate>Fri, 8 Apr 2022 16:02:32 +0300</pubDate><content:encoded><![CDATA[<h2>Example problem</h2><h3>Longest Substring Without Repeating Characters</h3><p>The <strong>sliding window</strong> approach is most intuitive. We should aim for O(n) time complexity and constant space complexity if the charset is made only from ASCII characters.</p><ol><li>Remember used letters</li><li>When the right side of the window encounters the letter that is already used, move the left side of the window to the position after the first occurrence of that letter</li><li>The longest substring is the largest distance between the left and the right side of the windows</li></ol><h3>Longest Repeating Character Replacement</h3><p>What is the longest substring with repeating letters, allowing <em>k</em> replacements.</p><p>To solve the problem we need to think about <em>k</em> replacements as <em>allowed mistakes</em> inside a string.</p><p>We can use the same <strong>sliding window</strong> approach. However, we increase <em>start index</em> when there are more mistakes than allowed.</p><pre><code><span class="keyword">func</span> characterReplacement(<span class="keyword">_</span> s: <span class="type">String</span>, <span class="keyword">_</span> k: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">var</span> startIndex = <span class="number">0</span>
    <span class="keyword">var</span> letters = <span class="type">Array</span>(s)
    <span class="keyword">var</span> letterCount = <span class="type">Array</span>(repeating: <span class="number">0</span>, count: <span class="number">26</span>)
    <span class="keyword">var</span> longestSubstring = <span class="number">0</span>
    <span class="keyword">var</span> maxCount = <span class="number">0</span>
            
    <span class="keyword">for</span> (index, letter) <span class="keyword">in</span> letters.<span class="call">enumerated</span>() {    
        maxCount = <span class="call">max</span>(maxCount, (letterCount[<span class="call">position</span>(for: letter)] + <span class="number">1</span>))
        letterCount[<span class="call">position</span>(for: letter)] += <span class="number">1</span>
        
        <span class="keyword">while</span> mistakes(from: startIndex, to: index, max: maxCount) &gt; <span class="call">k</span> {
            letterCount[<span class="call">position</span>(for: letters[startIndex])] -= <span class="number">1</span>
            startIndex += <span class="number">1</span>
        }
                    
        longestSubstring = <span class="call">max</span>(longestSubstring, index - startIndex + <span class="number">1</span>)
    }
    
    <span class="keyword">return</span> longestSubstring
}

<span class="keyword">private func</span> mistakes(from startIndex: <span class="type">Int</span>, to endIndex: <span class="type">Int</span>, max: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> endIndex - startIndex + <span class="number">1</span> - max
}
    
<span class="keyword">private func</span> position(for letter: <span class="type">Character</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="type">Int</span>(letter.<span class="property">asciiValue</span>! - <span class="type">Character</span>(<span class="string">"A"</span>).<span class="property">asciiValue</span>!)
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Object%20Oriented%20Design</guid><title>Object-Oriented Design</title><description></description><link>https://www.staskus.io/notes/Object%20Oriented%20Design</link><pubDate>Fri, 8 Apr 2022 10:39:33 +0300</pubDate><content:encoded><![CDATA[<p>When designing a system it's important to know how to:</p><ol><li>Handle Ambiguity. Ask questions about who, what, where, when, who, and why to design a system for a clear purpose.</li><li>Define the Core Objects (Person, Table, Meal, etc)</li><li>Define Relationships</li><li>Investigate Actions</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/System%20Design%20and%20Scalability</guid><title>System Design and Scalability</title><description></description><link>https://www.staskus.io/notes/System%20Design%20and%20Scalability</link><pubDate>Wed, 6 Apr 2022 09:04:22 +0300</pubDate><content:encoded><![CDATA[]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Math%20and%20Logic%20Puzzles</guid><title>Math and Logic Puzzles</title><description></description><link>https://www.staskus.io/notes/Math%20and%20Logic%20Puzzles</link><pubDate>Thu, 31 Mar 2022 09:54:42 +0300</pubDate><content:encoded><![CDATA[<h2>Popular tasks</h2><h3>Generate a list of prime numbers</h3><pre><code><span class="comment">// The Sieve of Eeratosthenes is a way to generate a list of primes by recognizing that all non-prime numbers are divisible by a prime number

// The idea is to cross of numbers that are divisible by the next available prime

// Example: 13

// We cross of powers of 2: 4, 6, 8, 10, 12
// Then cross of powers of 3: 9, 12
// We do that until the prime we pass is less than or equal to the square root of the max number

// We can optimize by only dealing with odd numbers</span>

<span class="keyword">func</span> countPrimes(<span class="keyword">_</span> n: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">guard</span> n &gt;= <span class="number">2</span> <span class="keyword">else</span> { <span class="keyword">return</span> <span class="number">0</span> }
    
    <span class="keyword">var</span> flags: [<span class="type">Bool</span>] = <span class="type">Array</span>(repeating: <span class="keyword">true</span>, count: n)
    flags[<span class="number">0</span>] = <span class="keyword">false</span>
    flags[<span class="number">1</span>] = <span class="keyword">false
    
    var</span> prime = <span class="number">2</span>
    
    <span class="keyword">while</span> prime &lt;= <span class="type">Int</span>(<span class="type">Double</span>(n).<span class="call">squareRoot</span>()) {
        <span class="call">crossOff</span>(flags: &amp;flags, prime: prime)
        
        prime = <span class="call">getNextPrime</span>(flags: flags, prime: prime)
    }
    
    <span class="keyword">return</span> flags
        .<span class="call">filter</span> { $0 }  
        .<span class="dotAccess">count</span>
}

<span class="keyword">private func</span> crossOff(flags: <span class="keyword">inout</span> [<span class="type">Bool</span>], prime: <span class="type">Int</span>) {
    <span class="keyword">for</span> i <span class="keyword">in</span> stride(from: prime * prime, to: flags.<span class="property">count</span>, by: prime) {
        flags[i] = <span class="keyword">false</span>
    }
}

<span class="keyword">private func</span> getNextPrime(flags: [<span class="type">Bool</span>], prime: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">var</span> next = prime + <span class="number">1</span>
    
    <span class="keyword">while</span> next &lt; flags.<span class="property">count</span> &amp;&amp; !flags[next] {
        next += <span class="number">1</span>
    }
    
    <span class="keyword">return</span> next
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Bit%20Manipulation</guid><title>Bit Manipulation</title><description></description><link>https://www.staskus.io/notes/Bit%20Manipulation</link><pubDate>Wed, 30 Mar 2022 17:32:36 +0300</pubDate><content:encoded><![CDATA[<pre><code><span class="type">X</span> ^ 0s = <span class="type">X 
X</span> &amp; 0s = <span class="number">0</span> 
<span class="type">X</span> | 0s = <span class="type">X 

X</span> ^ 1s = !x 
<span class="type">X</span> &amp; 1s = <span class="type">X 
X</span> | 1s = 1s 

<span class="type">X</span> ^ <span class="type">X</span> = <span class="number">0</span> 
<span class="type">X</span> &amp; <span class="type">X</span> = <span class="type">X 
X</span> | <span class="type">X</span> = <span class="type">X</span>
</code></pre><p><strong>Logical Shift</strong> - we shift the bits and put 0 in the most significant bit. <strong>Arithmetic Shift</strong> - we shift values to the right but fill new bits with the values of the sign bit. Essentially meaning division by 2.</p><h2>Example Tasks</h2><h3>Get Bit</h3><pre><code><span class="keyword">func</span> getBit(num: <span class="type">Int</span>, position: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> (num &amp; (<span class="number">1</span> &lt;&lt; position)) != <span class="number">0</span>
}

<span class="call">getBit</span>(num: <span class="number">5</span>, position: <span class="number">2</span>) <span class="comment">// 0101 &amp; 0100 = 0100 != 0</span>
<span class="call">getBit</span>(num: <span class="number">5</span>, position: <span class="number">1</span>) <span class="comment">// 0101 &amp; 0010 = 0000 == 0</span>
</code></pre><h3>What does code (n &amp; n-1) == 0 do?</h3><p>This logic checks if n is a power of 2 (or if n is 0)</p><h3>Write a function to determine the number of bits you need to flip to convert integer A to integer B</h3><pre><code><span class="keyword">func</span> bitSwapsRequired(<span class="keyword">_</span> a: <span class="type">Int</span>, <span class="keyword">_</span> b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">var</span> count = <span class="number">0</span>

    <span class="keyword">var</span> i = a ^ b

    <span class="keyword">while</span> i != <span class="number">0</span> {
        count += <span class="number">1</span>
        i = i &amp; (i - <span class="number">1</span>)
    }

    <span class="keyword">return</span> count
}

<span class="call">print</span>(<span class="call">bitSwapsRequired</span>(<span class="number">29</span>, <span class="number">15</span>)) <span class="comment">// 2</span>
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Stacks%20and%20Queues</guid><title>Stacks and Queues</title><description></description><link>https://www.staskus.io/notes/Stacks%20and%20Queues</link><pubDate>Thu, 24 Mar 2022 11:45:59 +0200</pubDate><content:encoded><![CDATA[<h2>Stack</h2><p>A stack has LIFO ordering. Main operations:</p><ul><li>pop() - remove the top element</li><li>push(_) - add an item to the top</li><li>peek() - look at the top element</li><li>isEmpty() - true if there're no elements</li></ul><h3>Usage</h3><ul><li>Recursive algorithms</li></ul><h2>Queue</h2><p>A queue has FIFO ordering. Main operations:</p><ul><li>add(_) - aedd an item to the bottom</li><li>remove() - remove the top element</li><li>peek() - look at the top element</li><li>isEmpty() - true if there're no elements</li></ul><h3>Usage</h3><ul><li>Breadth-first-search</li><li>Implementing a cache</li></ul><h2>Time complexity</h2><ul><li>O(n) for accessing nth item</li><li>O(1) for adding and removing an item</li></ul><h2>Example tasks to know how to solve:</h2><h3>Min Stack</h3><p>A stack that also can get a minimum value.</p><p>The trick here is to understand that minimum value only changes if the new smaller stack element is added. If this element is removed, we need to come back to an old minimum value. To achieve this we need to save a current min value with each <em>Node</em>. As it's a LIFO data structure we sort of have a timeline of minimum values.</p><h3>Implement Queue using 2 Stacks</h3><ul><li>Since the queue is FIFO and stack is LIFO we can reverse element order by moving elements from one stack to another. Doing it every push operation produces a time complexity of O(n)</li><li>We can do an <em>amortized</em> solution with having <em>old</em> and <em>new</em> stack. Only if the <em>old</em> (reversed) element stack is empty, we shift elements from <em>new</em> to <em>old</em>. This makes the average scenario much more effective than the worst-case scenario.</li></ul><h3>Stack supporting different types</h3><p>If the stack needs to support <em>popAnyType()</em>, <em>popTypeA()</em> and <em>popTypeB()</em> the best solution is to have separate stacks for both typeA and typeB and save a timestamp next to the nodes. When we do <em>popAnyType()</em> we can check which stack has the oldest element on top and return that.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Big0</guid><title>Big O</title><description></description><link>https://www.staskus.io/notes/Big0</link><pubDate>Thu, 24 Mar 2022 11:45:46 +0200</pubDate><content:encoded><![CDATA[<p>Big O describes the efficiency of algorithms.</p><h2>Time Complexity</h2><h2>Space Complexity</h2><p>Space complexity is the amount of memory required by an algorithm.</p><h3>Recursive calls</h3><p>In recursive functions, each call is added to the stack and we take this space into account.</p><h2>Cases</h2><ul><li>Best Case</li><li>Worst Case</li><li>Expected Case</li></ul><p>The best case is not insightful. The expected case and the worst case are usually the same but not always.</p><h2>Simplification</h2><p>Big O is only concerned about the <em>rate of increase</em> and expressed how the runtime scales, thus we can drop the constants and non-dominant terms. O(2N) is just O(N).</p><ul><li>O(N$^2$ + N) is O($N^2$)</li><li>O(N + log N) is O(N)</li><li>O(100*2$^2$ + 5000N$^2$) is O(2$^n$)</li></ul><img src="https://www.staskus.io/images/notes/42d971b30d15ec5efd2f8e1238e39424451afd922a0d719fa83811f80aeaf160.png" alt="Complexities - GeeksForGeeks.org"/><p>However, have in mind that it's usually not possible to remove <em>multiple variables</em>, they still need to be represented in the notation.</p><p>For example, to sort an array of sorted strings the complexity would be <em>O($a</em>s$(log a + log s))*, where a - array length, s - longest string length. In such cases, we cannot simplify much further.</p><h3>O(n)</h3><p>The algorithm that reverses an array only going through half of the array does not impact big O time and still has O(n) time complexity.</p><h3>O(log N)</h3><p>An algorithm will likely have an O(log N) runtime when the number of elements in the problem space gets halved at every step. Example - binary search.</p><h3>O(2$^n$)</h3><p>The base of an exponential complexity matters.</p><h3>O(2$^l$$^o$$^g$$^N$)</h3><p>This expression can be simplified to O(n). If we search binary tree making recursive calls the depth is roughly logN so it doesn't turn the recursive function exponential.</p><h2>Memoization</h2><p>Caching previously computed values is an optimization technique called memoization. It is a very common way to optimize exponential time recursive algorithms.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Strategy</guid><title>A problem-solving flow</title><description></description><link>https://www.staskus.io/notes/Strategy</link><pubDate>Tue, 22 Mar 2022 21:42:40 +0200</pubDate><content:encoded><![CDATA[<h2>A problem-solving flow</h2><ol><li>Listen and clarify the question. Write down the important bits of information.</li><li>Go through the examples and create your own example. Draw if possible.</li><li>State a brute-force solution and its time &amp; space complexities</li><li>Optimize<ol><li>Look for bottlenecks, unnecessary work, and duplicated work</li><li>Maybe there are unused bits of information from the description?</li><li>Try going through the solution with different examples</li><li>Try to solve with simplest example and make it bit by bit more complex</li><li>Make time vs space tradeoff</li><li>Computing some values (like sorting) upfront</li><li>Brainstorm all the possible data structures</li><li>Think about the best possible runtime and then how to achieve it</li><li>Walkthrough the approach in detail</li><li>Implement keeping coding standards in mind</li><li>Test</li><li>Code review</li><li>Small test cases</li><li>Special cases and edge cases</li></ol></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-06-23-app-clip</guid><title>App Clips: A first glance at the new way to access an iOS app</title><description></description><link>https://www.staskus.io/posts/2020-06-23-app-clip</link><pubDate>Tue, 23 Jun 2020 18:00:00 +0300</pubDate><content:encoded><![CDATA[<p>During <a href="https://developer.apple.com/wwdc20/">WWDC20</a> Apple is introducing new <a href="https://developer.apple.com/app-clips/">App Clips</a> feature. As it's described in the landing page:</p><blockquote><p>An app clip is a small part of your app that’s discoverable at the moment it’s needed.</p></blockquote><p>Apple already suggested some possible use cases such as ordering from a take-out restaurant or renting a scooter. And App Clips will be discovered and invoked by using new App Clip Codes, NFC Tags, QR Codes, Messages, or as place cards in Maps.</p><p>It looks like a great move forward in reducing friction and getting an app into users' hands as fast as possible.</p><p>We'll take a look at the initial steps of how these App Clips could be implemented and introduced in the project.</p><h1>Prerequisites</h1><p>Xcode 12 or higher.</p><h1>Getting Started</h1><p>We start by creating a new project and selecting the creation of a new target.</p><img src="https://www.staskus.io/images/app-clip/new_target.png" alt="App Clip New Target" width="600"/><p>We select a new App Clip target and add it to our application.</p><img src="https://www.staskus.io/images/app-clip/new_target_app_clip.png" alt="App Clip New Target" width="600"/><h1>Add Associated Domain</h1><p>We need to provide an associated domain for both App and App Clip targets. If App is not installed the link will open App Clip. Otherwise full App will be opened instead.</p><p>We do it by selecting <em>Target -&gt; Signing &amp; Capabilities</em>, clicking + sign, and choosing Associated Domains.</p><img src="https://www.staskus.io/images/app-clip/associated_domains.png" alt="Creating Associated Domain" width="600"/><p>Next, we enter our associated domain value which must follow pattern of <em>appclips:domain</em>. In this instance, we can enter <em>appclips:example.com</em>.</p><img src="https://www.staskus.io/images/app-clip/associated_domains_example.png" alt="Associated Domains Example" width="600"/><h1>Running App Clip target</h1><p>App Clip target can be run and debugged just like an App target.</p><p>We can open <code>ContentView.swift</code> inside an App Clip target, make changes, and run.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello, App Clip!"</span>).<span class="call">padding</span>()
    }
}
</code></pre><img src="https://www.staskus.io/images/app-clip/hello_app_clip.png" alt="Hello App Clip Simulator Screen" width="300"/><h1>Configuring App Clip</h1><p>App Clip is invoked via URL which can contain context-related information and be used in the configuration.</p><p>Let's say we want to provide a user with a more personalized greeting message after App Clip was invoked. We can pass binding <code>name</code> variable to <code>ContentView</code>.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@Binding var</span> name: <span class="type">String</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello,</span> \(name)<span class="string">"</span>).<span class="call">padding</span>()
    }
}
</code></pre><p>This example uses a new App lifecycle in SwiftUI which enables entire apps to be written completely in SwiftUI.</p><p>Information about invocation is passed through lifecycle events. We can use <code>onContinueUserActivity</code> to be notified about App Clip being launched with parameters.</p><p>More information about using legacy lifecycles can be found on <a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Access the Invocation URL section</a>.</p><p>After that, we take the incoming URL and its first path component. Now first path parameter passed through URL will be set as a name.</p><pre><code><span class="keyword">@main
struct</span> AppClipSneakPeekClipApp: <span class="type">App</span> {
    <span class="keyword">@State var</span> name = <span class="string">""</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> {
        <span class="type">WindowGroup</span> {
            <span class="type">ContentView</span>(name: $name).<span class="call">onContinueUserActivity</span>(<span class="type">NSUserActivityTypeBrowsingWeb</span>, perform: respondTo)
        }
    }

    <span class="keyword">func</span> respondTo(<span class="keyword">_</span> activity: <span class="type">NSUserActivity</span>?) {
        <span class="keyword">guard let</span> name = <span class="call">firstParameterValue</span>(from: activity) <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="keyword">self</span>.<span class="property">name</span> = name
    }

    <span class="keyword">private func</span> firstParameterValue(from activity: <span class="type">NSUserActivity</span>?) -&gt; <span class="type">String</span>? {
        <span class="comment">// Parsing components from URL</span>
        <span class="keyword">guard let</span> activity = activity <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        <span class="keyword">guard let</span> incomingURL = activity.<span class="property">webpageURL</span> <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        <span class="keyword">guard let</span> components = <span class="type">NSURLComponents</span>(url: incomingURL, resolvingAgainstBaseURL: <span class="keyword">true</span>) <span class="keyword">else</span> { <span class="keyword">return nil</span> }

        <span class="comment">// Taking first parameter: example.com/?parameter=Lisa</span>
        <span class="keyword">return</span> components.<span class="property">queryItems</span>?.<span class="property">first</span>?.<span class="property">value</span>
    }
}
</code></pre><h1>Testing</h1><p>Launching AppClip target now does not show any name value. It makes sense as we didn't pass any URL with parameters to our app.</p><p>We can automatically test it by providing <em>Environment Variable</em> for App Clip scheme. It can be done by selecting <code>App Clip scheme -&gt; Edit Scheme -&gt; Run</code> and set the value of <em>_XCAppClipURL</em> of test URL value. We set it to <em>https://example.com/?parameter=Lisa</em> to have a first parameter value.</p><img src="https://www.staskus.io/images/app-clip/testing.png" alt="Adding Environment Variable" width="600"/><p>If we launch the application now, the value is received through lifecycle event and updated inside a view.</p><img src="https://www.staskus.io/images/app-clip/testing_success.png" alt="iOS Simulator with result" width="300"/><h2>What about App Clip Card?</h2><p>App Clip Card itself that is shown with a suggestion to open an App Card is not developed through Xcode. The information displayed in this card can be configured through <a href="https://appstoreconnect.apple.com/login">App Store Connect</a>. Developers will be able to change a header image, subtitle, and title on the action button.</p><h1>Where do we go from here?</h1><p>App Clip looks like a promising addition to the ecosystem and it will be interesting to see how it will be used and adopted by both developers and users.</p><p>The example project can be found on <a href="https://github.com/staskus/AppClipSneakPeekApp">GitHub</a>.</p><p>Apple provides a lot of helpful resources for going more in-depth into App Clips.</p><ul><li><a href="https://developer.apple.com/documentation/app_clips">Developing a Great App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/creating_an_app_clip">Creating an App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Responding to Invocation</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Configuring Your App Clip’s Launch Experience</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Testing Your App Clip’s Launch Experience</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-01-26-publish</guid><title>Migrating from Jekyll to Publish: A site generator for Swift developers</title><description></description><link>https://www.staskus.io/posts/2020-01-26-publish</link><pubDate>Sun, 26 Jan 2020 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/JohnSundell/Publish">Publish</a> is a static site generator built for Swift developers. We'll be migrating a static blog generation from <a href="https://jekyllrb.com">Jekyll</a> to Publish. The previous version of a blog was generated using Jekyll and a provided theme without putting too much effort in understanding the whole creation process. This time I decided to dig deeper into understanding Publish and remembering long forgotten <em>HTML</em> and <em>CSS</em> skills.</p><p>We'll be trying to create a similar style blog that was created using Jekyll. It should remain adaptable for bigger or smaller screen sizes:</p><h4>Previous desktop version</h4><img src="https://www.staskus.io/images/publish/previous_1.png" alt="Previous desktop version of a blog" width="500"/><h4>Previous mobile version</h4><img src="https://www.staskus.io/images/publish/previous_2.png" alt="Previous mobile version of a blog" width="300"/><h1>Getting Started</h1><p>After running the steps described in a <a href="https://github.com/JohnSundell/Publish">Publish repository</a> we end up with a sample project that showcases the main parts and features of Publish.</p><p>In the folder structure we can see <code>posts</code> folder that contains an example post. I copy-pasted my blog posts <code>.md</code> files from old Jekyll blog to see if it works. We only need to change couple fields to make it work. The only difference is a metadata format on top of <code>.md</code> file. By removing quotes from strings, brackets from arrays and renaming categories to tags we can get Jekyll articles immediately generated into a new blog.</p><img src="https://www.staskus.io/images/publish/blog_1.png" alt="Previous desktop version of a blog" width="500"/><h1>Website</h1><p>If we open up <code>main.swift</code> file we see:</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>In Publish a website is a simple Swift struct that should contain mandatory fields required by a <code>Website</code> protocol as well as any additional fields that might be needed.</p><p>As this blog contains personal information as well as links to social media accounts, I included them in a <code>Blog</code> structure.</p><pre><code><span class="keyword">struct</span> Blog: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> posts
        <span class="keyword">case</span> about
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
    	<span class="comment">// Additional field in post .md metadata</span>
        <span class="keyword">var</span> excerpt: <span class="type">String</span>
    }

    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.staskus.io"</span>)!
    <span class="keyword">var</span> title = <span class="string">"staskus.io"</span>
    <span class="keyword">var</span> name = <span class="string">"Povilas Staškus"</span>
    <span class="keyword">var</span> description = <span class="string">"iOS Developer"</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="keyword">nil</span> }
    <span class="keyword">var</span> socialMediaLinks: [<span class="type">SocialMediaLink</span>] { [.<span class="dotAccess">location</span>, .<span class="dotAccess">email</span>, .<span class="dotAccess">linkedIn</span>, .<span class="dotAccess">github</span>, .<span class="dotAccess">twitter</span>] }
}
</code></pre><h1>Theme</h1><p>Basic <code>foundation</code> theme is used after generating a website for the first time. However, it's only there to give an example of how custom site theme should be created.</p><p>A <code>Theme</code> is built by conforming to <code>HTMLFactory</code> protocol.</p><p>Not all the pages are needed to be created for your site to be fully functioning. For a blog we must have: 1) an index page, that shows header, sidebar and list of posts. 2) item page, that will show full post.</p><pre><code><span class="keyword">class</span> BlogHTMLFactory: <span class="type">HTMLFactory</span> {

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>,
                       context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of an Index Page</span>
    }

    <span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Section</span>&lt;<span class="type">Site</span>&gt;,
                         context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Section Index Page that displays section items</span>
    }

    <span class="keyword">func</span> makeItemHTML(for item: <span class="type">Item</span>&lt;<span class="type">Site</span>&gt;,
                      context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Post Page</span>
    }

    <span class="keyword">func</span> makePageHTML(for page: <span class="type">Page</span>,
                      context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Section Page</span> 
    }

    <span class="keyword">func</span> makeTagListHTML(for page: <span class="type">TagListPage</span>,
                         context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    	<span class="comment">// Returning HTML of a Page with list of available tags</span>
    }

    <span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">TagDetailsPage</span>,
                            context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    	<span class="comment">// Returning HTML of a Page for a specific tag</span>
    }
}
</code></pre><p>Although we can write <code>HTML</code> code using Swift, the styling of the site is done using <code>CSS.</code> For the creation of this blog, I decided to use <a href="https://purecss.io">Pure.css</a>. The desired blog theme is quite minimalist and the features that <a href="https://purecss.io">Pure.css</a> provides seem more than enough to achieve what we want. Even after many years without any <code>CSS</code> and <code>HTML</code> experience it was possible to make pretty decent layout. For the rest of this article, we won't be focusing on that. The code can be found on <a href="https://github.com/staskus/Blog">GitHub</a> for those who are interested.</p><h2>Index Page</h2><p><code>makeIndexHTML</code> builds HTML of an index page. The structure is the same as writing plain HTML tags. We set <em>language</em>, <em>head</em> and then structure layout inside <em>body</em>.</p><p>Body uses <code>.grid</code> node that creates Pure.css grid in which we can structure our layout. We have <code>.header</code>, <code>.sidebar</code>, <code>.posts</code> and <code>.footer</code> that are put one after the other.</p><pre><code><span class="keyword">class</span> BlogHTMLFactory: <span class="type">HTMLFactory</span> {

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>,
                       context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="type">HTML</span>(
            .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
            .<span class="call">head</span>(for: context.<span class="property">site</span>),
            .<span class="call">body</span>(
                .<span class="call">grid</span>(
                    .<span class="call">header</span>(for: context.<span class="property">site</span>),
                    .<span class="call">sidebar</span>(for: context.<span class="property">site</span>),
                    .<span class="call">posts</span>(
                        for: context.<span class="call">allItems</span>(
                            sortedBy: \.<span class="property">date</span>,
                            order: .<span class="dotAccess">descending</span>
                        ),
                        on: context.<span class="property">site</span>,
                        title: <span class="string">"Recent posts"</span>
                    ),
                    .<span class="call">footer</span>(for: context.<span class="property">site</span>)
                )
            )
        )
    }
}
</code></pre><p>Any node can be written as a <code>static</code> func extension of a <code>Node</code>. <code>Context == HTML.BodyContext</code> indicate that this node can be only used inside <em>body</em>. It's a nice and clean way to declare new nodes, as they can be then used using dot syntax.</p><pre><code><span class="keyword">extension</span> <span class="type">Node</span> <span class="keyword">where</span> <span class="type">Context</span> == <span class="type">HTML</span>.<span class="type">BodyContext</span> {
    <span class="keyword">static func</span> grid(<span class="keyword">_</span> nodes: <span class="type">Node</span>...) -&gt; <span class="type">Node</span> {
        .<span class="call">div</span>(
            .<span class="call">id</span>(<span class="string">"layout"</span>),
            .<span class="call">class</span>(<span class="string">"pure-g"</span>),
            .<span class="call">group</span>(nodes)
        )
    }
}
</code></pre><h2>Post</h2><p>A post can be declared the same way as any other node. On the top, we show the title of the post. Below, we show date. We can use any powerful features that Swift infrastructure provides us. In this instance, we use <code>DateFormatter</code> to format a date. In a similar way any more complex or sophisticated logic could be used inside this code.</p><pre><code><span class="keyword">extension</span> <span class="type">Node</span> <span class="keyword">where</span> <span class="type">Context</span> == <span class="type">HTML</span>.<span class="type">BodyContext</span> {
    <span class="keyword">static func</span> post(for item: <span class="type">Item</span>&lt;<span class="type">Blog</span>&gt;, on site: <span class="type">Blog</span>) -&gt; <span class="type">Node</span> {
        <span class="keyword">return</span> .<span class="call">pageContent</span>(
            .<span class="call">h2</span>(
                .<span class="call">class</span>(<span class="string">"post-title"</span>),
                .<span class="call">a</span>(
                    .<span class="call">href</span>(item.<span class="property">path</span>),
                    .<span class="call">text</span>(item.<span class="property">title</span>)
                )
            ),
            .<span class="call">p</span>(
                .<span class="call">class</span>(<span class="string">"post-meta"</span>),
                .<span class="call">text</span>(<span class="type">DateFormatter</span>.<span class="property">blog</span>.<span class="call">string</span>(from: item.<span class="property">date</span>))
            ),
            .<span class="call">tagList</span>(for: item, on: site),
            .<span class="call">div</span>(
                .<span class="call">class</span>(<span class="string">"post-description"</span>),
                .<span class="call">div</span>(
                    .<span class="call">contentBody</span>(item.<span class="property">body</span>)
                )
            )
        )
    }
}
</code></pre><h2>Finishing the theme</h2><p>We can make our theme accessible by creating <code>Theme</code> object and passing our <code>BlogHTMLFactory</code>. Declaring it as a <em>static var</em> inside an extension allows reaching it more conveniently.</p><pre><code><span class="keyword">extension</span> <span class="type">Theme</span> <span class="keyword">where</span> <span class="type">Site</span> == <span class="type">Blog</span> {
    <span class="keyword">static var</span> blog: <span class="type">Self</span> {
        <span class="type">Theme</span>(htmlFactory: <span class="type">BlogHTMLFactory</span>())
    }
}
</code></pre><h1>Generating the site</h1><p>We've seen how by creating nodes we can step by step create pages for our blog. However, I would argue that the biggest power of Publish comes from <code>plugins</code> and additional building steps that we can create or use.</p><p><a href="https://github.com/JohnSundell/Splash">Splash</a> is a Swift syntax highlighter for blogs that has a plugin built for Publish. During the blog generation process, this plugin uses markdown parser to identify code inside <code>.md</code> files and apply syntax highlighting.</p><p>We can use or build any steps that might do additional checks, append necessary information or simply tweak a site in any way needed.</p><pre><code><span class="keyword">import</span> SplashPublishPlugin

<span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">blog</span>,
    additionalSteps: [.<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"staskus/nitesuit.github.io"</span>))],
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><h1>Result</h1><p>Publish worked seamlessly during development process. It provided all the convenience of Swift strong type system and helped stay focused while trying to figure unfamiliar web development workflows. Although Publish still misses many features that established static site generators have, it serves perfectly for its intended audience - Swift developers. Now that all the parts of the site are well understood, Publish together with Swift gives a lot of power for future improvements.</p><p>The code of the blog can be found on <a href="https://github.com/staskus/Blog">GitHub</a>.</p><h4>New desktop version</h4><img src="https://www.staskus.io/images/publish/blog_new_2.png" alt="New desktop version of a blog" width="500"/><h4>New mobile version</h4><img src="https://www.staskus.io/images/publish/blog_new_1.png" alt="New mobile version of a blog" width="300"/>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</guid><title>Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views</title><description></description><link>https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</link><pubDate>Sun, 24 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When starting to develop any application it's beneficial to think early about the way code can be testable and whether it would be scalable or maintainable. Many iOS applications have suffered from what is called <em>Massive View Controller</em> problem. By putting all the code that fetches, maps, presents and styles into one ViewController it very quickly overgrows in size and complexity. A lot of solutions where introduced to tackle this problem such as MVVM, MVVM + ReactiveCocoa or VIPER. In this application we'll be using <a href="https://clean-swift.com">Clean Swift</a> approach for breaking up massive view controllers into testable and maintainable parts.</p><h1>Data Structures</h1><h2>Data</h2><p><code>Struct</code> containing <em>raw data</em>.</p><pre><code>     <span class="keyword">struct</span> Data: <span class="type">Equatable</span> {
        <span class="keyword">let</span> regions: [<span class="type">Region</span>]
        <span class="keyword">let</span> trips: [<span class="type">Trip</span>]
    }
</code></pre><h2>View Model</h2><p><code>Struct</code> containing <em>State</em> (loading, error, empty, loaded) and mapped data that is used by <em>View Controllers</em> for configuring views.</p><pre><code>     <span class="keyword">struct</span> ViewModel: <span class="type">FeatureViewModel</span> {
        <span class="keyword">let</span> state: <span class="type">ViewState</span>&lt;<span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>&gt;
        <span class="keyword">let</span> title: <span class="type">String</span>

        <span class="keyword">struct</span> Content: <span class="type">FeatureContentViewModel</span>, <span class="type">Equatable</span> {
            <span class="keyword">var</span> rows: [<span class="type">FeedCardViewModel</span>]
            <span class="keyword">let</span> availableRegions: [<span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>.<span class="type">Region</span>]
            <span class="keyword">let</span> selectedRegion: <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>.<span class="type">Region</span>?

            <span class="keyword">struct</span> Region: <span class="type">Equatable</span> {
                <span class="keyword">let</span> id: <span class="type">String</span>
                <span class="keyword">let</span> name: <span class="type">String</span>
            }

            <span class="keyword">var</span> hasContent: <span class="type">Bool</span> {
                <span class="keyword">return</span> !rows.<span class="property">isEmpty</span>
            }
        }
    }
</code></pre><h2>Action</h2><p><code>Enum</code> with actions that <em>View Controller</em> can do and <em>Interactor</em> can handle.</p><pre><code>     <span class="keyword">enum</span> Action {
        <span class="keyword">case</span> load
        <span class="keyword">case</span> changeRegion(regionId: <span class="type">String</span>?)
    }
</code></pre><h2>Route</h2><p><code>Enum</code> with destinations that <em>View Controller</em> can route to.</p><pre><code>     <span class="keyword">enum</span> Route: <span class="type">Equatable</span> {
        <span class="keyword">case</span> book(<span class="type">Trip</span>)
    }
</code></pre><h1>Components</h1><h2>Interactor</h2><p>Receives an action, performs work and sends raw data to presenter.</p><ul><li>Input - <em>Action</em></li><li>Output - <em>Data</em></li><li>Uses - <em>Presenter</em></li></ul><h2>Presenter</h2><p>Receives raw data and maps it into <em>View Model</em></p><ul><li>Input - <em>Data</em></li><li>Output - <em>View Model</em></li></ul><h2>View Controller</h2><p>Receives <em>View Model</em> and configures a view according to it. Sends actions to <em>Interactor</em>.</p><ul><li>Input - <em>View Model</em></li><li>Output - <em>Action</em></li><li>Uses - <em>Interactor</em>, <em>Router</em></li></ul><h2>Router</h2><p>Receives <em>Route</em> object from <em>View Controller</em>, that contains information about next destination, and opens next <em>View Controller</em> using <em>Configurator</em></p><ul><li>Input - <em>Route</em></li><li>Uses - <em>Configurator</em></li></ul><h2>Configurator</h2><p>Takes an input and creates configured <em>View Controller</em> with other components.</p><ul><li>Input - Optional configuration data.</li><li>Output - <em>View Controller</em></li><li>Creates - <em>Interactor</em>, <em>Presenter</em>, <em>View Controller</em>, <em>Router</em></li></ul><h1>Feature</h1><p>The group of these components is called <code>Feature</code>. <a href="https://clean-swift.com">Clean Swift</a> provides with XCode templates that allow to generate all of these components together. We are using <a href="https://github.com/staskus/aerogami-ios/tree/master/templates/plop/Feature">plop templates</a> for feature generation. All of this allows to avoid writing boilerplate code and concentrate on actual code of the feature.</p><h1>Feed Example</h1><p><code>Feed</code> is a main <a href="https://github.com/staskus/aerogami-ios/tree/master/TravelFeatureKit/Features/Feed">feature</a> of the application. We're going to see how all of these different components is used to create a complete feature.</p><h2>Feed Interactor</h2><p><code>Feed Interactor</code> uses repositories of <em>Region</em>, <em>Trip</em> and <em>Airport</em> for loading data.</p><p><code>dispatch</code> function is an entry point of any <code>Interactor</code>.</p><pre><code>     <span class="keyword">func</span> dispatch(<span class="keyword">_</span> action: <span class="type">Feed</span>.<span class="type">Action</span>) {
        <span class="keyword">switch</span> action {
        <span class="keyword">case</span> .<span class="dotAccess">load</span>:
            contentState = .<span class="call">loading</span>(data: contentState.<span class="property">data</span>)
            <span class="call">load</span>()
        <span class="keyword">case</span> .<span class="dotAccess">changeRegion</span>(<span class="keyword">let</span> regionId):
            <span class="call">changeRegion</span>(id: regionId)
        }
    }
</code></pre><p>We can see when <code>FeedInteractor</code> receives <em>load</em> action it sets current state to <em>loading</em> and calls <code>load()</code> method. It combines <code>RegionRepository</code> and <code>TripRepository</code>, maps it to <em>Data</em> object and passes it to <code>FeedPresenter</code> by setting <em>contentState</em>.</p><pre><code>     <span class="keyword">func</span> load() {
        <span class="keyword">let</span> selectedRegion = regionRepository.<span class="call">getSelectedRegion</span>()

        <span class="type">Observable</span>.<span class="call">combineLatest</span>(
            <span class="keyword">self</span>.<span class="property">regionRepository</span>.<span class="call">getRegions</span>(),
            <span class="keyword">self</span>.<span class="property">tripRepository</span>.<span class="call">getTrips</span>(in: selectedRegion?.<span class="property">id</span>)
            )
            .<span class="call">map</span> { (regions, trips) -&gt; <span class="type">Feed</span>.<span class="type">Data</span> <span class="keyword">in
                return</span> <span class="type">Feed</span>.<span class="type">Data</span>(
                    regions: regions,
                    trips: trips,
                    selectedRegionId: selectedRegion?.<span class="property">id</span>,
                    tripImages: []
                )
            }
            .<span class="call">subscribe</span>(
                onNext: { data <span class="keyword">in
                    self</span>.<span class="property">contentState</span> = .<span class="call">loaded</span>(data: data, error: <span class="keyword">nil</span>)
                    <span class="keyword">self</span>.<span class="call">loadImages</span>(for: data.<span class="property">trips</span>)
                },
                onError: { error <span class="keyword">in
                    self</span>.<span class="property">contentState</span> = .<span class="call">error</span>(error: .<span class="call">loading</span>(reason: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">errorGenericTitle</span>()))
                }
            )
            .<span class="call">disposed</span>(by: disposeBag)
    }
</code></pre><h2>Feed Presenter</h2><p><a href="https://github.com/staskus/aerogami-ios/blob/master/TravelFeatureKit/Features/Feed/FeedPresenter.swift">Feed Presenter</a> essentially takes <code>Feed.Data</code> and returns <code>Feed.ViewModel</code>.</p><pre><code>     <span class="keyword">func</span> makeContentViewModel(content: <span class="type">Feed</span>.<span class="type">Data</span>) <span class="keyword">throws</span> -&gt; <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span> {
        <span class="keyword">return</span> <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>(
            rows: <span class="call">makeFeedCardRows</span>(content),
            availableRegions: <span class="call">makeAvailableRegions</span>(content),
            selectedRegion: <span class="call">makeSelectedRegion</span>(content)
        )
    }
</code></pre><p>We can see that <em>struct</em> such as <code>FeedCardViewModel</code> is fairly complicated and comprehensively describes for a table view row what needs to be displayed. It ensures that there is absolutely no business logic, mapping or formatting done in a view as it's simply sets these properties to appropriate variables.</p><pre><code>     <span class="keyword">private func</span> makeFeedCardRows(<span class="keyword">_</span> content: <span class="type">Feed</span>.<span class="type">Data</span>) -&gt; [<span class="type">FeedCardViewModel</span>] {
        <span class="keyword">return</span> <span class="call">getSortedTrips</span>(content).<span class="call">map</span> { trip <span class="keyword">in</span>
            currencyFormatter.<span class="property">currencyCode</span> = trip.<span class="property">currency</span>
            <span class="keyword">return</span> <span class="type">FeedCardViewModel</span>(
                direction: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">feedBothWaysTitle</span>(),
                trip: <span class="call">makeTripString</span>(trip),
                price: <span class="call">formatCurrency</span>(trip),
                dateRange: <span class="call">dateRange</span>(trip),
                routeName: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">feedBookTitle</span>(),
                imageUrl: <span class="call">makeTripImageURL</span>(trip, content: content),
                route: <span class="type">Feed</span>.<span class="type">Route</span>.<span class="call">book</span>(trip),
                isExpired: trip.<span class="property">expiresAt</span> &lt;= <span class="type">Date</span>()
            )
        }
    }
</code></pre><h2>Feed View Controller</h2><p>View Controller in this architecture is a very lean and clean class. It does what view <em>should</em> do: present data, handle user actions and delegate these actions to 'interactor'.</p><p><em>display()</em> lets <code>FeedViewController</code> know that the state and <code>Feed.ViewModel</code> was updated. Different views then can use parts of view model to configure themselves.</p><pre><code>     <span class="keyword">func</span> display() {
        <span class="keyword">guard let</span> viewModel = viewModel?.<span class="property">state</span>.<span class="property">viewModel</span> <span class="keyword">else</span> { <span class="keyword">return</span> }

        tableView.<span class="call">reloadData</span>()
        headerView.<span class="call">configure</span>(with: viewModel.<span class="property">selectedRegion</span>)
    }
</code></pre><p><code>Feed.Action</code> is sent to <code>Feed.Interactor</code> when anything meaningful happens in <code>FeedViewController.</code> For example, loading data when view appears.</p><pre><code>     <span class="keyword">override func</span> viewWillAppear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
        <span class="keyword">super</span>.<span class="call">viewWillAppear</span>(animated)

        interactor.<span class="call">subscribe</span>()
        interactor.<span class="call">dispatch</span>(<span class="type">Feed</span>.<span class="type">Action</span>.<span class="property">load</span>)
    }
</code></pre><p><code>Feed.Route</code> is sent to <code>Feed.Router</code> when <code>FeedViewController</code> wants to transition to other view controller.</p><pre><code>     <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, didSelectRowAt indexPath: <span class="type">IndexPath</span>) {
        <span class="keyword">guard let</span> cellViewModel = viewModel?.<span class="property">state</span>.<span class="property">viewModel</span>?.<span class="property">rows</span>[indexPath.<span class="property">row</span>] <span class="keyword">else</span> { <span class="keyword">return</span> }

        router.<span class="call">route</span>(to: cellViewModel.<span class="property">route</span>)
    }
</code></pre><h2>Feed Router</h2><p><code>FeedRouter</code> handles <em>route</em> actions and opens other view controllers. It uses <code>BookTripConfigurator</code> for building <code>BookTripViewController</code>.</p><pre><code><span class="keyword">class</span> FeedRouter {

    <span class="keyword">private let</span> bookTripConfigurator: <span class="type">BookTripConfigurator</span>

    <span class="keyword">weak var</span> viewController: <span class="type">FeedViewController</span>?

    <span class="keyword">init</span>(bookTripConfigurator: <span class="type">BookTripConfigurator</span>) {
        <span class="keyword">self</span>.<span class="property">bookTripConfigurator</span> = bookTripConfigurator
    }

    <span class="keyword">func</span> route(to route: <span class="type">Feed</span>.<span class="type">Route</span>) {
        <span class="keyword">switch</span> route {
        <span class="keyword">case</span> .<span class="dotAccess">book</span>(<span class="keyword">let</span> trip):
            <span class="keyword">let</span> bookTripViewController = bookTripConfigurator.<span class="call">createViewController</span>(trip: trip)
            bookTripViewController.<span class="property">modalPresentationStyle</span> = .<span class="dotAccess">overCurrentContext</span>
            bookTripViewController.<span class="property">modalTransitionStyle</span> = .<span class="dotAccess">coverVertical</span>
            viewController?.<span class="property">tabBarController</span>?.<span class="call">present</span>(bookTripViewController, animated: <span class="keyword">true</span>, completion: <span class="keyword">nil</span>)
        }
    }
}
</code></pre><h2>Usage</h2><p>For understanding this flow easier we can imagine a hypothetical scenario of <code>Feed</code> feature.</p><ol><li>AppDelegate uses <code>FeedConfigurator</code> and calls <code>createViewController()</code> to create <code>FeedViewController</code></li><li><code>FeedViewController</code> on <code>viewWillAppear</code> calls <code>interactor.dispatch(Feed.Action.load)</code> to trigger <code>load</code> action</li><li><code>FeedInteractor</code> handles <code>load</code> action and uses <code>TripRepository</code> to load an array of <code>Trips</code> from the backend. It passes an array of <code>Trips</code> to <code>FeedPresenter</code>.</li><li><code>FeedPresenter</code> takes an array of <code>Trips</code> and maps it to <code>FeedViewModel</code> by formatting and localizing text, loading images and splitting it into fields that view needs to know about.</li><li><code>FeedViewController</code>'s method <code>display()</code> is triggered and table view is loaded with new data.</li></ol><p>Although this all may seem too much at first, it actually provides developers with huge clarity when building and maintaining the project. Moreover, all these different components have clear inputs and outputs than can be unit tested. With the growing complexity of the feature it becomes convenient to simply check <code>Action</code> to see all the different things that <code>ViewController</code> does or analyse <code>Presenter</code> to understand what kind of data is actually presented.</p><h2>Result</h2><p>In these series we've seen how to build iOS application by separating it into different frameworks, loading data from API and mapping it using <code>Codable</code>, sketching UIs following Apple's guidelines and develop it all on top of <em>Clean</em> architecture. All of these steps allow the app to be scalable, maintainable and testable.<br><br><img src="https://www.staskus.io/images/aerogami-tutorial/part5/app_demo.gif" alt="App Demo" width="300"/></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</guid><title>Building a real-world iOS app (Part 4): Design</title><description></description><link>https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</link><pubDate>Wed, 20 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>User experience (UX) and design is an integral part of any application. As a developer, I don't have much knowledge or "feeling" towards good looking designs. Moreover, truly great user experience requires many iterations of development and feedback. In this part we'll see how we can take example from Apple's mobile apps and design guidelines to create a familiar looking application.</p><h1>Colors</h1><p>We'll begin to design by choosing the color palette of our application. One of the best ways to ensure familiarity and simplicity of the app is to have consistent colors throughout the application. I found it a great advice to limit yourself to 1 or 2 colors.</p><p>There are a few tools online to generate color palettes so the colors would fit together nicely.</p><p>Chosen colors should be put in a common place so it could be easily accessible.</p><pre><code><span class="keyword">struct</span> Theme {
    <span class="keyword">static let</span> primary = <span class="type">UIColor</span>(red: <span class="number">255</span>/<span class="number">255</span>, green: <span class="number">82</span>/<span class="number">255</span>, blue: <span class="number">82</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
    <span class="keyword">static let</span> primaryLight = <span class="type">Theme</span>.<span class="property">primary</span>.<span class="call">withAlphaComponent</span>(<span class="number">0.9</span>)
    <span class="keyword">static let</span> backgroundColor = <span class="type">UIColor</span>(red: <span class="number">239</span>/<span class="number">255</span>, green: <span class="number">239</span>/<span class="number">255</span>, blue: <span class="number">244</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
}
</code></pre><h1>UI</h1><p>Apple provides great resources for getting started. <a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a> is a great starting point for understanding the thinking behind Apple's choices as well as their preferences. Users have certain expectations and habits when using any application and it's important not to distract them with an unexpected behavior.</p><p>We'll take the inspiration from already existing <em>AppStore</em> app. The main screen of this app has a feed that we want to display in our travel application as well.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_example.png" alt="App Scren Example" width="300"/><p>Apple also provides us with <a href="https://developer.apple.com/design/resources/">design resources</a> that contain <a href="https://www.sketch.com">Sketch</a> files with designs of already existing applications. When learning to sketch or design something, I found it really beneficial to have these in front of me.</p><p>After tweaking these screens and applying our color palette we can create the first version of our design.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_real.png" alt="Feed Screen" width="300"/><p>It displays the essential information such as <em>origin</em>, <em>destination</em>, <em>dates</em> and <em>price</em>. We can also show images which provide visual information about the destination.</p><h1>App Icon</h1><p>Application icon is also a huge part of first impression of any application. We can use same given <a href="https://developer.apple.com/design/resources/">design resources</a> that include examples of created app icons.</p><p>We can use a little bit of imagination and tweak given icons on Sketch to give it a look of a travel or flight application.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.gif" alt="Making of App Icon" width="300"/><p>The resulting icon looks like this.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.png" alt="App Icon" width="300"/><p>We can use <a href="https://makeappicon.com">makeappicon.com</a> to generate all the necessary sizes of the icon so it could be used for different screen sizes as well as on AppStore.</p><h1>What's next?</h1><p>We saw how it's possible to create a clean design of an application without having much knowledge or spending too much time. Especially for small side projects, it's important to concentrate on main functionality and simply use best practices and examples when creating UIs.</p><p>In the next part of the series we'll shift our attention back to the development of our application. We'll see the approach for creating new screens and keeping the view and its logic cleanly separated.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</guid><title>Building a real-world iOS app (Part 3): Fetching and parsing data from API</title><description></description><link>https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</link><pubDate>Mon, 18 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In the <a href="2019-03-17-aerogami_series_part_2">previous part</a> we discovered a way to separate our application into frameworks and setup the architecture of our app to support dependency injection. In this part of the series we'll be fetching and parsing data from the backend using Alamofire and Codable.</p><h1>API Client</h1><p>Although in the scope of this tutorial we'll be using mocked data, the application will be completely ready to support calls to REST APIs.</p><h3>Protocol</h3><p>We define our <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/APIClient.swift">APIClient</a> protocol that serves as a lean interface between data fetching classes and actual implementation.</p><pre><code><span class="keyword">import</span> RxSwift

<span class="keyword">public protocol</span> APIClient {
    <span class="keyword">func</span> get(path: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;
}
</code></pre><p>It returns <code>Observable&lt;Any&gt;</code> which is a part of <code>RxSwift</code>. We won't be going through the basics of <code>RxSwift</code>, so it's beneficial to take a look <a href="https://github.com/ReactiveX/RxSwift">official documentation</a> before continuing.</p><h3>Implementation</h3><p>The actual implementation is in <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">BaseAPIClient</a>, which uses <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> for making HTTP requests. The only method <code>get(path: String)</code> makes <code>GET</code> request by concating given path to a base URL.</p><pre><code><span class="keyword">import</span> RxAlamofire
<span class="keyword">import</span> RxSwift

<span class="keyword">public class</span> BaseAPIClient: <span class="type">APIClient</span> {
    <span class="keyword">private let</span> baseUrl: <span class="type">String</span>

    <span class="keyword">public init</span>(baseUrl: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">baseUrl</span> = baseUrl
    }

    <span class="keyword">public func</span> get(path: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt; {
        <span class="keyword">return</span> <span class="type">RxAlamofire</span>
            .<span class="call">requestJSON</span>(.<span class="dotAccess">get</span>, <span class="string">"</span>\(baseUrl)<span class="string">/</span>\(path)<span class="string">"</span>)
            .<span class="call">map</span> { $1 }
    }
}
</code></pre><h3>Mock</h3><p>If you clone the <a href="https://github.com/staskus/aerogami-ios">repository</a>, it will use <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">MockAPIClient</a> which takes data from files. Because it uses the same public interface, <code>MockAPIClient</code> and <code>BaseAPIClient</code> can be interchanged depending on needs. See <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelApplication/Application/Assembly/ApplicationAssembly.swift">ApplicationAssembly</a> which assigns dependencies for <code>APIClient</code> interface. Depending on different configuration, it can assign any of these two. This little example perfectly illustrates the power of <code>dependency injection</code> and usage of <code>protocols</code>.</p><h1>Data</h1><p>The main entity in this project is a <code>Trip</code>. It describes the origin and destination of the flight as well as price and dates.</p><pre><code>{
   <span class="string">"currency"</span>:<span class="string">"EUR"</span>,
   <span class="string">"created_at"</span>:<span class="number">1547991979887</span>,
   <span class="string">"airlines"</span>:<span class="string">"FR"</span>,
   <span class="string">"departure_at"</span>:<span class="number">1552848000000</span>,
   <span class="string">"destination"</span>:{
      <span class="string">"city"</span>:<span class="string">"Malaga"</span>,
      <span class="string">"country_code"</span>:<span class="string">"ES"</span>,
      <span class="string">"airport_code"</span>:<span class="string">"AGP"</span>
   },
   <span class="string">"flight_number"</span>:<span class="number">4048</span>,
   <span class="string">"departure"</span>:{
      <span class="string">"city"</span>:<span class="string">"Copenhagen"</span>,
      <span class="string">"country_code"</span>:<span class="string">"DK"</span>,
      <span class="string">"airport_code"</span>:<span class="string">"CPH"</span>
   },
   <span class="string">"return_at"</span>:<span class="number">1553153100000</span>,
   <span class="string">"price"</span>:<span class="number">72</span>,
   <span class="string">"id"</span>:<span class="string">"c4449ff0-1cb9-11e9-b9f8-b3ba95b35000"</span>,
   <span class="string">"expires_at"</span>:<span class="number">1739200281000</span>
}
</code></pre><p><a href="https://github.com/staskus/aerogami-ios/blob/master/TravelApplication/Application/Mocking/TripMock.json">See full Trips JSON file</a></p><p>We'll define our entities inside <code>TravelKit</code> framework. They should be made public, so they could be reached inside other frameworks. We'll use excellent <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> type that starting from Swift 4 provides a powerful and clean way to encode and decode data.</p><p>Take a look at <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelKit/Repositories/Trip/Trip.swift">Trip</a> class. We don't need to define keys of each values if they match. It's possible to define what naming strategies are used during decoding or encoding process. For example, <code>.convertFromSnakeCase</code> strategy, as its name suggests, converts keys from snake case and assigns values automatically if they match.</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">public struct</span> Trip: <span class="type">Codable</span>, <span class="type">Equatable</span> {
    <span class="keyword">public var</span> id: <span class="type">String</span> = <span class="string">""</span>
    <span class="keyword">public var</span> currency: <span class="type">String</span> = <span class="string">""</span>
    <span class="keyword">public var</span> price = <span class="number">0</span>

    <span class="keyword">public var</span> airlines = <span class="string">""</span>
    <span class="keyword">public var</span> flightNumber = <span class="number">0</span>

    <span class="keyword">public var</span> destination: <span class="type">TripLocation</span>!
    <span class="keyword">public var</span> departure: <span class="type">TripLocation</span>!

    <span class="keyword">public var</span> createdAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> departureAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> returnAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> expiresAt = <span class="type">Date</span>()

    <span class="keyword">public init</span>() {}
}

<span class="keyword">public struct</span> TripLocation: <span class="type">Codable</span>, <span class="type">Equatable</span> {
    <span class="keyword">public var</span> city: <span class="type">String</span>!
    <span class="keyword">public var</span> countryCode: <span class="type">String</span>!
    <span class="keyword">public var</span> airportCode: <span class="type">String</span>!

    <span class="keyword">public init</span>() {}
}
</code></pre><p>After receiving <code>JSON</code> data we can define <code>decoder</code> and automatically parse values.</p><pre><code>     <span class="keyword">public static var</span> decoder: <span class="type">JSONDecoder</span> = {
        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()
        decoder.<span class="property">keyDecodingStrategy</span> = .<span class="dotAccess">convertFromSnakeCase</span>
        decoder.<span class="property">dateDecodingStrategy</span> = .<span class="dotAccess">millisecondsSince1970</span>
        <span class="keyword">return</span> decoder
    }()

    <span class="keyword">let</span> trips = <span class="keyword">try</span>? decoder.<span class="call">decode</span>([<span class="type">Trip</span>].<span class="keyword">self</span>, from: data)
</code></pre><p>With this simple and straightforward Codable API our data is cleanly parsed into statically typed object or array of objects after <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelDataKit/Repositories/Trip/Remote/APITripDataStore.swift">fetching from API</a>.</p><h1>Repositories</h1><p>Classes that are used to fetch data will be called repositories. In <code>TravelKit</code> we'll only define the protocols of these repositories. Our UI framework <code>TravelFeatureKit</code> will only know about <code>TravelKit</code> and protocols of repositories thus the implementations, defined in <code>TravelDataKit</code>, will be easily changeable.</p><p>Our <code>TripRepository</code> protocol defines the only way to fetch trips.</p><pre><code><span class="keyword">import</span> RxSwift

<span class="keyword">public protocol</span> TripRepository {
    <span class="keyword">func</span> getTrips(in region: <span class="type">String</span>?) -&gt; <span class="type">Observable</span>&lt;[<span class="type">Trip</span>]&gt;
}
</code></pre><p>Because our UI framework will only know about this protocol, we will be able to provide different types of implementations. <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/TripRepository.swift">TripRepository</a> implementation defined in <code>TravelDataKit</code> calls the <code>API</code> to fetch data and parses it using <code>Coadable</code>. However, <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/FavoriteTripRepository.swift">FavoriteTripRepository</a> which also implements <code>TripRepository</code> interface, uses <code>UserDefaults</code> to fetch locally liked <code>Trips</code>. It allows us to generate 2 completely different screens in our app. One showing the current feed of flights fetched from the API and another of liked and locally saved trips. Here <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelFeatureKit/Features/Favorites/FavoritesAssembly.swift">FavoritesAssembly</a> simply injects necessary dependencies needed for <em>favorites</em> to a <code>FavoriteFeed</code> feature.</p><h1>Design</h1><p>Before continuing creating the app, we'll see how we can quickly create simple application designs using Sketch or similar tools. In the next part of the series we'll overview the approach.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</guid><title>Building a real-world iOS app (Part 2): Separating application into frameworks</title><description></description><link>https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</link><pubDate>Sun, 17 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In this part of the series we'll overview how to properly setup the application.</p><h1>Creating Frameworks</h1><p>As we talked in the <a href="https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1">previous part</a>, we'll begin the creation of the project by creating 3 separate frameworks inside our XCode project (<code>TravelKit</code>, <code>TravelDataKit</code>, <code>TravelFeatureKit</code>). An article on <a href="https://www.raywenderlich.com/5109-creating-a-framework-for-ios">raywenderlich.com</a> has a thorough explanation of the whole process.</p><p>After creating frameworks, project navigator should look something like in the picture below.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part2/project_frameworks.png" alt="Frameworks in the Project Navigator" width="300"/><h1>Setting up CocoaPods</h1><p>We'll be using <a href="https://cocoapods.org">CocoaPods</a> for managing dependencies in our project. Although setting up CocoaPods is fairly straightforward, there can be some difficulties when having local frameworks involved. The configuration is defined in <code>Podfile</code> which is located in the root folder of the project.</p><p><code>Podfile</code> will be configured in a way that is clean and clear so it would not get messy when number of dependencies in the project grow. Essentially, we'll define the reusable pods at the top of the file and group different groups of pods that can be reused for different frameworks.</p><p>The part of <code>Podfile</code> that defines pods of <code>TravelKit</code>.</p><pre><code>platform :ios, '<span class="number">11.0</span>'
use_frameworks!
inhibit_all_warnings!

deployment_target = '<span class="number">11.0</span>'

workspace '<span class="type">TravelApplication</span>.<span class="property">xcworkspace</span>'

#Versions
$swinjectVersion =                    '~&gt; <span class="number">2.4</span>'
$swiftDateVersion =                   '~&gt; <span class="number">5.0</span>'
&lt;...&gt;

def shared_TravelKit_pods
    pod '<span class="type">RxSwift</span>',                    $rxSwiftVersion
    pod '<span class="type">SwiftDate</span>',                  $swiftDateVersion
end

target '<span class="type">TravelKit</span>' <span class="keyword">do</span>
    project '<span class="type">TravelKit</span>.<span class="property">xcodeproj</span>'
    platform :ios, deployment_target

    shared_TravelKit_pods

  target '<span class="type">TravelKitTests</span>' <span class="keyword">do</span>
    project '<span class="type">TravelKit</span>.<span class="property">xcodeproj</span>'
    inherit! :search_paths

    shared_testing_pods
  end
end
&lt;...&gt;
</code></pre><p>These different shared pods should be assembled and used of the actual application target.</p><pre><code>&lt;...&gt;
def shared_Apps_pods
  shared_TravelKit_pods
  &lt;...&gt;
end

target '<span class="type">TravelApplication</span>' <span class="keyword">do</span>
    project '<span class="type">TravelApplication</span>.<span class="property">xcodeproj</span>'
    platform :ios, deployment_target
    shared_Apps_pods
end
&lt;...&gt;
</code></pre><p>The full <a href="https://github.com/staskus/aerogami-ios/blob/master/Podfile">Podfile</a> can be found on <code>GitHub</code> as the rest of the project.</p><h1>Dependency Injection</h1><p>I prefer to think early about the way dependencies will be managed inside the application. Although dependency injection can be achieved without 3rd party libraries, for this project we'll use <a href="https://github.com/Swinject/Swinject">Swinject</a> that has easy to use interfaces for managing dependencies.</p><p>Our classes will use <code>initializer injection</code> thus all the dependencies will be given through the initializer. The classes will be initialized in assemblies. Assembly is a <code>Swinject</code> class which has access to a container of already injected dependencies and provides a way to register new dependencies.</p><p>For example, this is how the assembly of the <code>Feed</code> that displays the list of flights might looks like:</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Swinject
<span class="keyword">import</span> TravelKit

<span class="keyword">public class</span> FeedAssembly: <span class="type">Assembly</span> {

    <span class="keyword">public init</span>() {
    }

    <span class="keyword">public func</span> assemble(container: <span class="type">Container</span>) {
        container.<span class="call">register</span>(<span class="type">FeedConfigurator</span>.<span class="keyword">self</span>) { r <span class="keyword">in</span>
            <span class="type">FeedConfigurator</span>(
                regionRepository: r.<span class="call">resolve</span>(<span class="type">RegionRepository</span>.<span class="keyword">self</span>)!,
                tripRepository: r.<span class="call">resolve</span>(<span class="type">TripRepository</span>.<span class="keyword">self</span>)!,
                airportRepository: r.<span class="call">resolve</span>(<span class="type">AirportRepository</span>.<span class="keyword">self</span>)!,
                tripImageRepository: r.<span class="call">resolve</span>(<span class="type">TripImageRepository</span>.<span class="keyword">self</span>)!
                )
            }
            .<span class="call">initCompleted</span> { (resolver, feedConfigurator) <span class="keyword">in</span>
                feedConfigurator.<span class="property">bookTripConfigurator</span> = resolver.<span class="call">resolve</span>(<span class="type">BookTripConfigurator</span>.<span class="keyword">self</span>)!
            }
            .<span class="call">inObjectScope</span>(.<span class="dotAccess">container</span>)
    }
}
</code></pre><p>Here, we inject <code>FeedConfigurator</code> class. It is essentially a factory class for the whole <code>Feed</code> feature and its view. <code>Swinject</code> automatically passes the dependencies such as <code>RegionRepository</code> or <code>TripRepository</code>. We expect these dependencies to be injected in another assembly so we can resolve it here.</p><p>Our application will have <code>AssemblerFactory</code> that will contain all the different assemblies of the application and create them during initialization process.</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Swinject
<span class="keyword">import</span> TravelFeatureKit
<span class="keyword">import</span> TravelDataKit

<span class="keyword">class</span> AssemblerFactory {

    <span class="keyword">func</span> create() -&gt; <span class="type">Assembler</span> {
        <span class="keyword">let</span> assemblies: [<span class="type">Assembly</span>] = [
            <span class="type">ApplicationAssembly</span>(),
            <span class="type">RegionRepositoryAssembly</span>(),
            <span class="type">TripRepositoryAssembly</span>(),
            <span class="type">AirportRepositoryAssembly</span>(),

            <span class="type">MainAssembly</span>(),
            <span class="type">FavoritesAssembly</span>(),
            <span class="type">FeedAssembly</span>(),
            <span class="type">BookTripAssembly</span>(),
            <span class="type">BookURLRepositoryAssembly</span>(affiliateId: <span class="type">Constants</span>.<span class="property">affiliateId</span>)
        ]

        <span class="keyword">let</span> assembler = <span class="type">Assembler</span>(assemblies)

        <span class="keyword">return</span> assembler
    }
}
</code></pre><p>We use this assembly to create the first <code>ViewController</code> of the application and set it as <code>rootViewController</code>. See <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelApplication/Application/ApplicationLoader.swift">ApplicationLoader</a>.</p><pre><code>   <span class="keyword">self</span>.<span class="property">assembler</span> = <span class="type">AssemblerFactory</span>().<span class="call">create</span>()
  <span class="keyword">let</span> rootConfigurator = assembler.<span class="property">resolver</span>.<span class="call">resolve</span>(<span class="type">MainConfigurator</span>.<span class="keyword">self</span>)!
  <span class="keyword">let</span> rootViewController = rootConfigurator.<span class="call">createViewController</span>()
  window?.<span class="property">rootViewController</span> = rootViewController
  window?.<span class="call">makeKeyAndVisible</span>()
</code></pre><p>In the following parts of the series we'll be creating classes for fetching and presenting data that will use assemblies for injecting dependencies. We'll see more closely how having proper dependency injection allows code to be more reusable, safe and testable.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</guid><title>Building a real-world iOS app (Part 1): Introduction</title><description></description><link>https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</link><pubDate>Mon, 11 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When learning any new technology I find it beneficial to follow a real world example. In this tutorial series we'll be creating and releasing an iOS application. The application will be created by showing a real thinking process, going through essential steps and providing the motivation behind them. Although every single line of code won't be covered, all of it will be always available on <a href="https://github.com/staskus/aerogami-ios">GitHub</a>.</p><h1>Prerequisites</h1><p>Prior knowledge of iOS development and Swift syntax is needed.</p><h1>Introduction</h1><h2>Our Project</h2><p>We'll be creating a flight discovery application. The users of our application should be able to:</p><ol><li>See the <em>feed</em> of <em>flights</em></li><li>See the <em>date</em>, <em>price</em>, <em>origin</em> and <em>destination</em> of each <em>flight</em></li><li>Book the <em>flight</em>.</li></ol><p>In the scope of this project we won't be concerned about the source of information. Our application will use mocked flight information data. However, the structure of the application will support an easy integration with any Rest API.</p><h2>Our Approach</h2><p>Throughout the series we'll cover these topics one-by-one:</p><ol><li>Data Fetching and Parsing</li><li>Testing</li><li>Code Separation into Frameworks</li><li>Design using Sketch</li><li>Clean Swift Architecture</li><li>Building the UI and Displaying the Data</li><li>Release Process</li></ol><h2>The Final Product</h2><p>Here is the sneak peek of how the final product will look like. The full codebase can be found on <a href="https://github.com/staskus/aerogami-ios">GitHub</a>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/screenshot.png" alt="Application Screenshot" width="200"/><h1>High Level View</h1><p>Before we start, it's beneficial to understand how we're going to approach the creation of this application.</p><h2>Separation of Concerns</h2><p>Essentially our application should be able to perform 3 main tasks:</p><ol><li>Fetch data</li><li>Parse data</li><li>Display data</li></ol><p>We'll separate these different concerns into frameworks for our code to be decoupled and flexible. The primitive diagram of the architecture is displayed in the picture bellow. We'll define data models and protocols in <code>TravelKit</code>. This framework will contain data fetching protocols, which will be implemented in <code>TravelDataKit</code>. DataKit, as its name suggests, will be used for fetching, persisting and providing data. User interface will only know about data models and protocols and won't be concerned about the implementation. We'll call this framework <code>TravelFeatureKit</code>. The entry point of our application will initialize the dependencies required for all the frameworks and present the root view described in <code>TravelFeatureKit</code>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/architecture.png" alt="Application Architecture" width="300"/><p>In the next part of the series we'll continue by explaining how to create frameworks and setup the base of the application.</p>]]></content:encoded></item></channel></rss>