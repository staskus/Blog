<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Povilas Staškus</title><description>iOS Developer</description><link>https://www.staskus.io</link><language>en</language><lastBuildDate>Wed, 11 May 2022 10:58:41 +0300</lastBuildDate><pubDate>Wed, 11 May 2022 10:58:41 +0300</pubDate><ttl>250</ttl><atom:link href="https://www.staskus.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-06-23-app-clip</guid><title>App Clips: A first glance at the new way to access an iOS app</title><description></description><link>https://www.staskus.io/posts/2020-06-23-app-clip</link><pubDate>Tue, 23 Jun 2020 18:00:00 +0300</pubDate><content:encoded><![CDATA[<p>During <a href="https://developer.apple.com/wwdc20/">WWDC20</a> Apple is introducing new <a href="https://developer.apple.com/app-clips/">App Clips</a> feature. As it's described in the landing page:</p><blockquote><p>An app clip is a small part of your app that’s discoverable at the moment it’s needed.</p></blockquote><p>Apple already suggested some possible use cases such as ordering from a take-out restaurant or renting a scooter. And App Clips will be discovered and invoked by using new App Clip Codes, NFC Tags, QR Codes, Messages, or as place cards in Maps.</p><p>It looks like a great move forward in reducing friction and getting an app into users' hands as fast as possible.</p><p>We'll take a look at the initial steps of how these App Clips could be implemented and introduced in the project.</p><h1>Prerequisites</h1><p>Xcode 12 or higher.</p><h1>Getting Started</h1><p>We start by creating a new project and selecting the creation of a new target.</p><img src="https://www.staskus.io/images/app-clip/new_target.png" alt="App Clip New Target" width="600"/><p>We select a new App Clip target and add it to our application.</p><img src="https://www.staskus.io/images/app-clip/new_target_app_clip.png" alt="App Clip New Target" width="600"/><h1>Add Associated Domain</h1><p>We need to provide an associated domain for both App and App Clip targets. If App is not installed the link will open App Clip. Otherwise full App will be opened instead.</p><p>We do it by selecting <em>Target -&gt; Signing &amp; Capabilities</em>, clicking + sign, and choosing Associated Domains.</p><img src="https://www.staskus.io/images/app-clip/associated_domains.png" alt="Creating Associated Domain" width="600"/><p>Next, we enter our associated domain value which must follow pattern of <em>appclips:domain</em>. In this instance, we can enter <em>appclips:example.com</em>.</p><img src="https://www.staskus.io/images/app-clip/associated_domains_example.png" alt="Associated Domains Example" width="600"/><h1>Running App Clip target</h1><p>App Clip target can be run and debugged just like an App target.</p><p>We can open <code>ContentView.swift</code> inside an App Clip target, make changes, and run.</p><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        Text("Hello, App Clip!").padding()
    }
}
</code></pre><img src="https://www.staskus.io/images/app-clip/hello_app_clip.png" alt="Hello App Clip Simulator Screen" width="300"/><h1>Configuring App Clip</h1><p>App Clip is invoked via URL which can contain context-related information and be used in the configuration.</p><p>Let's say we want to provide a user with a more personalized greeting message after App Clip was invoked. We can pass binding <code>name</code> variable to <code>ContentView</code>.</p><pre><code class="language-swift">struct ContentView: View {
    @Binding var name: String

    var body: some View {
        Text("Hello, \(name)").padding()
    }
}
</code></pre><p>This example uses a new App lifecycle in SwiftUI which enables entire apps to be written completely in SwiftUI.</p><p>Information about invocation is passed through lifecycle events. We can use <code>onContinueUserActivity</code> to be notified about App Clip being launched with parameters.</p><p>More information about using legacy lifecycles can be found on <a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Access the Invocation URL section</a>.</p><p>After that, we take the incoming URL and its first path component. Now first path parameter passed through URL will be set as a name.</p><pre><code class="language-swift">@main
struct AppClipSneakPeekClipApp: App {
    @State var name = ""

    var body: some Scene {
        WindowGroup {
            ContentView(name: $name).onContinueUserActivity(NSUserActivityTypeBrowsingWeb, perform: respondTo)
        }
    }

    func respondTo(_ activity: NSUserActivity?) {
        guard let name = firstParameterValue(from: activity) else { return }

        self.name = name
    }

    private func firstParameterValue(from activity: NSUserActivity?) -&gt; String? {
        // Parsing components from URL
        guard let activity = activity else { return nil }
        guard let incomingURL = activity.webpageURL else { return nil }
        guard let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true) else { return nil }

        // Taking first parameter: example.com/?parameter=Lisa
        return components.queryItems?.first?.value
    }
}
</code></pre><h1>Testing</h1><p>Launching AppClip target now does not show any name value. It makes sense as we didn't pass any URL with parameters to our app.</p><p>We can automatically test it by providing <em>Environment Variable</em> for App Clip scheme. It can be done by selecting <code>App Clip scheme -&gt; Edit Scheme -&gt; Run</code> and set the value of <em>_XCAppClipURL</em> of test URL value. We set it to <em>https://example.com/?parameter=Lisa</em> to have a first parameter value.</p><img src="https://www.staskus.io/images/app-clip/testing.png" alt="Adding Environment Variable" width="600"/><p>If we launch the application now, the value is received through lifecycle event and updated inside a view.</p><img src="https://www.staskus.io/images/app-clip/testing_success.png" alt="iOS Simulator with result" width="300"/><h2>What about App Clip Card?</h2><p>App Clip Card itself that is shown with a suggestion to open an App Card is not developed through Xcode. The information displayed in this card can be configured through <a href="https://appstoreconnect.apple.com/login">App Store Connect</a>. Developers will be able to change a header image, subtitle, and title on the action button.</p><h1>Where do we go from here?</h1><p>App Clip looks like a promising addition to the ecosystem and it will be interesting to see how it will be used and adopted by both developers and users.</p><p>The example project can be found on <a href="https://github.com/staskus/AppClipSneakPeekApp">GitHub</a>.</p><p>Apple provides a lot of helpful resources for going more in-depth into App Clips.</p><ul><li><a href="https://developer.apple.com/documentation/app_clips">Developing a Great App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/creating_an_app_clip">Creating an App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Responding to Invocation</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Configuring Your App Clip’s Launch Experience</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Testing Your App Clip’s Launch Experience</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-01-26-publish</guid><title>Migrating from Jekyll to Publish: A site generator for Swift developers</title><description></description><link>https://www.staskus.io/posts/2020-01-26-publish</link><pubDate>Sun, 26 Jan 2020 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/JohnSundell/Publish">Publish</a> is a static site generator built for Swift developers. We'll be migrating a static blog generation from <a href="https://jekyllrb.com">Jekyll</a> to Publish. The previous version of a blog was generated using Jekyll and a provided theme without putting too much effort in understanding the whole creation process. This time I decided to dig deeper into understanding Publish and remembering long forgotten <em>HTML</em> and <em>CSS</em> skills.</p><p>We'll be trying to create a similar style blog that was created using Jekyll. It should remain adaptable for bigger or smaller screen sizes:</p><h4>Previous desktop version</h4><img src="https://www.staskus.io/images/publish/previous_1.png" alt="Previous desktop version of a blog" width="500"/><h4>Previous mobile version</h4><img src="https://www.staskus.io/images/publish/previous_2.png" alt="Previous mobile version of a blog" width="300"/><h1>Getting Started</h1><p>After running the steps described in a <a href="https://github.com/JohnSundell/Publish">Publish repository</a> we end up with a sample project that showcases the main parts and features of Publish.</p><p>In the folder structure we can see <code>posts</code> folder that contains an example post. I copy-pasted my blog posts <code>.md</code> files from old Jekyll blog to see if it works. We only need to change couple fields to make it work. The only difference is a metadata format on top of <code>.md</code> file. By removing quotes from strings, brackets from arrays and renaming categories to tags we can get Jekyll articles immediately generated into a new blog.</p><img src="https://www.staskus.io/images/publish/blog_1.png" alt="Previous desktop version of a blog" width="500"/><h1>Website</h1><p>If we open up <code>main.swift</code> file we see:</p><pre><code class="language-swift">try Blog().publish(withTheme: .foundation)
</code></pre><p>In Publish a website is a simple Swift struct that should contain mandatory fields required by a <code>Website</code> protocol as well as any additional fields that might be needed.</p><p>As this blog contains personal information as well as links to social media accounts, I included them in a <code>Blog</code> structure.</p><pre><code class="language-swift">struct Blog: Website {
    enum SectionID: String, WebsiteSectionID {
        case posts
        case about
    }

    struct ItemMetadata: WebsiteItemMetadata {
    	// Additional field in post .md metadata
        var excerpt: String
    }

    var url = URL(string: "https://www.staskus.io")!
    var title = "staskus.io"
    var name = "Povilas Staškus"
    var description = "iOS Developer"
    var language: Language { .english }
    var imagePath: Path? { nil }
    var socialMediaLinks: [SocialMediaLink] { [.location, .email, .linkedIn, .github, .twitter] }
}
</code></pre><h1>Theme</h1><p>Basic <code>foundation</code> theme is used after generating a website for the first time. However, it's only there to give an example of how custom site theme should be created.</p><p>A <code>Theme</code> is built by conforming to <code>HTMLFactory</code> protocol.</p><p>Not all the pages are needed to be created for your site to be fully functioning. For a blog we must have: 1) an index page, that shows header, sidebar and list of posts. 2) item page, that will show full post.</p><pre><code class="language-swift">class BlogHTMLFactory: HTMLFactory {

    func makeIndexHTML(for index: Index,
                       context: PublishingContext&lt;Blog&gt;) throws -&gt; HTML {
    	// Returning HTML of an Index Page
    }

    func makeSectionHTML(for section: Section&lt;Site&gt;,
                         context: PublishingContext&lt;Blog&gt;) throws -&gt; HTML {
    	// Returning HTML of a Section Index Page that displays section items
    }

    func makeItemHTML(for item: Item&lt;Site&gt;,
                      context: PublishingContext&lt;Blog&gt;) throws -&gt; HTML {
    	// Returning HTML of a Post Page
    }

    func makePageHTML(for page: Page,
                      context: PublishingContext&lt;Blog&gt;) throws -&gt; HTML {
    	// Returning HTML of a Section Page 
    }

    func makeTagListHTML(for page: TagListPage,
                         context: PublishingContext&lt;Blog&gt;) throws -&gt; HTML? {
    	// Returning HTML of a Page with list of available tags
    }

    func makeTagDetailsHTML(for page: TagDetailsPage,
                            context: PublishingContext&lt;Blog&gt;) throws -&gt; HTML? {
    	// Returning HTML of a Page for a specific tag
    }
}
</code></pre><p>Although we can write <code>HTML</code> code using Swift, the styling of the site is done using <code>CSS.</code> For the creation of this blog, I decided to use <a href="https://purecss.io">Pure.css</a>. The desired blog theme is quite minimalist and the features that <a href="https://purecss.io">Pure.css</a> provides seem more than enough to achieve what we want. Even after many years without any <code>CSS</code> and <code>HTML</code> experience it was possible to make pretty decent layout. For the rest of this article, we won't be focusing on that. The code can be found on <a href="https://github.com/staskus/Blog">GitHub</a> for those who are interested.</p><h2>Index Page</h2><p><code>makeIndexHTML</code> builds HTML of an index page. The structure is the same as writing plain HTML tags. We set <em>language</em>, <em>head</em> and then structure layout inside <em>body</em>.</p><p>Body uses <code>.grid</code> node that creates Pure.css grid in which we can structure our layout. We have <code>.header</code>, <code>.sidebar</code>, <code>.posts</code> and <code>.footer</code> that are put one after the other.</p><pre><code class="language-swift">class BlogHTMLFactory: HTMLFactory {

    func makeIndexHTML(for index: Index,
                       context: PublishingContext&lt;Blog&gt;) throws -&gt; HTML {
    	HTML(
            .lang(context.site.language),
            .head(for: context.site),
            .body(
                .grid(
                    .header(for: context.site),
                    .sidebar(for: context.site),
                    .posts(
                        for: context.allItems(
                            sortedBy: \.date,
                            order: .descending
                        ),
                        on: context.site,
                        title: "Recent posts"
                    ),
                    .footer(for: context.site)
                )
            )
        )
    }
}
</code></pre><p>Any node can be written as a <code>static</code> func extension of a <code>Node</code>. <code>Context == HTML.BodyContext</code> indicate that this node can be only used inside <em>body</em>. It's a nice and clean way to declare new nodes, as they can be then used using dot syntax.</p><pre><code class="language-swift">extension Node where Context == HTML.BodyContext {
    static func grid(_ nodes: Node...) -&gt; Node {
        .div(
            .id("layout"),
            .class("pure-g"),
            .group(nodes)
        )
    }
}
</code></pre><h2>Post</h2><p>A post can be declared the same way as any other node. On the top, we show the title of the post. Below, we show date. We can use any powerful features that Swift infrastructure provides us. In this instance, we use <code>DateFormatter</code> to format a date. In a similar way any more complex or sophisticated logic could be used inside this code.</p><pre><code class="language-swift">extension Node where Context == HTML.BodyContext {
    static func post(for item: Item&lt;Blog&gt;, on site: Blog) -&gt; Node {
        return .pageContent(
            .h2(
                .class("post-title"),
                .a(
                    .href(item.path),
                    .text(item.title)
                )
            ),
            .p(
                .class("post-meta"),
                .text(DateFormatter.blog.string(from: item.date))
            ),
            .tagList(for: item, on: site),
            .div(
                .class("post-description"),
                .div(
                    .contentBody(item.body)
                )
            )
        )
    }
}
</code></pre><h2>Finishing the theme</h2><p>We can make our theme accessible by creating <code>Theme</code> object and passing our <code>BlogHTMLFactory</code>. Declaring it as a <em>static var</em> inside an extension allows reaching it more conveniently.</p><pre><code class="language-swift">extension Theme where Site == Blog {
    static var blog: Self {
        Theme(htmlFactory: BlogHTMLFactory())
    }
}
</code></pre><h1>Generating the site</h1><p>We've seen how by creating nodes we can step by step create pages for our blog. However, I would argue that the biggest power of Publish comes from <code>plugins</code> and additional building steps that we can create or use.</p><p><a href="https://github.com/JohnSundell/Splash">Splash</a> is a Swift syntax highlighter for blogs that has a plugin built for Publish. During the blog generation process, this plugin uses markdown parser to identify code inside <code>.md</code> files and apply syntax highlighting.</p><p>We can use or build any steps that might do additional checks, append necessary information or simply tweak a site in any way needed.</p><pre><code class="language-swift">import SplashPublishPlugin

try Blog().publish(
    withTheme: .blog,
    additionalSteps: [.deploy(using: .gitHub("staskus/nitesuit.github.io"))],
    plugins: [.splash(withClassPrefix: "")]
)
</code></pre><h1>Result</h1><p>Publish worked seamlessly during development process. It provided all the convenience of Swift strong type system and helped stay focused while trying to figure unfamiliar web development workflows. Although Publish still misses many features that established static site generators have, it serves perfectly for its intended audience - Swift developers. Now that all the parts of the site are well understood, Publish together with Swift gives a lot of power for future improvements.</p><p>The code of the blog can be found on <a href="https://github.com/staskus/Blog">GitHub</a>.</p><h4>New desktop version</h4><img src="https://www.staskus.io/images/publish/blog_new_2.png" alt="New desktop version of a blog" width="500"/><h4>New mobile version</h4><img src="https://www.staskus.io/images/publish/blog_new_1.png" alt="New mobile version of a blog" width="300"/>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</guid><title>Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views</title><description></description><link>https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</link><pubDate>Sun, 24 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When starting to develop any application it's beneficial to think early about the way code can be testable and whether it would be scalable or maintainable. Many iOS applications have suffered from what is called <em>Massive View Controller</em> problem. By putting all the code that fetches, maps, presents and styles into one ViewController it very quickly overgrows in size and complexity. A lot of solutions where introduced to tackle this problem such as MVVM, MVVM + ReactiveCocoa or VIPER. In this application we'll be using <a href="https://clean-swift.com">Clean Swift</a> approach for breaking up massive view controllers into testable and maintainable parts.</p><h1>Data Structures</h1><h2>Data</h2><p><code>Struct</code> containing <em>raw data</em>.</p><pre><code class="language-swift">    struct Data: Equatable {
        let regions: [Region]
        let trips: [Trip]
    }
</code></pre><h2>View Model</h2><p><code>Struct</code> containing <em>State</em> (loading, error, empty, loaded) and mapped data that is used by <em>View Controllers</em> for configuring views.</p><pre><code class="language-swift">    struct ViewModel: FeatureViewModel {
        let state: ViewState&lt;Feed.ViewModel.Content&gt;
        let title: String

        struct Content: FeatureContentViewModel, Equatable {
            var rows: [FeedCardViewModel]
            let availableRegions: [Feed.ViewModel.Content.Region]
            let selectedRegion: Feed.ViewModel.Content.Region?

            struct Region: Equatable {
                let id: String
                let name: String
            }

            var hasContent: Bool {
                return !rows.isEmpty
            }
        }
    }
</code></pre><h2>Action</h2><p><code>Enum</code> with actions that <em>View Controller</em> can do and <em>Interactor</em> can handle.</p><pre><code class="language-swift">    enum Action {
        case load
        case changeRegion(regionId: String?)
    }
</code></pre><h2>Route</h2><p><code>Enum</code> with destinations that <em>View Controller</em> can route to.</p><pre><code class="language-swift">    enum Route: Equatable {
        case book(Trip)
    }
</code></pre><h1>Components</h1><h2>Interactor</h2><p>Receives an action, performs work and sends raw data to presenter.</p><ul><li>Input - <em>Action</em></li><li>Output - <em>Data</em></li><li>Uses - <em>Presenter</em></li></ul><h2>Presenter</h2><p>Receives raw data and maps it into <em>View Model</em></p><ul><li>Input - <em>Data</em></li><li>Output - <em>View Model</em></li></ul><h2>View Controller</h2><p>Receives <em>View Model</em> and configures a view according to it. Sends actions to <em>Interactor</em>.</p><ul><li>Input - <em>View Model</em></li><li>Output - <em>Action</em></li><li>Uses - <em>Interactor</em>, <em>Router</em></li></ul><h2>Router</h2><p>Receives <em>Route</em> object from <em>View Controller</em>, that contains information about next destination, and opens next <em>View Controller</em> using <em>Configurator</em></p><ul><li>Input - <em>Route</em></li><li>Uses - <em>Configurator</em></li></ul><h2>Configurator</h2><p>Takes an input and creates configured <em>View Controller</em> with other components.</p><ul><li>Input - Optional configuration data.</li><li>Output - <em>View Controller</em></li><li>Creates - <em>Interactor</em>, <em>Presenter</em>, <em>View Controller</em>, <em>Router</em></li></ul><h1>Feature</h1><p>The group of these components is called <code>Feature</code>. <a href="https://clean-swift.com">Clean Swift</a> provides with XCode templates that allow to generate all of these components together. We are using <a href="https://github.com/staskus/aerogami-ios/tree/master/templates/plop/Feature">plop templates</a> for feature generation. All of this allows to avoid writing boilerplate code and concentrate on actual code of the feature.</p><h1>Feed Example</h1><p><code>Feed</code> is a main <a href="https://github.com/staskus/aerogami-ios/tree/master/TravelFeatureKit/Features/Feed">feature</a> of the application. We're going to see how all of these different components is used to create a complete feature.</p><h2>Feed Interactor</h2><p><code>Feed Interactor</code> uses repositories of <em>Region</em>, <em>Trip</em> and <em>Airport</em> for loading data.</p><p><code>dispatch</code> function is an entry point of any <code>Interactor</code>.</p><pre><code class="language-swift">    func dispatch(_ action: Feed.Action) {
        switch action {
        case .load:
            contentState = .loading(data: contentState.data)
            load()
        case .changeRegion(let regionId):
            changeRegion(id: regionId)
        }
    }
</code></pre><p>We can see when <code>FeedInteractor</code> receives <em>load</em> action it sets current state to <em>loading</em> and calls <code>load()</code> method. It combines <code>RegionRepository</code> and <code>TripRepository</code>, maps it to <em>Data</em> object and passes it to <code>FeedPresenter</code> by setting <em>contentState</em>.</p><pre><code class="language-swift">    func load() {
        let selectedRegion = regionRepository.getSelectedRegion()

        Observable.combineLatest(
            self.regionRepository.getRegions(),
            self.tripRepository.getTrips(in: selectedRegion?.id)
            )
            .map { (regions, trips) -&gt; Feed.Data in
                return Feed.Data(
                    regions: regions,
                    trips: trips,
                    selectedRegionId: selectedRegion?.id,
                    tripImages: []
                )
            }
            .subscribe(
                onNext: { data in
                    self.contentState = .loaded(data: data, error: nil)
                    self.loadImages(for: data.trips)
                },
                onError: { error in
                    self.contentState = .error(error: .loading(reason: R.string.localizable.errorGenericTitle()))
                }
            )
            .disposed(by: disposeBag)
    }
</code></pre><h2>Feed Presenter</h2><p><a href="https://github.com/staskus/aerogami-ios/blob/master/TravelFeatureKit/Features/Feed/FeedPresenter.swift">Feed Presenter</a> essentially takes <code>Feed.Data</code> and returns <code>Feed.ViewModel</code>.</p><pre><code class="language-swift">    func makeContentViewModel(content: Feed.Data) throws -&gt; Feed.ViewModel.Content {
        return Feed.ViewModel.Content(
            rows: makeFeedCardRows(content),
            availableRegions: makeAvailableRegions(content),
            selectedRegion: makeSelectedRegion(content)
        )
    }
</code></pre><p>We can see that <em>struct</em> such as <code>FeedCardViewModel</code> is fairly complicated and comprehensively describes for a table view row what needs to be displayed. It ensures that there is absolutely no business logic, mapping or formatting done in a view as it's simply sets these properties to appropriate variables.</p><pre><code class="language-swift">    private func makeFeedCardRows(_ content: Feed.Data) -&gt; [FeedCardViewModel] {
        return getSortedTrips(content).map { trip in
            currencyFormatter.currencyCode = trip.currency
            return FeedCardViewModel(
                direction: R.string.localizable.feedBothWaysTitle(),
                trip: makeTripString(trip),
                price: formatCurrency(trip),
                dateRange: dateRange(trip),
                routeName: R.string.localizable.feedBookTitle(),
                imageUrl: makeTripImageURL(trip, content: content),
                route: Feed.Route.book(trip),
                isExpired: trip.expiresAt &lt;= Date()
            )
        }
    }
</code></pre><h2>Feed View Controller</h2><p>View Controller in this architecture is a very lean and clean class. It does what view <em>should</em> do: present data, handle user actions and delegate these actions to 'interactor'.</p><p><em>display()</em> lets <code>FeedViewController</code> know that the state and <code>Feed.ViewModel</code> was updated. Different views then can use parts of view model to configure themselves.</p><pre><code class="language-swift">    func display() {
        guard let viewModel = viewModel?.state.viewModel else { return }

        tableView.reloadData()
        headerView.configure(with: viewModel.selectedRegion)
    }
</code></pre><p><code>Feed.Action</code> is sent to <code>Feed.Interactor</code> when anything meaningful happens in <code>FeedViewController.</code> For example, loading data when view appears.</p><pre><code class="language-swift">    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        interactor.subscribe()
        interactor.dispatch(Feed.Action.load)
    }
</code></pre><p><code>Feed.Route</code> is sent to <code>Feed.Router</code> when <code>FeedViewController</code> wants to transition to other view controller.</p><pre><code class="language-swift">    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let cellViewModel = viewModel?.state.viewModel?.rows[indexPath.row] else { return }

        router.route(to: cellViewModel.route)
    }
</code></pre><h2>Feed Router</h2><p><code>FeedRouter</code> handles <em>route</em> actions and opens other view controllers. It uses <code>BookTripConfigurator</code> for building <code>BookTripViewController</code>.</p><pre><code class="language-swift">class FeedRouter {

    private let bookTripConfigurator: BookTripConfigurator

    weak var viewController: FeedViewController?

    init(bookTripConfigurator: BookTripConfigurator) {
        self.bookTripConfigurator = bookTripConfigurator
    }

    func route(to route: Feed.Route) {
        switch route {
        case .book(let trip):
            let bookTripViewController = bookTripConfigurator.createViewController(trip: trip)
            bookTripViewController.modalPresentationStyle = .overCurrentContext
            bookTripViewController.modalTransitionStyle = .coverVertical
            viewController?.tabBarController?.present(bookTripViewController, animated: true, completion: nil)
        }
    }
}
</code></pre><h2>Usage</h2><p>For understanding this flow easier we can imagine a hypothetical scenario of <code>Feed</code> feature.</p><ol><li>AppDelegate uses <code>FeedConfigurator</code> and calls <code>createViewController()</code> to create <code>FeedViewController</code></li><li><code>FeedViewController</code> on <code>viewWillAppear</code> calls <code>interactor.dispatch(Feed.Action.load)</code> to trigger <code>load</code> action</li><li><code>FeedInteractor</code> handles <code>load</code> action and uses <code>TripRepository</code> to load an array of <code>Trips</code> from the backend. It passes an array of <code>Trips</code> to <code>FeedPresenter</code>.</li><li><code>FeedPresenter</code> takes an array of <code>Trips</code> and maps it to <code>FeedViewModel</code> by formatting and localizing text, loading images and splitting it into fields that view needs to know about.</li><li><code>FeedViewController</code>'s method <code>display()</code> is triggered and table view is loaded with new data.</li></ol><p>Although this all may seem too much at first, it actually provides developers with huge clarity when building and maintaining the project. Moreover, all these different components have clear inputs and outputs than can be unit tested. With the growing complexity of the feature it becomes convenient to simply check <code>Action</code> to see all the different things that <code>ViewController</code> does or analyse <code>Presenter</code> to understand what kind of data is actually presented.</p><h2>Result</h2><p>In these series we've seen how to build iOS application by separating it into different frameworks, loading data from API and mapping it using <code>Codable</code>, sketching UIs following Apple's guidelines and develop it all on top of <em>Clean</em> architecture. All of these steps allow the app to be scalable, maintainable and testable.<br><br><img src="https://www.staskus.io/images/aerogami-tutorial/part5/app_demo.gif" alt="App Demo" width="300"/></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</guid><title>Building a real-world iOS app (Part 4): Design</title><description></description><link>https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</link><pubDate>Wed, 20 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>User experience (UX) and design is an integral part of any application. As a developer, I don't have much knowledge or "feeling" towards good looking designs. Moreover, truly great user experience requires many iterations of development and feedback. In this part we'll see how we can take example from Apple's mobile apps and design guidelines to create a familiar looking application.</p><h1>Colors</h1><p>We'll begin to design by choosing the color palette of our application. One of the best ways to ensure familiarity and simplicity of the app is to have consistent colors throughout the application. I found it a great advice to limit yourself to 1 or 2 colors.</p><p>There are a few tools online to generate color palettes so the colors would fit together nicely.</p><p>Chosen colors should be put in a common place so it could be easily accessible.</p><pre><code>struct Theme {
    static let primary = UIColor(red: 255/255, green: 82/255, blue: 82/255, alpha: 1.0)
    static let primaryLight = Theme.primary.withAlphaComponent(0.9)
    static let backgroundColor = UIColor(red: 239/255, green: 239/255, blue: 244/255, alpha: 1.0)
}
</code></pre><h1>UI</h1><p>Apple provides great resources for getting started. <a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a> is a great starting point for understanding the thinking behind Apple's choices as well as their preferences. Users have certain expectations and habits when using any application and it's important not to distract them with an unexpected behavior.</p><p>We'll take the inspiration from already existing <em>AppStore</em> app. The main screen of this app has a feed that we want to display in our travel application as well.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_example.png" alt="App Scren Example" width="300"/><p>Apple also provides us with <a href="https://developer.apple.com/design/resources/">design resources</a> that contain <a href="https://www.sketch.com">Sketch</a> files with designs of already existing applications. When learning to sketch or design something, I found it really beneficial to have these in front of me.</p><p>After tweaking these screens and applying our color palette we can create the first version of our design.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_real.png" alt="Feed Screen" width="300"/><p>It displays the essential information such as <em>origin</em>, <em>destination</em>, <em>dates</em> and <em>price</em>. We can also show images which provide visual information about the destination.</p><h1>App Icon</h1><p>Application icon is also a huge part of first impression of any application. We can use same given <a href="https://developer.apple.com/design/resources/">design resources</a> that include examples of created app icons.</p><p>We can use a little bit of imagination and tweak given icons on Sketch to give it a look of a travel or flight application.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.gif" alt="Making of App Icon" width="300"/><p>The resulting icon looks like this.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.png" alt="App Icon" width="300"/><p>We can use <a href="https://makeappicon.com">makeappicon.com</a> to generate all the necessary sizes of the icon so it could be used for different screen sizes as well as on AppStore.</p><h1>What's next?</h1><p>We saw how it's possible to create a clean design of an application without having much knowledge or spending too much time. Especially for small side projects, it's important to concentrate on main functionality and simply use best practices and examples when creating UIs.</p><p>In the next part of the series we'll shift our attention back to the development of our application. We'll see the approach for creating new screens and keeping the view and its logic cleanly separated.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</guid><title>Building a real-world iOS app (Part 3): Fetching and parsing data from API</title><description></description><link>https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</link><pubDate>Mon, 18 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In the <a href="2019-03-17-aerogami_series_part_2">previous part</a> we discovered a way to separate our application into frameworks and setup the architecture of our app to support dependency injection. In this part of the series we'll be fetching and parsing data from the backend using Alamofire and Codable.</p><h1>API Client</h1><p>Although in the scope of this tutorial we'll be using mocked data, the application will be completely ready to support calls to REST APIs.</p><h3>Protocol</h3><p>We define our <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/APIClient.swift">APIClient</a> protocol that serves as a lean interface between data fetching classes and actual implementation.</p><pre><code class="language-swift">import RxSwift

public protocol APIClient {
    func get(path: String) -&gt; Observable&lt;Any&gt;
}
</code></pre><p>It returns <code>Observable&lt;Any&gt;</code> which is a part of <code>RxSwift</code>. We won't be going through the basics of <code>RxSwift</code>, so it's beneficial to take a look <a href="https://github.com/ReactiveX/RxSwift">official documentation</a> before continuing.</p><h3>Implementation</h3><p>The actual implementation is in <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">BaseAPIClient</a>, which uses <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> for making HTTP requests. The only method <code>get(path: String)</code> makes <code>GET</code> request by concating given path to a base URL.</p><pre><code class="language-swift">import RxAlamofire
import RxSwift

public class BaseAPIClient: APIClient {
    private let baseUrl: String

    public init(baseUrl: String) {
        self.baseUrl = baseUrl
    }

    public func get(path: String) -&gt; Observable&lt;Any&gt; {
        return RxAlamofire
            .requestJSON(.get, "\(baseUrl)/\(path)")
            .map { $1 }
    }
}
</code></pre><h3>Mock</h3><p>If you clone the <a href="https://github.com/staskus/aerogami-ios">repository</a>, it will use <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">MockAPIClient</a> which takes data from files. Because it uses the same public interface, <code>MockAPIClient</code> and <code>BaseAPIClient</code> can be interchanged depending on needs. See <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelApplication/Application/Assembly/ApplicationAssembly.swift">ApplicationAssembly</a> which assigns dependencies for <code>APIClient</code> interface. Depending on different configuration, it can assign any of these two. This little example perfectly illustrates the power of <code>dependency injection</code> and usage of <code>protocols</code>.</p><h1>Data</h1><p>The main entity in this project is a <code>Trip</code>. It describes the origin and destination of the flight as well as price and dates.</p><pre><code class="language-js">{
   "currency":"EUR",
   "created_at":1547991979887,
   "airlines":"FR",
   "departure_at":1552848000000,
   "destination":{
      "city":"Malaga",
      "country_code":"ES",
      "airport_code":"AGP"
   },
   "flight_number":4048,
   "departure":{
      "city":"Copenhagen",
      "country_code":"DK",
      "airport_code":"CPH"
   },
   "return_at":1553153100000,
   "price":72,
   "id":"c4449ff0-1cb9-11e9-b9f8-b3ba95b35000",
   "expires_at":1739200281000
}
</code></pre><p><a href="https://github.com/staskus/aerogami-ios/blob/master/TravelApplication/Application/Mocking/TripMock.json">See full Trips JSON file</a></p><p>We'll define our entities inside <code>TravelKit</code> framework. They should be made public, so they could be reached inside other frameworks. We'll use excellent <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> type that starting from Swift 4 provides a powerful and clean way to encode and decode data.</p><p>Take a look at <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelKit/Repositories/Trip/Trip.swift">Trip</a> class. We don't need to define keys of each values if they match. It's possible to define what naming strategies are used during decoding or encoding process. For example, <code>.convertFromSnakeCase</code> strategy, as its name suggests, converts keys from snake case and assigns values automatically if they match.</p><pre><code class="language-swift">import Foundation

public struct Trip: Codable, Equatable {
    public var id: String = ""
    public var currency: String = ""
    public var price = 0

    public var airlines = ""
    public var flightNumber = 0

    public var destination: TripLocation!
    public var departure: TripLocation!

    public var createdAt = Date()
    public var departureAt = Date()
    public var returnAt = Date()
    public var expiresAt = Date()

    public init() {}
}

public struct TripLocation: Codable, Equatable {
    public var city: String!
    public var countryCode: String!
    public var airportCode: String!

    public init() {}
}
</code></pre><p>After receiving <code>JSON</code> data we can define <code>decoder</code> and automatically parse values.</p><pre><code class="language-swift">    public static var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        decoder.dateDecodingStrategy = .millisecondsSince1970
        return decoder
    }()

    let trips = try? decoder.decode([Trip].self, from: data)
</code></pre><p>With this simple and straightforward Codable API our data is cleanly parsed into statically typed object or array of objects after <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelDataKit/Repositories/Trip/Remote/APITripDataStore.swift">fetching from API</a>.</p><h1>Repositories</h1><p>Classes that are used to fetch data will be called repositories. In <code>TravelKit</code> we'll only define the protocols of these repositories. Our UI framework <code>TravelFeatureKit</code> will only know about <code>TravelKit</code> and protocols of repositories thus the implementations, defined in <code>TravelDataKit</code>, will be easily changeable.</p><p>Our <code>TripRepository</code> protocol defines the only way to fetch trips.</p><pre><code class="language-swift">import RxSwift

public protocol TripRepository {
    func getTrips(in region: String?) -&gt; Observable&lt;[Trip]&gt;
}
</code></pre><p>Because our UI framework will only know about this protocol, we will be able to provide different types of implementations. <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/TripRepository.swift">TripRepository</a> implementation defined in <code>TravelDataKit</code> calls the <code>API</code> to fetch data and parses it using <code>Coadable</code>. However, <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/FavoriteTripRepository.swift">FavoriteTripRepository</a> which also implements <code>TripRepository</code> interface, uses <code>UserDefaults</code> to fetch locally liked <code>Trips</code>. It allows us to generate 2 completely different screens in our app. One showing the current feed of flights fetched from the API and another of liked and locally saved trips. Here <a href="https://github.com/staskus/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelFeatureKit/Features/Favorites/FavoritesAssembly.swift">FavoritesAssembly</a> simply injects necessary dependencies needed for <em>favorites</em> to a <code>FavoriteFeed</code> feature.</p><h1>Design</h1><p>Before continuing creating the app, we'll see how we can quickly create simple application designs using Sketch or similar tools. In the next part of the series we'll overview the approach.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</guid><title>Building a real-world iOS app (Part 2): Separating application into frameworks</title><description></description><link>https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</link><pubDate>Sun, 17 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In this part of the series we'll overview how to properly setup the application.</p><h1>Creating Frameworks</h1><p>As we talked in the <a href="https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1">previous part</a>, we'll begin the creation of the project by creating 3 separate frameworks inside our XCode project (<code>TravelKit</code>, <code>TravelDataKit</code>, <code>TravelFeatureKit</code>). An article on <a href="https://www.raywenderlich.com/5109-creating-a-framework-for-ios">raywenderlich.com</a> has a thorough explanation of the whole process.</p><p>After creating frameworks, project navigator should look something like in the picture below.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part2/project_frameworks.png" alt="Frameworks in the Project Navigator" width="300"/><h1>Setting up CocoaPods</h1><p>We'll be using <a href="https://cocoapods.org">CocoaPods</a> for managing dependencies in our project. Although setting up CocoaPods is fairly straightforward, there can be some difficulties when having local frameworks involved. The configuration is defined in <code>Podfile</code> which is located in the root folder of the project.</p><p><code>Podfile</code> will be configured in a way that is clean and clear so it would not get messy when number of dependencies in the project grow. Essentially, we'll define the reusable pods at the top of the file and group different groups of pods that can be reused for different frameworks.</p><p>The part of <code>Podfile</code> that defines pods of <code>TravelKit</code>.</p><pre><code class="language-ruby">platform :ios, '11.0'
use_frameworks!
inhibit_all_warnings!

deployment_target = '11.0'

workspace 'TravelApplication.xcworkspace'

#Versions
$swinjectVersion =                    '~&gt; 2.4'
$swiftDateVersion =                   '~&gt; 5.0'
&lt;...&gt;

def shared_TravelKit_pods
    pod 'RxSwift',                    $rxSwiftVersion
    pod 'SwiftDate',                  $swiftDateVersion
end

target 'TravelKit' do
    project 'TravelKit.xcodeproj'
    platform :ios, deployment_target

    shared_TravelKit_pods

  target 'TravelKitTests' do
    project 'TravelKit.xcodeproj'
    inherit! :search_paths

    shared_testing_pods
  end
end
&lt;...&gt;
</code></pre><p>These different shared pods should be assembled and used of the actual application target.</p><pre><code class="language-ruby">&lt;...&gt;
def shared_Apps_pods
  shared_TravelKit_pods
  &lt;...&gt;
end

target 'TravelApplication' do
    project 'TravelApplication.xcodeproj'
    platform :ios, deployment_target
    shared_Apps_pods
end
&lt;...&gt;
</code></pre><p>The full <a href="https://github.com/staskus/aerogami-ios/blob/master/Podfile">Podfile</a> can be found on <code>GitHub</code> as the rest of the project.</p><h1>Dependency Injection</h1><p>I prefer to think early about the way dependencies will be managed inside the application. Although dependency injection can be achieved without 3rd party libraries, for this project we'll use <a href="https://github.com/Swinject/Swinject">Swinject</a> that has easy to use interfaces for managing dependencies.</p><p>Our classes will use <code>initializer injection</code> thus all the dependencies will be given through the initializer. The classes will be initialized in assemblies. Assembly is a <code>Swinject</code> class which has access to a container of already injected dependencies and provides a way to register new dependencies.</p><p>For example, this is how the assembly of the <code>Feed</code> that displays the list of flights might looks like:</p><pre><code class="language-swift">import Foundation
import Swinject
import TravelKit

public class FeedAssembly: Assembly {

    public init() {
    }

    public func assemble(container: Container) {
        container.register(FeedConfigurator.self) { r in
            FeedConfigurator(
                regionRepository: r.resolve(RegionRepository.self)!,
                tripRepository: r.resolve(TripRepository.self)!,
                airportRepository: r.resolve(AirportRepository.self)!,
                tripImageRepository: r.resolve(TripImageRepository.self)!
                )
            }
            .initCompleted { (resolver, feedConfigurator) in
                feedConfigurator.bookTripConfigurator = resolver.resolve(BookTripConfigurator.self)!
            }
            .inObjectScope(.container)
    }
}
</code></pre><p>Here, we inject <code>FeedConfigurator</code> class. It is essentially a factory class for the whole <code>Feed</code> feature and its view. <code>Swinject</code> automatically passes the dependencies such as <code>RegionRepository</code> or <code>TripRepository</code>. We expect these dependencies to be injected in another assembly so we can resolve it here.</p><p>Our application will have <code>AssemblerFactory</code> that will contain all the different assemblies of the application and create them during initialization process.</p><pre><code class="language-swift">import Foundation
import Swinject
import TravelFeatureKit
import TravelDataKit

class AssemblerFactory {

    func create() -&gt; Assembler {
        let assemblies: [Assembly] = [
            ApplicationAssembly(),
            RegionRepositoryAssembly(),
            TripRepositoryAssembly(),
            AirportRepositoryAssembly(),

            MainAssembly(),
            FavoritesAssembly(),
            FeedAssembly(),
            BookTripAssembly(),
            BookURLRepositoryAssembly(affiliateId: Constants.affiliateId)
        ]

        let assembler = Assembler(assemblies)

        return assembler
    }
}
</code></pre><p>We use this assembly to create the first <code>ViewController</code> of the application and set it as <code>rootViewController</code>. See <a href="https://github.com/staskus/aerogami-ios/blob/master/TravelApplication/Application/ApplicationLoader.swift">ApplicationLoader</a>.</p><pre><code class="language-swift">  self.assembler = AssemblerFactory().create()
  let rootConfigurator = assembler.resolver.resolve(MainConfigurator.self)!
  let rootViewController = rootConfigurator.createViewController()
  window?.rootViewController = rootViewController
  window?.makeKeyAndVisible()
</code></pre><p>In the following parts of the series we'll be creating classes for fetching and presenting data that will use assemblies for injecting dependencies. We'll see more closely how having proper dependency injection allows code to be more reusable, safe and testable.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</guid><title>Building a real-world iOS app (Part 1): Introduction</title><description></description><link>https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</link><pubDate>Mon, 11 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When learning any new technology I find it beneficial to follow a real world example. In this tutorial series we'll be creating and releasing an iOS application. The application will be created by showing a real thinking process, going through essential steps and providing the motivation behind them. Although every single line of code won't be covered, all of it will be always available on <a href="https://github.com/staskus/aerogami-ios">GitHub</a>.</p><h1>Prerequisites</h1><p>Prior knowledge of iOS development and Swift syntax is needed.</p><h1>Introduction</h1><h2>Our Project</h2><p>We'll be creating a flight discovery application. The users of our application should be able to:</p><ol><li>See the <em>feed</em> of <em>flights</em></li><li>See the <em>date</em>, <em>price</em>, <em>origin</em> and <em>destination</em> of each <em>flight</em></li><li>Book the <em>flight</em>.</li></ol><p>In the scope of this project we won't be concerned about the source of information. Our application will use mocked flight information data. However, the structure of the application will support an easy integration with any Rest API.</p><h2>Our Approach</h2><p>Throughout the series we'll cover these topics one-by-one:</p><ol><li>Data Fetching and Parsing</li><li>Testing</li><li>Code Separation into Frameworks</li><li>Design using Sketch</li><li>Clean Swift Architecture</li><li>Building the UI and Displaying the Data</li><li>Release Process</li></ol><h2>The Final Product</h2><p>Here is the sneak peek of how the final product will look like. The full codebase can be found on <a href="https://github.com/staskus/aerogami-ios">GitHub</a>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/screenshot.png" alt="Application Screenshot" width="200"/><h1>High Level View</h1><p>Before we start, it's beneficial to understand how we're going to approach the creation of this application.</p><h2>Separation of Concerns</h2><p>Essentially our application should be able to perform 3 main tasks:</p><ol><li>Fetch data</li><li>Parse data</li><li>Display data</li></ol><p>We'll separate these different concerns into frameworks for our code to be decoupled and flexible. The primitive diagram of the architecture is displayed in the picture bellow. We'll define data models and protocols in <code>TravelKit</code>. This framework will contain data fetching protocols, which will be implemented in <code>TravelDataKit</code>. DataKit, as its name suggests, will be used for fetching, persisting and providing data. User interface will only know about data models and protocols and won't be concerned about the implementation. We'll call this framework <code>TravelFeatureKit</code>. The entry point of our application will initialize the dependencies required for all the frameworks and present the root view described in <code>TravelFeatureKit</code>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/architecture.png" alt="Application Architecture" width="300"/><p>In the next part of the series we'll continue by explaining how to create frameworks and setup the base of the application.</p>]]></content:encoded></item></channel></rss>