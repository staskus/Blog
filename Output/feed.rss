<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Povilas Sta≈°kus</title><description>iOS Developer</description><link>https://www.staskus.io</link><language>en</language><lastBuildDate>Wed, 30 Mar 2022 11:06:24 +0300</lastBuildDate><pubDate>Wed, 30 Mar 2022 11:06:24 +0300</pubDate><ttl>250</ttl><atom:link href="https://www.staskus.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.staskus.io/notes/Trees%20and%20Graphs</guid><title>Trees and Graphs</title><description></description><link>https://www.staskus.io/notes/Trees%20and%20Graphs</link><pubDate>Wed, 30 Mar 2022 11:06:15 +0300</pubDate><content:encoded><![CDATA[<h1>Trees</h1><p><strong>Tree</strong> - a data structure composed of nodes. Each tree has a root node, each child has zero or more child nodes and doesn't have cycles.</p><p><strong>Leaf Node</strong> - a node with no children.</p><h2>Binary trees</h2><p><strong>Binary Tree</strong> - each node has up to two children.</p><p><strong>Binary Search Tree</strong> - when <em>every</em> node is specifically ordered.</p><p><strong>Complete Binary Tree</strong> - every level is filled except the last level. Last level filling from left to right.</p><p><strong>Full Binary Tree</strong> - each node has either zero or two children</p><p><strong>Perfect Binary Tree</strong> - full, complete and all nodes at the same level.</p><h3>Traversal</h3><h4>In-Order</h4><p>First visit the left branch, then the current node then the right branch.</p><pre><code><span class="keyword">func</span> traverseInOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">traverseInOrder</span>(node?.<span class="property">left</span>)
        <span class="call">visit</span>(node) <span class="comment">// for example just print</span>
        <span class="call">traverseInOrder</span>(node?.<span class="property">right</span>)
    }
}
</code></pre><h4>Pre-Order</h4><p>First visit the current node, then the others.</p><pre><code><span class="keyword">func</span> traversePreOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">visit</span>(node)
        <span class="call">traversePreOrder</span>(node?.<span class="property">left</span>)
        <span class="call">traversePreOrder</span>(node?.<span class="property">right</span>)
    }
}
</code></pre><h4>Post-Order</h4><p>First visit left and right branches, then the current node.</p><pre><code><span class="keyword">func</span> traversePostOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">traversePostOrder</span>(node?.<span class="property">left</span>)
        <span class="call">traversePostOrder</span>(node?.<span class="property">right</span>)
        <span class="call">visit</span>(node)
    }
}
</code></pre><h2>Balancing</h2><p><strong>Balanced tree</strong> - doesn't mean that right and left sides are of the same size. It means that its balance might allow for specific effective operations such as O(log n) insert and find.</p><h2>Binary Heaps</h2><p><strong>Min-heap</strong> - is a complete binary tree where each node is smaller than its children. The root is the minimum element in the tree.</p><h3>Insert</h3><p>We insert at the rightmost empty spot and then go up by swapping with the parent until it's smaller than its parent.</p><p>O(log n)</p><h3>Get Minimum Element</h3><p>It's always at the top.</p><h3>Remove Minimum Element</h3><ol><li>Remove the top element</li><li>Replace it with the bottommost-rightmost element</li><li>Go from the top to the bottom swapping it with the children until it reaches its place</li></ol><p>O(log n)</p><h2>Trie (Prefix Tree)</h2><p>An n-ary tree where characters are stored at each node. * node indicates a complete word. Each node can have children the number of the size of the alphabet.</p><p>Usage: <em> Storing the entire language for quick prefix lookups. </em> Lists of valid words</p><h1>Graphs</h1><p>A graph is a collection of nodes with edges between some of them.</p><p><strong>Connected graph</strong> - if there's a path between every pair of vertices.</p><p><strong>Acyclic graph</strong> - a graph without cycles</p><h2>Adjacency List</h2><p>A way to represent a graph</p><pre><code><span class="keyword">class</span> Graph {
    <span class="keyword">var</span> nodes: [<span class="type">Node</span>]
}

<span class="keyword">class</span> Node {
    <span class="keyword">var</span> val: <span class="type">Int</span>
    <span class="keyword">var</span> children: [<span class="type">Node</span>]
}
</code></pre><h2>Adjacency Matrix</h2><pre><code>matrix[i][j] == <span class="keyword">true</span> <span class="comment">// represents that there's an edge between i and j nodes</span>
</code></pre><h2>Search</h2><h3>Depth-first search (DFS)</h3><p>Explore each branch completely before moving to the next branch, meaning going deep first.</p><p>DFS is to visit every node in the graph.</p><p>To implement we can use recursion or a stack (which recursion uses underneath).</p><pre><code>     <span class="keyword">func</span> searchDFS(<span class="keyword">_</span> root: <span class="type">Node</span>?) {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="call">visit</span>(root)
        root.<span class="property">visited</span> = <span class="keyword">true

        for</span> node <span class="keyword">in</span> root.<span class="property">children</span> {
            <span class="keyword">if</span> !node.<span class="property">visited</span> {
                <span class="call">seachDFS</span>(node)
            }
        }
    }
</code></pre><h3>Breadth-first search (BFS)</h3><p>Explore each neighbor before moving to the children, meaning going wide first.</p><p>BFS is used to find the shortest (or any) path between 2 nodes.</p><p>To implement we need to use a queue (FIFO) data structure to ensure we search wide first.</p><pre><code>     <span class="keyword">func</span> searchBFS(<span class="keyword">_</span> root: <span class="type">Node</span>?) {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="keyword">let</span> queue = <span class="type">Queue</span>()
        root.<span class="property">marked</span> = <span class="keyword">true</span>
        queue.<span class="call">enqueue</span>(root) <span class="comment">// Add to the end</span>

        <span class="keyword">while</span> !queue.<span class="call">isEmpty</span> {
            <span class="keyword">let</span> node = queue.<span class="call">dequeue</span>() <span class="comment">// Take from the front</span>
            <span class="call">visit</span>(node)

            <span class="keyword">for</span> child <span class="keyword">in</span> node.<span class="property">children</span> {
                <span class="keyword">if</span> !child.<span class="property">marked</span> {
                    child.<span class="property">marked</span> = <span class="keyword">true</span>
                    queue.<span class="call">enqueue</span>(child)
                }
            }
        }
    }
</code></pre><p>3 facts to know about BFS: 1. Inorder traversal of BST is an array sorted in the ascending order. 2. Successor = "after node", i.e. the next node in "In order traversal (Left -&gt; Node -&gt; Previous)", or the smallest node after the current one. 3. Predecessor = "before node", i.e. the previous node "In order traversal (Left -&gt; Node -&gt; Previous)", or the largest node before the current one.</p><h3>Bidirectional Search</h3><p>Find the shorted path between 2 nodes by performing 2 simultaneous BFS from both nodes.</p><h2>Example problems to know how to solve:</h2><h3>Convert Sorted Array to Binary Search Tree</h3><p>Keep splitting the sorted array in half so the root would be the middle element.</p><pre><code><span class="comment">// O(n) time complexity, O(logn) space complexity</span>

<span class="keyword">class</span> Solution {
    <span class="keyword">func</span> sortedArrayToBST(<span class="keyword">_</span> nums: [<span class="type">Int</span>]) -&gt; <span class="type">TreeNode</span>? {
        <span class="keyword">return</span> <span class="call">createMinimalBST</span>(nums, start: <span class="number">0</span>, end: nums.<span class="property">count</span> - <span class="number">1</span>)
    }
    
    <span class="keyword">private func</span> createMinimalBST(<span class="keyword">_</span> nums: [<span class="type">Int</span>], start: <span class="type">Int</span>, end: <span class="type">Int</span>) -&gt; <span class="type">TreeNode</span>? {
        <span class="keyword">guard</span> start &lt;= end <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        
        <span class="keyword">let</span> mid = ((start + end) / <span class="number">2</span>)
    
        <span class="keyword">return</span> <span class="type">TreeNode</span>(
            nums[mid],
            <span class="call">createMinimalBST</span>(nums, start: start, end: mid - <span class="number">1</span>),
            <span class="call">createMinimalBST</span>(nums, start: mid + <span class="number">1</span>, end: end)
            )
    }
}
</code></pre><h3>Given a binary tree, return the level order traversal of its nodes</h3><p>It can be done using a simple recursion or a BFS. BFS allows printing easier level by level. In both cases, we need to save the "level" in the queue or pass it during the recursion.</p><h3>Check if Binary Tree is balanced</h3><p>A balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p><p>Calculating the height of each branch is not fully effective. We need to introduce an "early exit" the moment we find one branch not being balanced.</p><pre><code><span class="comment">// O(N) time and O(H) space because of the early exit
// We first go as deep left as possible and then increase the height when going up. The moment we find the difference between left and right more than 1, we throw an error.</span>
<span class="keyword">class</span> Solution {
    <span class="keyword">enum</span> TreeError: <span class="type">Error</span> {
        <span class="keyword">case</span> notBalanced
    }
    
    <span class="keyword">func</span> isBalanced(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
        
        <span class="keyword">do</span> {
            <span class="keyword">try</span> <span class="call">checkHeight</span>(root)
            <span class="keyword">return true</span>
        } <span class="keyword">catch</span> {
            <span class="keyword">return false</span>
        }
    }
    
    <span class="keyword">@discardableResult
    private func</span> checkHeight(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) <span class="keyword">throws</span> -&gt; <span class="type">Int</span> {      
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> -<span class="number">1</span> }

        <span class="keyword">let</span> left = <span class="keyword">try</span> <span class="call">checkHeight</span>(root.<span class="property">left</span>) <span class="comment">// Throwing error as an early exit</span>
        <span class="keyword">let</span> right =  <span class="keyword">try</span> <span class="call">checkHeight</span>(root.<span class="property">right</span>)
        
        <span class="keyword">if</span> (<span class="call">abs</span>(left - right) &lt; <span class="number">2</span>) {
            <span class="keyword">return</span> <span class="call">max</span>(left, right) + <span class="number">1</span>
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">TreeError</span>.<span class="property">notBalanced</span>
        }
    }
}
</code></pre><h3>Validate Binary Search Tree</h3><pre><code><span class="type">A</span> valid <span class="type">BST</span> <span class="keyword">is</span> defined <span class="keyword">as</span> follows:

* <span class="type">The</span> left subtree of a node contains only nodes with keys less than the node's key.
* <span class="type">The</span> right subtree of a node contains only nodes with keys greater than the node's key.
* <span class="type">Both</span> the left and right subtrees must also be binary search trees.
</code></pre><img src="https://www.staskus.io/images/notes/86b326043320bbd1a5d8d05117e1187489c2d15b285e3a773dd4476c23e2dc14.png" alt="Leetcode.com"/><p>We have 2 main routes to take.</p><p>First one is more intuitive, traverse the tree recursively, passing valid ranges and then validating them against the current value:</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
    
    <span class="keyword">return</span> <span class="call">isValidBST</span>(root.<span class="property">left</span>, -<span class="type">Int</span>.<span class="property">max</span>..&lt;root.<span class="property">val</span>) &amp;&amp; <span class="call">isValidBST</span>(root.<span class="property">right</span>, root.<span class="property">val</span>+<span class="number">1</span>..&lt;<span class="type">Int</span>.<span class="property">max</span>)
}

<span class="keyword">private func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?, <span class="keyword">_</span> allowedRange: <span class="type">Range</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
            
    <span class="keyword">if</span> !allowedRange.<span class="call">contains</span>(root.<span class="property">val</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">return</span> <span class="call">isValidBST</span>(root.<span class="property">left</span>, allowedRange.<span class="property">lowerBound</span>..&lt;root.<span class="property">val</span>) &amp;&amp; <span class="call">isValidBST</span>(root.<span class="property">right</span>, root.<span class="property">val</span>+<span class="number">1</span>..&lt;allowedRange.<span class="property">upperBound</span>)
}
</code></pre><p>Using DFS Inorder traversal is a more interesting solution. <code>Left -&gt; Node -&gt; Right</code>. Traversing like this we expect each node to have a larger value if it is a binary search tree.</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">private var</span> previous: <span class="type">Int</span>?

<span class="keyword">func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
<span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
    
    <span class="comment">// Left</span>
    <span class="keyword">if</span> !<span class="call">isValidBST</span>(root.<span class="property">left</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="comment">// Node</span>
    <span class="keyword">if let</span> previous = previous, previous &gt;= root.<span class="property">val</span> {
        <span class="keyword">return false</span>
    }
    previous = root.<span class="property">val</span>
    
    <span class="comment">// Right</span>
    <span class="keyword">if</span> !<span class="call">isValidBST</span>(root.<span class="property">right</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">return true</span>
}
</code></pre><h3>Find a successor (next node) in a binary search tree</h3><ul><li>Successor = "after node", i.e. the next node in the inorder traversal, or the smallest node after the current one.</li></ul><ul><li>Predecessor = "before node", i.e. the previous node in the inorder traversal, or the largest node before the current one.</li></ul><p>So to find a successor we either need to go: - One right node and as many left nodes as possible - If no right node exists, go up the tree until the node is the left child of the parent and return the parent</p><h3>Course Schedule</h3><p>Given the list of courses and dependency list of which courses must come before the others, return a list of course order.</p><p>This issue can be solved with DFS with some caveats. <em> We might not have one graph, there might be multiple graphs. So we might need to do multiple DFS until all nodes (courses) have been visited. </em> Once we reach the end of the graph then we add that node to the <strong>beginning</strong> of the course schedule. * If cycles are found, it's impossible to create a schedule. Cycles can be avoided by <strong>visited</strong> and <strong>visiting</strong> (or gray and black) node marking.</p><h3>Lowest Common Ancestor in a Binary Tree of 2 nodes</h3><p>The idea is to do a DFS recursive search throughout the tree. At each point we make 2 recursive calls (to the left and to the right). At the moment where <strong>both</strong> left and right branches result in a node being found, or any of the branches result in a node being found <strong>and</strong> the current node is a node we are looking for, we return a node.</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">private func</span> findNode(from node: <span class="type">TreeNode</span>?, to p: <span class="type">TreeNode</span>, orTo q: <span class="type">TreeNode</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> node = node <span class="keyword">else</span> {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">let</span> left = <span class="call">findNode</span>(from: node.<span class="property">left</span>, to: p, orTo: q) ? <span class="number">1</span> : <span class="number">0</span>
    <span class="keyword">let</span> right = <span class="call">findNode</span>(from: node.<span class="property">right</span>, to: p, orTo: q) ? <span class="number">1</span> : <span class="number">0</span>
    <span class="keyword">let</span> current = node.<span class="property">val</span> == p.<span class="property">val</span> || node.<span class="property">val</span> == q.<span class="property">val</span> ? <span class="number">1</span> : <span class="number">0</span>
    
    <span class="comment">// If any two are correct</span>
    <span class="keyword">if</span> left + right + current &gt;= <span class="number">2</span> {
        ancestor = node
    }
    
    <span class="keyword">return</span> left + right + current &gt; <span class="number">0</span>
}
</code></pre><h3>Number of Ways to Reorder Array to Get Same BST</h3><p>How many times we can reorder the same given array to get the same BST.</p><p>The intuition: <em> The first array element needs to be the same to have the same root </em> Smaller elements need to keep the same relative position to other small elements * Larger elements need to keep the same relative position to other large elements</p><p>The solution: <em> Divide and conquer. Keep splitting given array into 2 arrays with larger numbers than the first one and smaller numbers than the first one. Calculate the number of combination for each array </em> Combinatorics nCk (to find the number of ways selecting k things out of n things) * Multiply all the results recursively</p><p>Problems in Swift: <em> No built-in way to calculate nCk </em> No built-in way to calculate using large numbers BigInt</p><p>The gist of the algorithm</p><pre><code>     <span class="keyword">func</span> numOfWays(<span class="keyword">_</span> nums: [<span class="type">Int</span>]) -&gt; <span class="type">Int</span> {
       <span class="keyword">func</span> divideAndConquer(<span class="keyword">_</span> sublist: [<span class="type">Int</span>]) -&gt; <span class="type">Int</span> {
           <span class="keyword">if</span> sublist.<span class="property">count</span> &lt;= <span class="number">2</span> {
               <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// base case</span>
           }
           
           <span class="keyword">let</span> root = sublist[<span class="number">0</span>]
           
           <span class="keyword">let</span> left = sublist.<span class="call">filter</span> { $0 &lt; root }
           <span class="keyword">let</span> right = sublist.<span class="call">filter</span> { $0 &gt; root }
           
           <span class="keyword">return</span> <span class="call">nCk</span>(left.<span class="property">count</span> + right.<span class="property">count</span>, left.<span class="property">count</span>) * <span class="call">divideAndConquer</span>(left) * <span class="call">divideAndConquer</span>(right)
       }
        
        <span class="keyword">return</span> (<span class="call">divideAndConquer</span>(nums) - <span class="number">1</span>) <span class="comment">// With big trees the result will overflow</span>
    }
    
    <span class="keyword">func</span> nCk(<span class="keyword">_</span> n: <span class="type">Int</span>, <span class="keyword">_</span> k: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
        <span class="comment">//C (n , k) = n! / [ (n-k)! k! ]</span>
        
        <span class="keyword">if</span> (k &gt; n) { <span class="keyword">return</span> <span class="number">0</span> }
        <span class="keyword">var</span> result = <span class="number">1</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="call">min</span>(k, n-k) {
            result = (result * (n - i))/(i + <span class="number">1</span>)
        }
        <span class="keyword">return</span> result
    }
</code></pre><h1>Additional Information</h1><h2>Spanning Tree</h2><p>A spanning tree is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.</p><p>A minimum spanning tree is a spanning tree with the minimum possible total edge weight in a ‚Äúweighted undirected graph‚Äù.</p><p>Tree - doesn't have cycles</p><p>Cut Property - choosing crossing edge between 2 cuts with the lowest weight</p><h3>Minimum Spanning Tree</h3><p><strong>‚ÄúKruskal‚Äôs algorithm‚Äù</strong> is an algorithm to construct a ‚Äúminimum spanning tree‚Äù of a ‚Äúweighted undirected graph‚Äù. 1) Take all possible edges 2) sort by weight 3) pick one by one if the cycle is not created (!uf.connected).</p><p><strong>Prims Algorithm:</strong> - 1) Pick starting node, see which unvisited node we can visit most cheaply. 2) pick visited nodes, see which unvisited node we can visit most cheaply 3) repeat until all nodes are visited. We need to use min-heap to pick the lowest weighted edge - However, in some cases using min-heap is not effective enough so we need to look ways around it (Min Cost to Connect All Points) as even effective sorting adds log(n) of time complexity.</p><p>Heap is not a Priority Queue, but a way to implement a Priority Queue.</p><p>Heap is a special type of binary tree. Insertion, deletion O(log n). Max, minimum - O(1): - Min Heap. - Max Heap</p><p>BFS - Always find the shortest path first. Finding a path in the grid is a usual task.</p><h2>Single source shortest path problem</h2><p>Edge Relaxation operation is a key in solving the "single source shortest path problem" - If A-D distance is 3, but A-C-D is 2 by performing edge relaxation we note that the distance between A-D is actually 2</p><p><strong>Dijkstra's algorithm</strong>. Can only be used to solve the problem with non-negative weights</p><ul><li>In time complexity we have 2 properties: V - number of vertices and E - number of edges. If we use the Fibonacci heap to extract minimum element total complexity O(E + VlogV). If we use Binary heap time complexity would be O(V+ ElogV).</li><li>Space complexity O(V)</li></ul><p><strong>Steps:</strong> 1. Start at the ending vertex by marking it with a distance of 0 (call it <em>currentVertex</em>) 2. Identify all of the vertices connected to <em>currentVertex</em> with weights. If we already identified vertex, only change weight if a new one is smaller 3. Label <em>currentVertex</em> as visited 4. Find smallest identifier vertice and repeat 2 5. Once labeled a beginning vertex - stop</p><p><strong>Bellman-Ford algorithm</strong>. Can solve with any weights.</p><p>‚ÄúBellman-Ford algorithm‚Äù is only applicable to ‚Äúgraphs‚Äù with no ‚Äúnegative weight cycles‚Äù.</p><p>We find a negative cycle if after performing Nth edge relaxation (we normally just need to do N-1) we still find a shorter path.</p><ul><li>Time complexity O(V * E)</li><li>Space complexity O(V)</li></ul><p>Positive Weight Cycle: If during each cycle the path weight increases. The shortest path is after the first cycle</p><p>Negative Weight Cycle: If during each cycle the path weight decreases. There's no shortest path then</p><p><strong>Bellman-Ford:</strong> 1. Have previous and current arrays 2. Each iteration simply set current cost to be minimum of already existing or previous + cost current[destination] = min(current[destination], previous[origin] + cost) 3. At the end of iteration set previous = current</p><p>Essentially, <strong>Bellman-Ford</strong> algorithm is a dynamic programming solution optimized for space and time. If 2 loops in the row we get the same result, we can return it as the shortest path.</p><p>If a question has a constraint of going through k edges, then we just use a dynamic programming approach</p><h2>Dynamic Programming</h2><p><strong>Dynamic Programming (DP)</strong> is an algorithmic technique for solving an optimization problem by breaking it down into simpler subproblems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its subproblems.</p><p>Solving shortest path problem using Dynamic Programming: - Asking: Can I find the shortest path using at most 1 edge? Can I find the shortest path using at most 2 edges, etc until N-1 edges</p><p><strong>Dynamic Programming</strong> 1. Look if the same problem can be split into some smaller problems in a tree structure. Then it means we can solve it using recursion. We need to know the base case to return early from recursion. 2. Make it work brute force way 3. Optimize it using ‚Äúmemoization‚Äù (creating dict or set for efficiency)</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Stacks%20and%20Queues</guid><title>Stacks and Queues</title><description></description><link>https://www.staskus.io/notes/Stacks%20and%20Queues</link><pubDate>Thu, 24 Mar 2022 11:45:59 +0200</pubDate><content:encoded><![CDATA[<h2>Stack</h2><p>A stack has LIFO ordering. Main operations:</p><ul><li>pop() - remove the top element</li><li>push(_) - add an item to the top</li><li>peek() - look at the top element</li><li>isEmpty() - true if there're no elements</li></ul><h3>Usage</h3><ul><li>Recursive algorithms</li></ul><h2>Queue</h2><p>A queue has FIFO ordering. Main operations:</p><ul><li>add(_) - aedd an item to the bottom</li><li>remove() - remove the top element</li><li>peek() - look at the top element</li><li>isEmpty() - true if there're no elements</li></ul><h3>Usage</h3><ul><li>Breadth-first-search</li><li>Implementing a cache</li></ul><h2>Time complexity</h2><ul><li>O(n) for accessing nth item</li><li>O(1) for adding and removing an item</li></ul><h2>Example tasks to know how to solve:</h2><h3>Min Stack</h3><p>A stack that also can get a minimum value.</p><p>The trick here is to understand that minimum value only changes if the new smaller stack element is added. If this element is removed, we need to come back to an old minimum value. To achieve this we need to save a current min value with each <em>Node</em>. As it's a LIFO data structure we sort of have a timeline of minimum values.</p><h3>Implement Queue using 2 Stacks</h3><ul><li>Since the queue is FIFO and stack is LIFO we can reverse element order by moving elements from one stack to another. Doing it every push operation produces a time complexity of O(n)</li><li>We can do an <em>amortized</em> solution with having <em>old</em> and <em>new</em> stack. Only if the <em>old</em> (reversed) element stack is empty, we shift elements from <em>new</em> to <em>old</em>. This makes the average scenario much more effective than the worst-case scenario.</li></ul><h3>Stack supporting different types</h3><p>If the stack needs to support <em>popAnyType()</em>, <em>popTypeA()</em> and <em>popTypeB()</em> the best solution is to have separate stacks for both typeA and typeB and save a timestamp next to the nodes. When we do <em>popAnyType()</em> we can check which stack has the oldest element on top and return that.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Arrays%20and%20Strings</guid><title>Array and Strings</title><description></description><link>https://www.staskus.io/notes/Arrays%20and%20Strings</link><pubDate>Thu, 24 Mar 2022 11:45:49 +0200</pubDate><content:encoded><![CDATA[<h2>Hash Tables</h2><p>We can implement hash tables using the combination of arrays and linked lists.</p><ol><li>We compute hash code and % it from array length</li><li>At each array position there's a linked list to deal with collisions</li><li>When retrieving values find a linked list by a key (hash &amp; index) and then search through a linked list for a key</li></ol><p>Although the worst-case scenario due to collisions is 0(n), a good implementation that keeps collisions at a minimum is considered to be O(1)</p><h2>Resizable Arrays</h2><p>Some programming languages have only fixed-size arrays and use different types of data structures like ArrayList which expands in size dynamically. It does this by doubling its size after reaching a limit.</p><h2>Example tasks to know how to solve:</h2><h3>Determine if String has unique characters</h3><p>We can use Sets or Hashmaps. If we can only use Arrays clarify the limitations of an alphabet. If it's the English alphabet we can create an array of size 26 (size 128 if including all ASCII characters) and the element's position would be <em>character.asciiValue - 'a'.asciiValue</em>.</p><h3>Given two strings decide if one is a permutation of the other</h3><p>We can sort and check if they are equal with time complexity O(nlogn) and space complexity O(1).</p><p>We can use hashtables with time complexity O(n) and space complexity O(n).</p><p>If the alphabet has limitations (as explained before) we can use fixed-size arrays with a space complexity of O(1).</p><h3>Check if a string is a permutation of a palindrome</h3><p>In such a task is important to nail down what exactly is a palindrome. It has no more than one odd number-letter count. We can again use fixed-size arrays to make letter counts.</p><h3>Check if 2 strings are one edit (insert, remove, replace) away</h3><p>It's important to exit early from clear invalid cases. Then go through a long string and return false if found more than one difference.</p><h3>Compressing the string into its letter counts without using extra space</h3><p>What is helpful is using a concept of a <em>read pointer</em> and a <em>write pointer</em>. While we make calculations going together with <em>read pointer</em>, <em>write pointer</em> can execute changes on the string without making some positioning calculations.</p><h3>Rotate Matrix without using extra space</h3><p><strong>A very popular problem</strong></p><p>Having drawn examples helps with finding the patterns of how matrices work.</p><p>2 main options for solving: <em> Transpose (flip diagonally) and Reflect (left to right / top to bottom) </em> Rotate squares inside a matrix (Which I choose as it uses twice as less iterations)</p><p>Each matrix has n/2 (where n is a number of elements in a row) squares. We need to iterate through all the squares and swap elements at the corners of those squares.</p><img src="https://www.staskus.io/images/notes/f53df9570974ef456f0347b2fe8bb8e09876c4c0c4910f51a3fb2bfb42ffc5fb.png" alt="<a href="https://www.enjoyalgorithms.com/blog/rotate-a-matrix-by-90-degrees-in-an-anticlockwise-direction">picture 1</a>"/><p>After exchanging the upper layer, we move into inner layer circles (in larger matrices)</p><p>Example of turning the matrix 90 degrees</p><pre><code><span class="keyword">let</span> n = matrix.<span class="property">count</span>
        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="number">0</span>..&lt;n/<span class="number">2</span> {
    <span class="comment">// Going through elements in the layer. The deeper the layer, the less the elements</span>
    <span class="keyword">for</span> pos <span class="keyword">in</span> layer..&lt;n-<span class="number">1</span>-layer {
        <span class="keyword">let</span> temp = matrix[layer][pos]
        matrix[layer][pos] = matrix[n-<span class="number">1</span>-pos][layer]
        matrix[n-<span class="number">1</span>-pos][layer] = matrix[n-<span class="number">1</span>-layer][n-<span class="number">1</span>-pos]
        matrix[n-<span class="number">1</span>-layer][n-<span class="number">1</span>-pos] = matrix[pos][n-<span class="number">1</span>-layer]
        matrix[pos][n-<span class="number">1</span>-layer] = temp
    }
}
</code></pre><h2>Zero Matrix</h2><p>If the element is 0, its entire row and column should be zero.</p><p>In such a task optimal solution is using constant space, meaning changing matrix in place. The challenge is coming up with the flag to notify which rows and columns need to be turned to zeros. Usually, we can set flags at the beginning of rows and columns and iterate through the matrix 2 times.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Big0</guid><title>Big O</title><description></description><link>https://www.staskus.io/notes/Big0</link><pubDate>Thu, 24 Mar 2022 11:45:46 +0200</pubDate><content:encoded><![CDATA[<p>Big O describes the efficiency of algorithms.</p><h2>Time Complexity</h2><h2>Space Complexity</h2><p>Space complexity is the amount of memory required by an algorithm.</p><h3>Recursive calls</h3><p>In recursive functions, each call is added to the stack and we take this space into account.</p><h2>Cases</h2><ul><li>Best Case</li><li>Worst Case</li><li>Expected Case</li></ul><p>The best case is not insightful. The expected case and the worst case are usually the same but not always.</p><h2>Simplification</h2><p>Big O is only concerned about the <em>rate of increase</em> and expressed how the runtime scales, thus we can drop the constants and non-dominant terms. O(2N) is just O(N).</p><ul><li>O(N$^2$ + N) is O($N^2$)</li><li>O(N + log N) is O(N)</li><li>O(100*2$^2$ + 5000N$^2$) is O(2$^n$)</li></ul><img src="https://www.staskus.io/images/notes/42d971b30d15ec5efd2f8e1238e39424451afd922a0d719fa83811f80aeaf160.png" alt="Complexities - GeeksForGeeks.org"/><p>However, have in mind that it's usually not possible to remove <em>multiple variables</em>, they still need to be represented in the notation.</p><p>For example, to sort an array of sorted strings the complexity would be <em>O($a</em>s$(log a + log s))*, where a - array length, s - longest string length. In such cases, we cannot simplify much further.</p><h3>O(n)</h3><p>The algorithm that reverses an array only going through half of the array does not impact big O time and still has O(n) time complexity.</p><h3>O(log N)</h3><p>An algorithm will likely have an O(log N) runtime when the number of elements in the problem space gets halved at every step. Example - binary search.</p><h3>O(2$^n$)</h3><p>The base of an exponential complexity matters.</p><h3>O(2$^l$$^o$$^g$$^N$)</h3><p>This expression can be simplified to O(n). If we search binary tree making recursive calls the depth is roughly logN so it doesn't turn the recursive function exponential.</p><h2>Memoization</h2><p>Caching previously computed values is an optimization technique called memoization. It is a very common way to optimize exponential time recursive algorithms.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Linked%20Lists</guid><title>Linked Lists</title><description></description><link>https://www.staskus.io/notes/Linked%20Lists</link><pubDate>Thu, 24 Mar 2022 11:45:43 +0200</pubDate><content:encoded><![CDATA[<p>In a linked list, each node points to the next node in the linked list. In a doubly-linked-list, each node also points to the previous node.</p><p>The benefit of a linked list is that items are added and removed in constant time.</p><h2>The Runner Technique</h2><p>Iterate through the linked list with two pointers simultaneously, one going faster than the other.</p><h2>Recursion</h2><p>Many linked list problems are solved with recursion. The only caveat is that it takes at least O(n) space.</p><h2>Example tasks to know how to solve:</h2><h3>Remove nth element from the end</h3><p>We could use the 2 runner technique to solve this issue. We can have one pointer always nth the elements behind it. When the first pointer reaches the end, we have a second pointer point to the nth element from the end that we need to remove.</p><h3>Partition a linked list by value</h3><p>It could be done by creating 2 linked lists one with values larger than the given value and the other one with smaller values and in the end, merging those lists.</p><h3>Check if singly-linked-list values construct a palindrome</h3><p>To do this in place with O(1) space complexity we need to work directly on the list.</p><ul><li>Using the runner technique: fast and slow pointers. When the fast reaches the end, the slow reaches the middle</li><li>Reverse the linked list from the middle</li><li>Compare values one by one, from the start and the middle</li></ul><h3>Find the intersection of two linked lists</h3><ul><li>A medium solution would be to put nodes into a hashtable and compare</li><li>The best solution is to calculate the lengths of two linked lists and then compare the nodes at the same starting point</li></ul><p>Here's a clever way to find an intersection. The trick is to set the value of one of the current nodes to the head of the other list when the end is reached:</p><pre><code>     <span class="keyword">func</span> getIntersectionNode(<span class="keyword">_</span> headA: <span class="type">ListNode</span>?, <span class="keyword">_</span> headB: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? { 
        <span class="keyword">var</span> currentA = headA
        <span class="keyword">var</span> currentB = headB
        
        <span class="keyword">while</span> currentA !== <span class="call">currentB</span> {
            currentA = currentA == <span class="keyword">nil</span> ? headB : currentA?.<span class="property">next</span>
            currentB = currentB == <span class="keyword">nil</span> ? headA : currentB?.<span class="property">next</span>
        }
        
        <span class="keyword">return</span> currentA
    }
</code></pre><h3>Detecting a loop in a linked list</h3><ul><li>A medium solution putting nodes into a hashtable (set). Have in mind that in Swift nodes have to be <code>Hashable</code> or simply wrapped in the <code>ObjectIdentifier</code> so we would compare references</li><li>The best solution is to detect a loop using the runner technique. If there's a loop, they will eventually meet. The harder part to understand is finding <strong>the start of the loop</strong>. It will be exactly between the <em>head</em> and the <em>collision</em> point. Therefore going step by step from the <em>head</em> and the <em>collision</em> the next collision will happen at <em>the start of the loop</em>.</li></ul><pre><code>   <span class="keyword">func</span> colissionNode(<span class="keyword">_</span> head: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? {
        <span class="keyword">var</span> slow = head
        <span class="keyword">var</span> fast = head
        
        <span class="keyword">while</span> fast?.<span class="property">next</span> != <span class="keyword">nil</span> {
            slow = slow?.<span class="property">next</span>
            fast = fast?.<span class="property">next</span>?.<span class="property">next</span>
            
            <span class="keyword">if</span> slow === fast {
                <span class="keyword">return</span> slow
            }
        }
        
        <span class="keyword">return nil</span>
    }
</code></pre><p>If we do the math we can see that F = b, therefore going step by step from the start and from the point h we will reach the start of the loop: <img src="https://www.staskus.io/images/notes/67ea9a4463080be07ce89fc92ba437d53482bdce56217f6ff1ffe17e021bf200.png" alt="LeetCode.com"/></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/notes/Strategy</guid><title>A problem-solving flow</title><description></description><link>https://www.staskus.io/notes/Strategy</link><pubDate>Tue, 22 Mar 2022 21:42:40 +0200</pubDate><content:encoded><![CDATA[<h2>A problem-solving flow</h2><ol><li>Listen and clarify the question. Write down the important bits of information.</li><li>Go through the examples and create your own example. Draw if possible.</li><li>State a brute-force solution and its time &amp; space complexities</li><li>Optimize<ol><li>Look for bottlenecks, unnecessary work, and duplicated work</li><li>Maybe there are unused bits of information from the description?</li><li>Try going through the solution with different examples</li><li>Try to solve with simplest example and make it bit by bit more complex</li><li>Make time vs space tradeoff</li><li>Computing some values (like sorting) upfront</li><li>Brainstorm all the possible data structures</li><li>Think about the best possible runtime and then how to achieve it</li><li>Walkthrough the approach in detail</li><li>Implement keeping coding standards in mind</li><li>Test</li><li>Code review</li><li>Small test cases</li><li>Special cases and edge cases</li></ol></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-06-23-app-clip</guid><title>App Clips: A first glance at the new way to access an iOS app</title><description></description><link>https://www.staskus.io/posts/2020-06-23-app-clip</link><pubDate>Tue, 23 Jun 2020 18:00:00 +0300</pubDate><content:encoded><![CDATA[<p>During <a href="https://developer.apple.com/wwdc20/">WWDC20</a> Apple is introducing new <a href="https://developer.apple.com/app-clips/">App Clips</a> feature. As it's described in the landing page:</p><blockquote><p>An app clip is a small part of your app that‚Äôs discoverable at the moment it‚Äôs needed.</p></blockquote><p>Apple already suggested some possible use cases such as ordering from a take-out restaurant or renting a scooter. And App Clips will be discovered and invoked by using new App Clip Codes, NFC Tags, QR Codes, Messages, or as place cards in Maps.</p><p>It looks like a great move forward in reducing friction and getting an app into users' hands as fast as possible.</p><p>We'll take a look at the initial steps of how these App Clips could be implemented and introduced in the project.</p><h1>Prerequisites</h1><p>Xcode 12 or higher.</p><h1>Getting Started</h1><p>We start by creating a new project and selecting the creation of a new target.</p><img src="https://www.staskus.io/images/app-clip/new_target.png" alt="App Clip New Target" width="600"/><p>We select a new App Clip target and add it to our application.</p><img src="https://www.staskus.io/images/app-clip/new_target_app_clip.png" alt="App Clip New Target" width="600"/><h1>Add Associated Domain</h1><p>We need to provide an associated domain for both App and App Clip targets. If App is not installed the link will open App Clip. Otherwise full App will be opened instead.</p><p>We do it by selecting <em>Target -&gt; Signing &amp; Capabilities</em>, clicking + sign, and choosing Associated Domains.</p><img src="https://www.staskus.io/images/app-clip/associated_domains.png" alt="Creating Associated Domain" width="600"/><p>Next, we enter our associated domain value which must follow pattern of <em>appclips:domain</em>. In this instance, we can enter <em>appclips:example.com</em>.</p><img src="https://www.staskus.io/images/app-clip/associated_domains_example.png" alt="Associated Domains Example" width="600"/><h1>Running App Clip target</h1><p>App Clip target can be run and debugged just like an App target.</p><p>We can open <code>ContentView.swift</code> inside an App Clip target, make changes, and run.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello, App Clip!"</span>).<span class="call">padding</span>()
    }
}
</code></pre><img src="https://www.staskus.io/images/app-clip/hello_app_clip.png" alt="Hello App Clip Simulator Screen" width="300"/><h1>Configuring App Clip</h1><p>App Clip is invoked via URL which can contain context-related information and be used in the configuration.</p><p>Let's say we want to provide a user with a more personalized greeting message after App Clip was invoked. We can pass binding <code>name</code> variable to <code>ContentView</code>.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@Binding var</span> name: <span class="type">String</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello,</span> \(name)<span class="string">"</span>).<span class="call">padding</span>()
    }
}
</code></pre><p>This example uses a new App lifecycle in SwiftUI which enables entire apps to be written completely in SwiftUI.</p><p>Information about invocation is passed through lifecycle events. We can use <code>onContinueUserActivity</code> to be notified about App Clip being launched with parameters.</p><p>More information about using legacy lifecycles can be found on <a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Access the Invocation URL section</a>.</p><p>After that, we take the incoming URL and its first path component. Now first path parameter passed through URL will be set as a name.</p><pre><code><span class="keyword">@main
struct</span> AppClipSneakPeekClipApp: <span class="type">App</span> {
    <span class="keyword">@State var</span> name = <span class="string">""</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> {
        <span class="type">WindowGroup</span> {
            <span class="type">ContentView</span>(name: $name).<span class="call">onContinueUserActivity</span>(<span class="type">NSUserActivityTypeBrowsingWeb</span>, perform: respondTo)
        }
    }

    <span class="keyword">func</span> respondTo(<span class="keyword">_</span> activity: <span class="type">NSUserActivity</span>?) {
        <span class="keyword">guard let</span> name = <span class="call">firstParameterValue</span>(from: activity) <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="keyword">self</span>.<span class="property">name</span> = name
    }

    <span class="keyword">private func</span> firstParameterValue(from activity: <span class="type">NSUserActivity</span>?) -&gt; <span class="type">String</span>? {
        <span class="comment">// Parsing components from URL</span>
        <span class="keyword">guard let</span> activity = activity <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        <span class="keyword">guard let</span> incomingURL = activity.<span class="property">webpageURL</span> <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        <span class="keyword">guard let</span> components = <span class="type">NSURLComponents</span>(url: incomingURL, resolvingAgainstBaseURL: <span class="keyword">true</span>) <span class="keyword">else</span> { <span class="keyword">return nil</span> }

        <span class="comment">// Taking first parameter: example.com/?parameter=Lisa</span>
        <span class="keyword">return</span> components.<span class="property">queryItems</span>?.<span class="property">first</span>?.<span class="property">value</span>
    }
}
</code></pre><h1>Testing</h1><p>Launching AppClip target now does not show any name value. It makes sense as we didn't pass any URL with parameters to our app.</p><p>We can automatically test it by providing <em>Environment Variable</em> for App Clip scheme. It can be done by selecting <code>App Clip scheme -&gt; Edit Scheme -&gt; Run</code> and set the value of <em>_XCAppClipURL</em> of test URL value. We set it to <em>https://example.com/?parameter=Lisa</em> to have a first parameter value.</p><img src="https://www.staskus.io/images/app-clip/testing.png" alt="Adding Environment Variable" width="600"/><p>If we launch the application now, the value is received through lifecycle event and updated inside a view.</p><img src="https://www.staskus.io/images/app-clip/testing_success.png" alt="iOS Simulator with result" width="300"/><h2>What about App Clip Card?</h2><p>App Clip Card itself that is shown with a suggestion to open an App Card is not developed through Xcode. The information displayed in this card can be configured through <a href="https://appstoreconnect.apple.com/login">App Store Connect</a>. Developers will be able to change a header image, subtitle, and title on the action button.</p><h1>Where do we go from here?</h1><p>App Clip looks like a promising addition to the ecosystem and it will be interesting to see how it will be used and adopted by both developers and users.</p><p>The example project can be found on <a href="https://github.com/nitesuit/AppClipSneakPeekApp">GitHub</a>.</p><p>Apple provides a lot of helpful resources for going more in-depth into App Clips.</p><ul><li><a href="https://developer.apple.com/documentation/app_clips">Developing a Great App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/creating_an_app_clip">Creating an App Clip</a></li><li><a href="https://developer.apple.com/documentation/app_clips/responding_to_invocations">Responding to Invocation</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Configuring Your App Clip‚Äôs Launch Experience</a></li><li><a href="https://developer.apple.com/documentation/app_clips/configuring_your_app_clip_s_launch_experience">Testing Your App Clip‚Äôs Launch Experience</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2020-01-26-publish</guid><title>Migrating from Jekyll to Publish: A site generator for Swift developers</title><description></description><link>https://www.staskus.io/posts/2020-01-26-publish</link><pubDate>Sun, 26 Jan 2020 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/JohnSundell/Publish">Publish</a> is a static site generator built for Swift developers. We'll be migrating a static blog generation from <a href="https://jekyllrb.com">Jekyll</a> to Publish. The previous version of a blog was generated using Jekyll and a provided theme without putting too much effort in understanding the whole creation process. This time I decided to dig deeper into understanding Publish and remembering long forgotten <em>HTML</em> and <em>CSS</em> skills.</p><p>We'll be trying to create a similar style blog that was created using Jekyll. It should remain adaptable for bigger or smaller screen sizes:</p><h4>Previous desktop version</h4><img src="https://www.staskus.io/images/publish/previous_1.png" alt="Previous desktop version of a blog" width="500"/><h4>Previous mobile version</h4><img src="https://www.staskus.io/images/publish/previous_2.png" alt="Previous mobile version of a blog" width="300"/><h1>Getting Started</h1><p>After running the steps described in a <a href="https://github.com/JohnSundell/Publish">Publish repository</a> we end up with a sample project that showcases the main parts and features of Publish.</p><p>In the folder structure we can see <code>posts</code> folder that contains an example post. I copy-pasted my blog posts <code>.md</code> files from old Jekyll blog to see if it works. We only need to change couple fields to make it work. The only difference is a metadata format on top of <code>.md</code> file. By removing quotes from strings, brackets from arrays and renaming categories to tags we can get Jekyll articles immediately generated into a new blog.</p><img src="https://www.staskus.io/images/publish/blog_1.png" alt="Previous desktop version of a blog" width="500"/><h1>Website</h1><p>If we open up <code>main.swift</code> file we see:</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>In Publish a website is a simple Swift struct that should contain mandatory fields required by a <code>Website</code> protocol as well as any additional fields that might be needed.</p><p>As this blog contains personal information as well as links to social media accounts, I included them in a <code>Blog</code> structure.</p><pre><code><span class="keyword">struct</span> Blog: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> posts
        <span class="keyword">case</span> about
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
    	<span class="comment">// Additional field in post .md metadata</span>
        <span class="keyword">var</span> excerpt: <span class="type">String</span>
    }

    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.staskus.io"</span>)!
    <span class="keyword">var</span> title = <span class="string">"staskus.io"</span>
    <span class="keyword">var</span> name = <span class="string">"Povilas Sta≈°kus"</span>
    <span class="keyword">var</span> description = <span class="string">"iOS Developer"</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="keyword">nil</span> }
    <span class="keyword">var</span> socialMediaLinks: [<span class="type">SocialMediaLink</span>] { [.<span class="dotAccess">location</span>, .<span class="dotAccess">email</span>, .<span class="dotAccess">linkedIn</span>, .<span class="dotAccess">github</span>, .<span class="dotAccess">twitter</span>] }
}
</code></pre><h1>Theme</h1><p>Basic <code>foundation</code> theme is used after generating a website for the first time. However, it's only there to give an example of how custom site theme should be created.</p><p>A <code>Theme</code> is built by conforming to <code>HTMLFactory</code> protocol.</p><p>Not all the pages are needed to be created for your site to be fully functioning. For a blog we must have: 1) an index page, that shows header, sidebar and list of posts. 2) item page, that will show full post.</p><pre><code><span class="keyword">class</span> BlogHTMLFactory: <span class="type">HTMLFactory</span> {

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>,
                       context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of an Index Page</span>
    }

    <span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Section</span>&lt;<span class="type">Site</span>&gt;,
                         context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Section Index Page that displays section items</span>
    }

    <span class="keyword">func</span> makeItemHTML(for item: <span class="type">Item</span>&lt;<span class="type">Site</span>&gt;,
                      context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Post Page</span>
    }

    <span class="keyword">func</span> makePageHTML(for page: <span class="type">Page</span>,
                      context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="comment">// Returning HTML of a Section Page</span> 
    }

    <span class="keyword">func</span> makeTagListHTML(for page: <span class="type">TagListPage</span>,
                         context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    	<span class="comment">// Returning HTML of a Page with list of available tags</span>
    }

    <span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">TagDetailsPage</span>,
                            context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    	<span class="comment">// Returning HTML of a Page for a specific tag</span>
    }
}
</code></pre><p>Although we can write <code>HTML</code> code using Swift, the styling of the site is done using <code>CSS.</code> For the creation of this blog, I decided to use <a href="https://purecss.io">Pure.css</a>. The desired blog theme is quite minimalist and the features that <a href="https://purecss.io">Pure.css</a> provides seem more than enough to achieve what we want. Even after many years without any <code>CSS</code> and <code>HTML</code> experience it was possible to make pretty decent layout. For the rest of this article, we won't be focusing on that. The code can be found on <a href="https://github.com/nitesuit/Blog">GitHub</a> for those who are interested.</p><h2>Index Page</h2><p><code>makeIndexHTML</code> builds HTML of an index page. The structure is the same as writing plain HTML tags. We set <em>language</em>, <em>head</em> and then structure layout inside <em>body</em>.</p><p>Body uses <code>.grid</code> node that creates Pure.css grid in which we can structure our layout. We have <code>.header</code>, <code>.sidebar</code>, <code>.posts</code> and <code>.footer</code> that are put one after the other.</p><pre><code><span class="keyword">class</span> BlogHTMLFactory: <span class="type">HTMLFactory</span> {

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>,
                       context: <span class="type">PublishingContext</span>&lt;<span class="type">Blog</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    	<span class="type">HTML</span>(
            .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
            .<span class="call">head</span>(for: context.<span class="property">site</span>),
            .<span class="call">body</span>(
                .<span class="call">grid</span>(
                    .<span class="call">header</span>(for: context.<span class="property">site</span>),
                    .<span class="call">sidebar</span>(for: context.<span class="property">site</span>),
                    .<span class="call">posts</span>(
                        for: context.<span class="call">allItems</span>(
                            sortedBy: \.<span class="property">date</span>,
                            order: .<span class="dotAccess">descending</span>
                        ),
                        on: context.<span class="property">site</span>,
                        title: <span class="string">"Recent posts"</span>
                    ),
                    .<span class="call">footer</span>(for: context.<span class="property">site</span>)
                )
            )
        )
    }
}
</code></pre><p>Any node can be written as a <code>static</code> func extension of a <code>Node</code>. <code>Context == HTML.BodyContext</code> indicate that this node can be only used inside <em>body</em>. It's a nice and clean way to declare new nodes, as they can be then used using dot syntax.</p><pre><code><span class="keyword">extension</span> <span class="type">Node</span> <span class="keyword">where</span> <span class="type">Context</span> == <span class="type">HTML</span>.<span class="type">BodyContext</span> {
    <span class="keyword">static func</span> grid(<span class="keyword">_</span> nodes: <span class="type">Node</span>...) -&gt; <span class="type">Node</span> {
        .<span class="call">div</span>(
            .<span class="call">id</span>(<span class="string">"layout"</span>),
            .<span class="call">class</span>(<span class="string">"pure-g"</span>),
            .<span class="call">group</span>(nodes)
        )
    }
}
</code></pre><h2>Post</h2><p>A post can be declared the same way as any other node. On the top, we show the title of the post. Below, we show date. We can use any powerful features that Swift infrastructure provides us. In this instance, we use <code>DateFormatter</code> to format a date. In a similar way any more complex or sophisticated logic could be used inside this code.</p><pre><code><span class="keyword">extension</span> <span class="type">Node</span> <span class="keyword">where</span> <span class="type">Context</span> == <span class="type">HTML</span>.<span class="type">BodyContext</span> {
    <span class="keyword">static func</span> post(for item: <span class="type">Item</span>&lt;<span class="type">Blog</span>&gt;, on site: <span class="type">Blog</span>) -&gt; <span class="type">Node</span> {
        <span class="keyword">return</span> .<span class="call">pageContent</span>(
            .<span class="call">h2</span>(
                .<span class="call">class</span>(<span class="string">"post-title"</span>),
                .<span class="call">a</span>(
                    .<span class="call">href</span>(item.<span class="property">path</span>),
                    .<span class="call">text</span>(item.<span class="property">title</span>)
                )
            ),
            .<span class="call">p</span>(
                .<span class="call">class</span>(<span class="string">"post-meta"</span>),
                .<span class="call">text</span>(<span class="type">DateFormatter</span>.<span class="property">blog</span>.<span class="call">string</span>(from: item.<span class="property">date</span>))
            ),
            .<span class="call">tagList</span>(for: item, on: site),
            .<span class="call">div</span>(
                .<span class="call">class</span>(<span class="string">"post-description"</span>),
                .<span class="call">div</span>(
                    .<span class="call">contentBody</span>(item.<span class="property">body</span>)
                )
            )
        )
    }
}
</code></pre><h2>Finishing the theme</h2><p>We can make our theme accessible by creating <code>Theme</code> object and passing our <code>BlogHTMLFactory</code>. Declaring it as a <em>static var</em> inside an extension allows reaching it more conveniently.</p><pre><code><span class="keyword">extension</span> <span class="type">Theme</span> <span class="keyword">where</span> <span class="type">Site</span> == <span class="type">Blog</span> {
    <span class="keyword">static var</span> blog: <span class="type">Self</span> {
        <span class="type">Theme</span>(htmlFactory: <span class="type">BlogHTMLFactory</span>())
    }
}
</code></pre><h1>Generating the site</h1><p>We've seen how by creating nodes we can step by step create pages for our blog. However, I would argue that the biggest power of Publish comes from <code>plugins</code> and additional building steps that we can create or use.</p><p><a href="https://github.com/JohnSundell/Splash">Splash</a> is a Swift syntax highlighter for blogs that has a plugin built for Publish. During the blog generation process, this plugin uses markdown parser to identify code inside <code>.md</code> files and apply syntax highlighting.</p><p>We can use or build any steps that might do additional checks, append necessary information or simply tweak a site in any way needed.</p><pre><code><span class="keyword">import</span> SplashPublishPlugin

<span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">blog</span>,
    additionalSteps: [.<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"nitesuit/nitesuit.github.io"</span>))],
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><h1>Result</h1><p>Publish worked seamlessly during development process. It provided all the convenience of Swift strong type system and helped stay focused while trying to figure unfamiliar web development workflows. Although Publish still misses many features that established static site generators have, it serves perfectly for its intended audience - Swift developers. Now that all the parts of the site are well understood, Publish together with Swift gives a lot of power for future improvements.</p><p>The code of the blog can be found on <a href="https://github.com/nitesuit/Blog">GitHub</a>.</p><h4>New desktop version</h4><img src="https://www.staskus.io/images/publish/blog_new_2.png" alt="New desktop version of a blog" width="500"/><h4>New mobile version</h4><img src="https://www.staskus.io/images/publish/blog_new_1.png" alt="New mobile version of a blog" width="300"/>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</guid><title>Building a real-world iOS app (Part 5): Using Clean Swift for developing testable and scalable views</title><description></description><link>https://www.staskus.io/posts/2019-03-24-aerogami_series_part_5</link><pubDate>Sun, 24 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When starting to develop any application it's beneficial to think early about the way code can be testable and whether it would be scalable or maintainable. Many iOS applications have suffered from what is called <em>Massive View Controller</em> problem. By putting all the code that fetches, maps, presents and styles into one ViewController it very quickly overgrows in size and complexity. A lot of solutions where introduced to tackle this problem such as MVVM, MVVM + ReactiveCocoa or VIPER. In this application we'll be using <a href="https://clean-swift.com">Clean Swift</a> approach for breaking up massive view controllers into testable and maintainable parts.</p><h1>Data Structures</h1><h2>Data</h2><p><code>Struct</code> containing <em>raw data</em>.</p><pre><code>     <span class="keyword">struct</span> Data: <span class="type">Equatable</span> {
        <span class="keyword">let</span> regions: [<span class="type">Region</span>]
        <span class="keyword">let</span> trips: [<span class="type">Trip</span>]
    }
</code></pre><h2>View Model</h2><p><code>Struct</code> containing <em>State</em> (loading, error, empty, loaded) and mapped data that is used by <em>View Controllers</em> for configuring views.</p><pre><code>     <span class="keyword">struct</span> ViewModel: <span class="type">FeatureViewModel</span> {
        <span class="keyword">let</span> state: <span class="type">ViewState</span>&lt;<span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>&gt;
        <span class="keyword">let</span> title: <span class="type">String</span>

        <span class="keyword">struct</span> Content: <span class="type">FeatureContentViewModel</span>, <span class="type">Equatable</span> {
            <span class="keyword">var</span> rows: [<span class="type">FeedCardViewModel</span>]
            <span class="keyword">let</span> availableRegions: [<span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>.<span class="type">Region</span>]
            <span class="keyword">let</span> selectedRegion: <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>.<span class="type">Region</span>?

            <span class="keyword">struct</span> Region: <span class="type">Equatable</span> {
                <span class="keyword">let</span> id: <span class="type">String</span>
                <span class="keyword">let</span> name: <span class="type">String</span>
            }

            <span class="keyword">var</span> hasContent: <span class="type">Bool</span> {
                <span class="keyword">return</span> !rows.<span class="property">isEmpty</span>
            }
        }
    }
</code></pre><h2>Action</h2><p><code>Enum</code> with actions that <em>View Controller</em> can do and <em>Interactor</em> can handle.</p><pre><code>     <span class="keyword">enum</span> Action {
        <span class="keyword">case</span> load
        <span class="keyword">case</span> changeRegion(regionId: <span class="type">String</span>?)
    }
</code></pre><h2>Route</h2><p><code>Enum</code> with destinations that <em>View Controller</em> can route to.</p><pre><code>     <span class="keyword">enum</span> Route: <span class="type">Equatable</span> {
        <span class="keyword">case</span> book(<span class="type">Trip</span>)
    }
</code></pre><h1>Components</h1><h2>Interactor</h2><p>Receives an action, performs work and sends raw data to presenter.</p><ul><li>Input - <em>Action</em></li><li>Output - <em>Data</em></li><li>Uses - <em>Presenter</em></li></ul><h2>Presenter</h2><p>Receives raw data and maps it into <em>View Model</em></p><ul><li>Input - <em>Data</em></li><li>Output - <em>View Model</em></li></ul><h2>View Controller</h2><p>Receives <em>View Model</em> and configures a view according to it. Sends actions to <em>Interactor</em>.</p><ul><li>Input - <em>View Model</em></li><li>Output - <em>Action</em></li><li>Uses - <em>Interactor</em>, <em>Router</em></li></ul><h2>Router</h2><p>Receives <em>Route</em> object from <em>View Controller</em>, that contains information about next destination, and opens next <em>View Controller</em> using <em>Configurator</em></p><ul><li>Input - <em>Route</em></li><li>Uses - <em>Configurator</em></li></ul><h2>Configurator</h2><p>Takes an input and creates configured <em>View Controller</em> with other components.</p><ul><li>Input - Optional configuration data.</li><li>Output - <em>View Controller</em></li><li>Creates - <em>Interactor</em>, <em>Presenter</em>, <em>View Controller</em>, <em>Router</em></li></ul><h1>Feature</h1><p>The group of these components is called <code>Feature</code>. <a href="https://clean-swift.com">Clean Swift</a> provides with XCode templates that allow to generate all of these components together. We are using <a href="https://github.com/nitesuit/aerogami-ios/tree/master/templates/plop/Feature">plop templates</a> for feature generation. All of this allows to avoid writing boilerplate code and concentrate on actual code of the feature.</p><h1>Feed Example</h1><p><code>Feed</code> is a main <a href="https://github.com/nitesuit/aerogami-ios/tree/master/TravelFeatureKit/Features/Feed">feature</a> of the application. We're going to see how all of these different components is used to create a complete feature.</p><h2>Feed Interactor</h2><p><code>Feed Interactor</code> uses repositories of <em>Region</em>, <em>Trip</em> and <em>Airport</em> for loading data.</p><p><code>dispatch</code> function is an entry point of any <code>Interactor</code>.</p><pre><code>     <span class="keyword">func</span> dispatch(<span class="keyword">_</span> action: <span class="type">Feed</span>.<span class="type">Action</span>) {
        <span class="keyword">switch</span> action {
        <span class="keyword">case</span> .<span class="dotAccess">load</span>:
            contentState = .<span class="call">loading</span>(data: contentState.<span class="property">data</span>)
            <span class="call">load</span>()
        <span class="keyword">case</span> .<span class="dotAccess">changeRegion</span>(<span class="keyword">let</span> regionId):
            <span class="call">changeRegion</span>(id: regionId)
        }
    }
</code></pre><p>We can see when <code>FeedInteractor</code> receives <em>load</em> action it sets current state to <em>loading</em> and calls <code>load()</code> method. It combines <code>RegionRepository</code> and <code>TripRepository</code>, maps it to <em>Data</em> object and passes it to <code>FeedPresenter</code> by setting <em>contentState</em>.</p><pre><code>     <span class="keyword">func</span> load() {
        <span class="keyword">let</span> selectedRegion = regionRepository.<span class="call">getSelectedRegion</span>()

        <span class="type">Observable</span>.<span class="call">combineLatest</span>(
            <span class="keyword">self</span>.<span class="property">regionRepository</span>.<span class="call">getRegions</span>(),
            <span class="keyword">self</span>.<span class="property">tripRepository</span>.<span class="call">getTrips</span>(in: selectedRegion?.<span class="property">id</span>)
            )
            .<span class="call">map</span> { (regions, trips) -&gt; <span class="type">Feed</span>.<span class="type">Data</span> <span class="keyword">in
                return</span> <span class="type">Feed</span>.<span class="type">Data</span>(
                    regions: regions,
                    trips: trips,
                    selectedRegionId: selectedRegion?.<span class="property">id</span>,
                    tripImages: []
                )
            }
            .<span class="call">subscribe</span>(
                onNext: { data <span class="keyword">in
                    self</span>.<span class="property">contentState</span> = .<span class="call">loaded</span>(data: data, error: <span class="keyword">nil</span>)
                    <span class="keyword">self</span>.<span class="call">loadImages</span>(for: data.<span class="property">trips</span>)
                },
                onError: { error <span class="keyword">in
                    self</span>.<span class="property">contentState</span> = .<span class="call">error</span>(error: .<span class="call">loading</span>(reason: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">errorGenericTitle</span>()))
                }
            )
            .<span class="call">disposed</span>(by: disposeBag)
    }
</code></pre><h2>Feed Presenter</h2><p><a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelFeatureKit/Features/Feed/FeedPresenter.swift">Feed Presenter</a> essentially takes <code>Feed.Data</code> and returns <code>Feed.ViewModel</code>.</p><pre><code>     <span class="keyword">func</span> makeContentViewModel(content: <span class="type">Feed</span>.<span class="type">Data</span>) <span class="keyword">throws</span> -&gt; <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span> {
        <span class="keyword">return</span> <span class="type">Feed</span>.<span class="type">ViewModel</span>.<span class="type">Content</span>(
            rows: <span class="call">makeFeedCardRows</span>(content),
            availableRegions: <span class="call">makeAvailableRegions</span>(content),
            selectedRegion: <span class="call">makeSelectedRegion</span>(content)
        )
    }
</code></pre><p>We can see that <em>struct</em> such as <code>FeedCardViewModel</code> is fairly complicated and comprehensively describes for a table view row what needs to be displayed. It ensures that there is absolutely no business logic, mapping or formatting done in a view as it's simply sets these properties to appropriate variables.</p><pre><code>     <span class="keyword">private func</span> makeFeedCardRows(<span class="keyword">_</span> content: <span class="type">Feed</span>.<span class="type">Data</span>) -&gt; [<span class="type">FeedCardViewModel</span>] {
        <span class="keyword">return</span> <span class="call">getSortedTrips</span>(content).<span class="call">map</span> { trip <span class="keyword">in</span>
            currencyFormatter.<span class="property">currencyCode</span> = trip.<span class="property">currency</span>
            <span class="keyword">return</span> <span class="type">FeedCardViewModel</span>(
                direction: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">feedBothWaysTitle</span>(),
                trip: <span class="call">makeTripString</span>(trip),
                price: <span class="call">formatCurrency</span>(trip),
                dateRange: <span class="call">dateRange</span>(trip),
                routeName: <span class="type">R</span>.<span class="property">string</span>.<span class="property">localizable</span>.<span class="call">feedBookTitle</span>(),
                imageUrl: <span class="call">makeTripImageURL</span>(trip, content: content),
                route: <span class="type">Feed</span>.<span class="type">Route</span>.<span class="call">book</span>(trip),
                isExpired: trip.<span class="property">expiresAt</span> &lt;= <span class="type">Date</span>()
            )
        }
    }
</code></pre><h2>Feed View Controller</h2><p>View Controller in this architecture is a very lean and clean class. It does what view <em>should</em> do: present data, handle user actions and delegate these actions to 'interactor'.</p><p><em>display()</em> lets <code>FeedViewController</code> know that the state and <code>Feed.ViewModel</code> was updated. Different views then can use parts of view model to configure themselves.</p><pre><code>     <span class="keyword">func</span> display() {
        <span class="keyword">guard let</span> viewModel = viewModel?.<span class="property">state</span>.<span class="property">viewModel</span> <span class="keyword">else</span> { <span class="keyword">return</span> }

        tableView.<span class="call">reloadData</span>()
        headerView.<span class="call">configure</span>(with: viewModel.<span class="property">selectedRegion</span>)
    }
</code></pre><p><code>Feed.Action</code> is sent to <code>Feed.Interactor</code> when anything meaningful happens in <code>FeedViewController.</code> For example, loading data when view appears.</p><pre><code>     <span class="keyword">override func</span> viewWillAppear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
        <span class="keyword">super</span>.<span class="call">viewWillAppear</span>(animated)

        interactor.<span class="call">subscribe</span>()
        interactor.<span class="call">dispatch</span>(<span class="type">Feed</span>.<span class="type">Action</span>.<span class="property">load</span>)
    }
</code></pre><p><code>Feed.Route</code> is sent to <code>Feed.Router</code> when <code>FeedViewController</code> wants to transition to other view controller.</p><pre><code>     <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, didSelectRowAt indexPath: <span class="type">IndexPath</span>) {
        <span class="keyword">guard let</span> cellViewModel = viewModel?.<span class="property">state</span>.<span class="property">viewModel</span>?.<span class="property">rows</span>[indexPath.<span class="property">row</span>] <span class="keyword">else</span> { <span class="keyword">return</span> }

        router.<span class="call">route</span>(to: cellViewModel.<span class="property">route</span>)
    }
</code></pre><h2>Feed Router</h2><p><code>FeedRouter</code> handles <em>route</em> actions and opens other view controllers. It uses <code>BookTripConfigurator</code> for building <code>BookTripViewController</code>.</p><pre><code><span class="keyword">class</span> FeedRouter {

    <span class="keyword">private let</span> bookTripConfigurator: <span class="type">BookTripConfigurator</span>

    <span class="keyword">weak var</span> viewController: <span class="type">FeedViewController</span>?

    <span class="keyword">init</span>(bookTripConfigurator: <span class="type">BookTripConfigurator</span>) {
        <span class="keyword">self</span>.<span class="property">bookTripConfigurator</span> = bookTripConfigurator
    }

    <span class="keyword">func</span> route(to route: <span class="type">Feed</span>.<span class="type">Route</span>) {
        <span class="keyword">switch</span> route {
        <span class="keyword">case</span> .<span class="dotAccess">book</span>(<span class="keyword">let</span> trip):
            <span class="keyword">let</span> bookTripViewController = bookTripConfigurator.<span class="call">createViewController</span>(trip: trip)
            bookTripViewController.<span class="property">modalPresentationStyle</span> = .<span class="dotAccess">overCurrentContext</span>
            bookTripViewController.<span class="property">modalTransitionStyle</span> = .<span class="dotAccess">coverVertical</span>
            viewController?.<span class="property">tabBarController</span>?.<span class="call">present</span>(bookTripViewController, animated: <span class="keyword">true</span>, completion: <span class="keyword">nil</span>)
        }
    }
}
</code></pre><h2>Usage</h2><p>For understanding this flow easier we can imagine a hypothetical scenario of <code>Feed</code> feature.</p><ol><li>AppDelegate uses <code>FeedConfigurator</code> and calls <code>createViewController()</code> to create <code>FeedViewController</code></li><li><code>FeedViewController</code> on <code>viewWillAppear</code> calls <code>interactor.dispatch(Feed.Action.load)</code> to trigger <code>load</code> action</li><li><code>FeedInteractor</code> handles <code>load</code> action and uses <code>TripRepository</code> to load an array of <code>Trips</code> from the backend. It passes an array of <code>Trips</code> to <code>FeedPresenter</code>.</li><li><code>FeedPresenter</code> takes an array of <code>Trips</code> and maps it to <code>FeedViewModel</code> by formatting and localizing text, loading images and splitting it into fields that view needs to know about.</li><li><code>FeedViewController</code>'s method <code>display()</code> is triggered and table view is loaded with new data.</li></ol><p>Although this all may seem too much at first, it actually provides developers with huge clarity when building and maintaining the project. Moreover, all these different components have clear inputs and outputs than can be unit tested. With the growing complexity of the feature it becomes convenient to simply check <code>Action</code> to see all the different things that <code>ViewController</code> does or analyse <code>Presenter</code> to understand what kind of data is actually presented.</p><h2>Result</h2><p>In these series we've seen how to build iOS application by separating it into different frameworks, loading data from API and mapping it using <code>Codable</code>, sketching UIs following Apple's guidelines and develop it all on top of <em>Clean</em> architecture. All of these steps allow the app to be scalable, maintainable and testable.<br><br><img src="https://www.staskus.io/images/aerogami-tutorial/part5/app_demo.gif" alt="App Demo" width="300"/></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</guid><title>Building a real-world iOS app (Part 4): Design</title><description></description><link>https://www.staskus.io/posts/2019-03-20-aerogami_series_part_4</link><pubDate>Wed, 20 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>User experience (UX) and design is an integral part of any application. As a developer, I don't have much knowledge or "feeling" towards good looking designs. Moreover, truly great user experience requires many iterations of development and feedback. In this part we'll see how we can take example from Apple's mobile apps and design guidelines to create a familiar looking application.</p><h1>Colors</h1><p>We'll begin to design by choosing the color palette of our application. One of the best ways to ensure familiarity and simplicity of the app is to have consistent colors throughout the application. I found it a great advice to limit yourself to 1 or 2 colors.</p><p>There are a few tools online to generate color palettes so the colors would fit together nicely.</p><p>Chosen colors should be put in a common place so it could be easily accessible.</p><pre><code><span class="keyword">struct</span> Theme {
    <span class="keyword">static let</span> primary = <span class="type">UIColor</span>(red: <span class="number">255</span>/<span class="number">255</span>, green: <span class="number">82</span>/<span class="number">255</span>, blue: <span class="number">82</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
    <span class="keyword">static let</span> primaryLight = <span class="type">Theme</span>.<span class="property">primary</span>.<span class="call">withAlphaComponent</span>(<span class="number">0.9</span>)
    <span class="keyword">static let</span> backgroundColor = <span class="type">UIColor</span>(red: <span class="number">239</span>/<span class="number">255</span>, green: <span class="number">239</span>/<span class="number">255</span>, blue: <span class="number">244</span>/<span class="number">255</span>, alpha: <span class="number">1.0</span>)
}
</code></pre><h1>UI</h1><p>Apple provides great resources for getting started. <a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a> is a great starting point for understanding the thinking behind Apple's choices as well as their preferences. Users have certain expectations and habits when using any application and it's important not to distract them with an unexpected behavior.</p><p>We'll take the inspiration from already existing <em>AppStore</em> app. The main screen of this app has a feed that we want to display in our travel application as well.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_example.png" alt="App Scren Example" width="300"/><p>Apple also provides us with <a href="https://developer.apple.com/design/resources/">design resources</a> that contain <a href="https://www.sketch.com">Sketch</a> files with designs of already existing applications. When learning to sketch or design something, I found it really beneficial to have these in front of me.</p><p>After tweaking these screens and applying our color palette we can create the first version of our design.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_screen_real.png" alt="Feed Screen" width="300"/><p>It displays the essential information such as <em>origin</em>, <em>destination</em>, <em>dates</em> and <em>price</em>. We can also show images which provide visual information about the destination.</p><h1>App Icon</h1><p>Application icon is also a huge part of first impression of any application. We can use same given <a href="https://developer.apple.com/design/resources/">design resources</a> that include examples of created app icons.</p><p>We can use a little bit of imagination and tweak given icons on Sketch to give it a look of a travel or flight application.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.gif" alt="Making of App Icon" width="300"/><p>The resulting icon looks like this.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part4/app_icon.png" alt="App Icon" width="300"/><p>We can use <a href="https://makeappicon.com">makeappicon.com</a> to generate all the necessary sizes of the icon so it could be used for different screen sizes as well as on AppStore.</p><h1>What's next?</h1><p>We saw how it's possible to create a clean design of an application without having much knowledge or spending too much time. Especially for small side projects, it's important to concentrate on main functionality and simply use best practices and examples when creating UIs.</p><p>In the next part of the series we'll shift our attention back to the development of our application. We'll see the approach for creating new screens and keeping the view and its logic cleanly separated.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</guid><title>Building a real-world iOS app (Part 3): Fetching and parsing data from API</title><description></description><link>https://www.staskus.io/posts/2019-03-18-aerogami_series_part_3</link><pubDate>Mon, 18 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In the <a href="2019-03-17-aerogami_series_part_2">previous part</a> we discovered a way to separate our application into frameworks and setup the architecture of our app to support dependency injection. In this part of the series we'll be fetching and parsing data from the backend using Alamofire and Codable.</p><h1>API Client</h1><p>Although in the scope of this tutorial we'll be using mocked data, the application will be completely ready to support calls to REST APIs.</p><h3>Protocol</h3><p>We define our <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelAPIKit/APIClient.swift">APIClient</a> protocol that serves as a lean interface between data fetching classes and actual implementation.</p><pre><code><span class="keyword">import</span> RxSwift

<span class="keyword">public protocol</span> APIClient {
    <span class="keyword">func</span> get(path: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;
}
</code></pre><p>It returns <code>Observable&lt;Any&gt;</code> which is a part of <code>RxSwift</code>. We won't be going through the basics of <code>RxSwift</code>, so it's beneficial to take a look <a href="https://github.com/ReactiveX/RxSwift">official documentation</a> before continuing.</p><h3>Implementation</h3><p>The actual implementation is in <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">BaseAPIClient</a>, which uses <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> for making HTTP requests. The only method <code>get(path: String)</code> makes <code>GET</code> request by concating given path to a base URL.</p><pre><code><span class="keyword">import</span> RxAlamofire
<span class="keyword">import</span> RxSwift

<span class="keyword">public class</span> BaseAPIClient: <span class="type">APIClient</span> {
    <span class="keyword">private let</span> baseUrl: <span class="type">String</span>

    <span class="keyword">public init</span>(baseUrl: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">baseUrl</span> = baseUrl
    }

    <span class="keyword">public func</span> get(path: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt; {
        <span class="keyword">return</span> <span class="type">RxAlamofire</span>
            .<span class="call">requestJSON</span>(.<span class="dotAccess">get</span>, <span class="string">"</span>\(baseUrl)<span class="string">/</span>\(path)<span class="string">"</span>)
            .<span class="call">map</span> { $1 }
    }
}
</code></pre><h3>Mock</h3><p>If you clone the <a href="https://github.com/nitesuit/aerogami-ios">repository</a>, it will use <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelAPIKit/BaseAPIClient.swift">MockAPIClient</a> which takes data from files. Because it uses the same public interface, <code>MockAPIClient</code> and <code>BaseAPIClient</code> can be interchanged depending on needs. See <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelApplication/Application/Assembly/ApplicationAssembly.swift">ApplicationAssembly</a> which assigns dependencies for <code>APIClient</code> interface. Depending on different configuration, it can assign any of these two. This little example perfectly illustrates the power of <code>dependency injection</code> and usage of <code>protocols</code>.</p><h1>Data</h1><p>The main entity in this project is a <code>Trip</code>. It describes the origin and destination of the flight as well as price and dates.</p><pre><code>{
   <span class="string">"currency"</span>:<span class="string">"EUR"</span>,
   <span class="string">"created_at"</span>:<span class="number">1547991979887</span>,
   <span class="string">"airlines"</span>:<span class="string">"FR"</span>,
   <span class="string">"departure_at"</span>:<span class="number">1552848000000</span>,
   <span class="string">"destination"</span>:{
      <span class="string">"city"</span>:<span class="string">"Malaga"</span>,
      <span class="string">"country_code"</span>:<span class="string">"ES"</span>,
      <span class="string">"airport_code"</span>:<span class="string">"AGP"</span>
   },
   <span class="string">"flight_number"</span>:<span class="number">4048</span>,
   <span class="string">"departure"</span>:{
      <span class="string">"city"</span>:<span class="string">"Copenhagen"</span>,
      <span class="string">"country_code"</span>:<span class="string">"DK"</span>,
      <span class="string">"airport_code"</span>:<span class="string">"CPH"</span>
   },
   <span class="string">"return_at"</span>:<span class="number">1553153100000</span>,
   <span class="string">"price"</span>:<span class="number">72</span>,
   <span class="string">"id"</span>:<span class="string">"c4449ff0-1cb9-11e9-b9f8-b3ba95b35000"</span>,
   <span class="string">"expires_at"</span>:<span class="number">1739200281000</span>
}
</code></pre><p><a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelApplication/Application/Mocking/TripMock.json">See full Trips JSON file</a></p><p>We'll define our entities inside <code>TravelKit</code> framework. They should be made public, so they could be reached inside other frameworks. We'll use excellent <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> type that starting from Swift 4 provides a powerful and clean way to encode and decode data.</p><p>Take a look at <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelKit/Repositories/Trip/Trip.swift">Trip</a> class. We don't need to define keys of each values if they match. It's possible to define what naming strategies are used during decoding or encoding process. For example, <code>.convertFromSnakeCase</code> strategy, as its name suggests, converts keys from snake case and assigns values automatically if they match.</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">public struct</span> Trip: <span class="type">Codable</span>, <span class="type">Equatable</span> {
    <span class="keyword">public var</span> id: <span class="type">String</span> = <span class="string">""</span>
    <span class="keyword">public var</span> currency: <span class="type">String</span> = <span class="string">""</span>
    <span class="keyword">public var</span> price = <span class="number">0</span>

    <span class="keyword">public var</span> airlines = <span class="string">""</span>
    <span class="keyword">public var</span> flightNumber = <span class="number">0</span>

    <span class="keyword">public var</span> destination: <span class="type">TripLocation</span>!
    <span class="keyword">public var</span> departure: <span class="type">TripLocation</span>!

    <span class="keyword">public var</span> createdAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> departureAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> returnAt = <span class="type">Date</span>()
    <span class="keyword">public var</span> expiresAt = <span class="type">Date</span>()

    <span class="keyword">public init</span>() {}
}

<span class="keyword">public struct</span> TripLocation: <span class="type">Codable</span>, <span class="type">Equatable</span> {
    <span class="keyword">public var</span> city: <span class="type">String</span>!
    <span class="keyword">public var</span> countryCode: <span class="type">String</span>!
    <span class="keyword">public var</span> airportCode: <span class="type">String</span>!

    <span class="keyword">public init</span>() {}
}
</code></pre><p>After receiving <code>JSON</code> data we can define <code>decoder</code> and automatically parse values.</p><pre><code>     <span class="keyword">public static var</span> decoder: <span class="type">JSONDecoder</span> = {
        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()
        decoder.<span class="property">keyDecodingStrategy</span> = .<span class="dotAccess">convertFromSnakeCase</span>
        decoder.<span class="property">dateDecodingStrategy</span> = .<span class="dotAccess">millisecondsSince1970</span>
        <span class="keyword">return</span> decoder
    }()

    <span class="keyword">let</span> trips = <span class="keyword">try</span>? decoder.<span class="call">decode</span>([<span class="type">Trip</span>].<span class="keyword">self</span>, from: data)
</code></pre><p>With this simple and straightforward Codable API our data is cleanly parsed into statically typed object or array of objects after <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelDataKit/Repositories/Trip/Remote/APITripDataStore.swift">fetching from API</a>.</p><h1>Repositories</h1><p>Classes that are used to fetch data will be called repositories. In <code>TravelKit</code> we'll only define the protocols of these repositories. Our UI framework <code>TravelFeatureKit</code> will only know about <code>TravelKit</code> and protocols of repositories thus the implementations, defined in <code>TravelDataKit</code>, will be easily changeable.</p><p>Our <code>TripRepository</code> protocol defines the only way to fetch trips.</p><pre><code><span class="keyword">import</span> RxSwift

<span class="keyword">public protocol</span> TripRepository {
    <span class="keyword">func</span> getTrips(in region: <span class="type">String</span>?) -&gt; <span class="type">Observable</span>&lt;[<span class="type">Trip</span>]&gt;
}
</code></pre><p>Because our UI framework will only know about this protocol, we will be able to provide different types of implementations. <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/TripRepository.swift">TripRepository</a> implementation defined in <code>TravelDataKit</code> calls the <code>API</code> to fetch data and parses it using <code>Coadable</code>. However, <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelDataKit/Repositories/Trip/FavoriteTripRepository.swift">FavoriteTripRepository</a> which also implements <code>TripRepository</code> interface, uses <code>UserDefaults</code> to fetch locally liked <code>Trips</code>. It allows us to generate 2 completely different screens in our app. One showing the current feed of flights fetched from the API and another of liked and locally saved trips. Here <a href="https://github.com/nitesuit/aerogami-ios/blob/bd558d5962e7d97300213ad6896ff8d1f548a074/TravelFeatureKit/Features/Favorites/FavoritesAssembly.swift">FavoritesAssembly</a> simply injects necessary dependencies needed for <em>favorites</em> to a <code>FavoriteFeed</code> feature.</p><h1>Design</h1><p>Before continuing creating the app, we'll see how we can quickly create simple application designs using Sketch or similar tools. In the next part of the series we'll overview the approach.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</guid><title>Building a real-world iOS app (Part 2): Separating application into frameworks</title><description></description><link>https://www.staskus.io/posts/2019-03-17-aerogami_series_part_2</link><pubDate>Sun, 17 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>In this part of the series we'll overview how to properly setup the application.</p><h1>Creating Frameworks</h1><p>As we talked in the <a href="https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1">previous part</a>, we'll begin the creation of the project by creating 3 separate frameworks inside our XCode project (<code>TravelKit</code>, <code>TravelDataKit</code>, <code>TravelFeatureKit</code>). An article on <a href="https://www.raywenderlich.com/5109-creating-a-framework-for-ios">raywenderlich.com</a> has a thorough explanation of the whole process.</p><p>After creating frameworks, project navigator should look something like in the picture below.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part2/project_frameworks.png" alt="Frameworks in the Project Navigator" width="300"/><h1>Setting up CocoaPods</h1><p>We'll be using <a href="https://cocoapods.org">CocoaPods</a> for managing dependencies in our project. Although setting up CocoaPods is fairly straightforward, there can be some difficulties when having local frameworks involved. The configuration is defined in <code>Podfile</code> which is located in the root folder of the project.</p><p><code>Podfile</code> will be configured in a way that is clean and clear so it would not get messy when number of dependencies in the project grow. Essentially, we'll define the reusable pods at the top of the file and group different groups of pods that can be reused for different frameworks.</p><p>The part of <code>Podfile</code> that defines pods of <code>TravelKit</code>.</p><pre><code>platform :ios, '<span class="number">11.0</span>'
use_frameworks!
inhibit_all_warnings!

deployment_target = '<span class="number">11.0</span>'

workspace '<span class="type">TravelApplication</span>.<span class="property">xcworkspace</span>'

#Versions
$swinjectVersion =                    '~&gt; <span class="number">2.4</span>'
$swiftDateVersion =                   '~&gt; <span class="number">5.0</span>'
&lt;...&gt;

def shared_TravelKit_pods
    pod '<span class="type">RxSwift</span>',                    $rxSwiftVersion
    pod '<span class="type">SwiftDate</span>',                  $swiftDateVersion
end

target '<span class="type">TravelKit</span>' <span class="keyword">do</span>
    project '<span class="type">TravelKit</span>.<span class="property">xcodeproj</span>'
    platform :ios, deployment_target

    shared_TravelKit_pods

  target '<span class="type">TravelKitTests</span>' <span class="keyword">do</span>
    project '<span class="type">TravelKit</span>.<span class="property">xcodeproj</span>'
    inherit! :search_paths

    shared_testing_pods
  end
end
&lt;...&gt;
</code></pre><p>These different shared pods should be assembled and used of the actual application target.</p><pre><code>&lt;...&gt;
def shared_Apps_pods
  shared_TravelKit_pods
  &lt;...&gt;
end

target '<span class="type">TravelApplication</span>' <span class="keyword">do</span>
    project '<span class="type">TravelApplication</span>.<span class="property">xcodeproj</span>'
    platform :ios, deployment_target
    shared_Apps_pods
end
&lt;...&gt;
</code></pre><p>The full <a href="https://github.com/nitesuit/aerogami-ios/blob/master/Podfile">Podfile</a> can be found on <code>GitHub</code> as the rest of the project.</p><h1>Dependency Injection</h1><p>I prefer to think early about the way dependencies will be managed inside the application. Although dependency injection can be achieved without 3rd party libraries, for this project we'll use <a href="https://github.com/Swinject/Swinject">Swinject</a> that has easy to use interfaces for managing dependencies.</p><p>Our classes will use <code>initializer injection</code> thus all the dependencies will be given through the initializer. The classes will be initialized in assemblies. Assembly is a <code>Swinject</code> class which has access to a container of already injected dependencies and provides a way to register new dependencies.</p><p>For example, this is how the assembly of the <code>Feed</code> that displays the list of flights might looks like:</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Swinject
<span class="keyword">import</span> TravelKit

<span class="keyword">public class</span> FeedAssembly: <span class="type">Assembly</span> {

    <span class="keyword">public init</span>() {
    }

    <span class="keyword">public func</span> assemble(container: <span class="type">Container</span>) {
        container.<span class="call">register</span>(<span class="type">FeedConfigurator</span>.<span class="keyword">self</span>) { r <span class="keyword">in</span>
            <span class="type">FeedConfigurator</span>(
                regionRepository: r.<span class="call">resolve</span>(<span class="type">RegionRepository</span>.<span class="keyword">self</span>)!,
                tripRepository: r.<span class="call">resolve</span>(<span class="type">TripRepository</span>.<span class="keyword">self</span>)!,
                airportRepository: r.<span class="call">resolve</span>(<span class="type">AirportRepository</span>.<span class="keyword">self</span>)!,
                tripImageRepository: r.<span class="call">resolve</span>(<span class="type">TripImageRepository</span>.<span class="keyword">self</span>)!
                )
            }
            .<span class="call">initCompleted</span> { (resolver, feedConfigurator) <span class="keyword">in</span>
                feedConfigurator.<span class="property">bookTripConfigurator</span> = resolver.<span class="call">resolve</span>(<span class="type">BookTripConfigurator</span>.<span class="keyword">self</span>)!
            }
            .<span class="call">inObjectScope</span>(.<span class="dotAccess">container</span>)
    }
}
</code></pre><p>Here, we inject <code>FeedConfigurator</code> class. It is essentially a factory class for the whole <code>Feed</code> feature and its view. <code>Swinject</code> automatically passes the dependencies such as <code>RegionRepository</code> or <code>TripRepository</code>. We expect these dependencies to be injected in another assembly so we can resolve it here.</p><p>Our application will have <code>AssemblerFactory</code> that will contain all the different assemblies of the application and create them during initialization process.</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> Swinject
<span class="keyword">import</span> TravelFeatureKit
<span class="keyword">import</span> TravelDataKit

<span class="keyword">class</span> AssemblerFactory {

    <span class="keyword">func</span> create() -&gt; <span class="type">Assembler</span> {
        <span class="keyword">let</span> assemblies: [<span class="type">Assembly</span>] = [
            <span class="type">ApplicationAssembly</span>(),
            <span class="type">RegionRepositoryAssembly</span>(),
            <span class="type">TripRepositoryAssembly</span>(),
            <span class="type">AirportRepositoryAssembly</span>(),

            <span class="type">MainAssembly</span>(),
            <span class="type">FavoritesAssembly</span>(),
            <span class="type">FeedAssembly</span>(),
            <span class="type">BookTripAssembly</span>(),
            <span class="type">BookURLRepositoryAssembly</span>(affiliateId: <span class="type">Constants</span>.<span class="property">affiliateId</span>)
        ]

        <span class="keyword">let</span> assembler = <span class="type">Assembler</span>(assemblies)

        <span class="keyword">return</span> assembler
    }
}
</code></pre><p>We use this assembly to create the first <code>ViewController</code> of the application and set it as <code>rootViewController</code>. See <a href="https://github.com/nitesuit/aerogami-ios/blob/master/TravelApplication/Application/ApplicationLoader.swift">ApplicationLoader</a>.</p><pre><code>   <span class="keyword">self</span>.<span class="property">assembler</span> = <span class="type">AssemblerFactory</span>().<span class="call">create</span>()
  <span class="keyword">let</span> rootConfigurator = assembler.<span class="property">resolver</span>.<span class="call">resolve</span>(<span class="type">MainConfigurator</span>.<span class="keyword">self</span>)!
  <span class="keyword">let</span> rootViewController = rootConfigurator.<span class="call">createViewController</span>()
  window?.<span class="property">rootViewController</span> = rootViewController
  window?.<span class="call">makeKeyAndVisible</span>()
</code></pre><p>In the following parts of the series we'll be creating classes for fetching and presenting data that will use assemblies for injecting dependencies. We'll see more closely how having proper dependency injection allows code to be more reusable, safe and testable.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</guid><title>Building a real-world iOS app (Part 1): Introduction</title><description></description><link>https://www.staskus.io/posts/2019-03-11-aerogami_series_part_1</link><pubDate>Mon, 11 Mar 2019 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When learning any new technology I find it beneficial to follow a real world example. In this tutorial series we'll be creating and releasing an iOS application. The application will be created by showing a real thinking process, going through essential steps and providing the motivation behind them. Although every single line of code won't be covered, all of it will be always available on <a href="https://github.com/nitesuit/aerogami-ios">GitHub</a>.</p><h1>Prerequisites</h1><p>Prior knowledge of iOS development and Swift syntax is needed.</p><h1>Introduction</h1><h2>Our Project</h2><p>We'll be creating a flight discovery application. The users of our application should be able to:</p><ol><li>See the <em>feed</em> of <em>flights</em></li><li>See the <em>date</em>, <em>price</em>, <em>origin</em> and <em>destination</em> of each <em>flight</em></li><li>Book the <em>flight</em>.</li></ol><p>In the scope of this project we won't be concerned about the source of information. Our application will use mocked flight information data. However, the structure of the application will support an easy integration with any Rest API.</p><h2>Our Approach</h2><p>Throughout the series we'll cover these topics one-by-one:</p><ol><li>Data Fetching and Parsing</li><li>Testing</li><li>Code Separation into Frameworks</li><li>Design using Sketch</li><li>Clean Swift Architecture</li><li>Building the UI and Displaying the Data</li><li>Release Process</li></ol><h2>The Final Product</h2><p>Here is the sneak peek of how the final product will look like. The full codebase can be found on <a href="https://github.com/nitesuit/aerogami-ios">GitHub</a>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/screenshot.png" alt="Application Screenshot" width="200"/><h1>High Level View</h1><p>Before we start, it's beneficial to understand how we're going to approach the creation of this application.</p><h2>Separation of Concerns</h2><p>Essentially our application should be able to perform 3 main tasks:</p><ol><li>Fetch data</li><li>Parse data</li><li>Display data</li></ol><p>We'll separate these different concerns into frameworks for our code to be decoupled and flexible. The primitive diagram of the architecture is displayed in the picture bellow. We'll define data models and protocols in <code>TravelKit</code>. This framework will contain data fetching protocols, which will be implemented in <code>TravelDataKit</code>. DataKit, as its name suggests, will be used for fetching, persisting and providing data. User interface will only know about data models and protocols and won't be concerned about the implementation. We'll call this framework <code>TravelFeatureKit</code>. The entry point of our application will initialize the dependencies required for all the frameworks and present the root view described in <code>TravelFeatureKit</code>.</p><img src="https://www.staskus.io/images/aerogami-tutorial/part1/architecture.png" alt="Application Architecture" width="300"/><p>In the next part of the series we'll continue by explaining how to create frameworks and setup the base of the application.</p>]]></content:encoded></item></channel></rss>