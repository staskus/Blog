<!DOCTYPE html><html lang="en"><head><title>Povilas Staškus - iOS Developer</title><meta name="twitter:title" content="Povilas Staškus - iOS Developer"/><meta name="og:title" content="Povilas Staškus - iOS Developer"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/Pure/styles.css"/><link rel="stylesheet" href="/all.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><a class="pure-menu-heading" href="/">staskus.io</a><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/about">About</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/archive">Archive</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/afterWork">After work</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://avatars0.githubusercontent.com/u/4062343?s=460&v=4"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Povilas Staškus</h1><h3 class="brand-tagline">iOS Developer</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="https://en.wikipedia.org/wiki/Vilnius"><i class="fas fa-map-marker-alt l-box social-icon"></i><a class="social-media" href="https://en.wikipedia.org/wiki/Vilnius">Vilnius, Lithuania</a></a></div><div class="pure-u-md-1-1"><a href="mailto:povilas@staskus.io"><i class="fas fa-envelope-open-text l-box social-icon"></i><a class="social-media" href="mailto:povilas@staskus.io">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/povilas-staškus-6b10528b"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/povilas-staškus-6b10528b">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/staskus"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/staskus">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/PovilasStaskus"><i class="fab fa-twitter-square l-box social-icon"></i><a class="social-media" href="https://twitter.com/PovilasStaskus">Twitter</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/notes/Trees and Graphs">Trees and Graphs</a></h2><p class="post-meta">Last modified: 2022 April 27</p><div class="post-description"><div><h1>Trees</h1><p><strong>Tree</strong> - a data structure composed of nodes. Each tree has a root node, each child has zero or more child nodes and doesn't have cycles.</p><p><strong>Leaf Node</strong> - a node with no children.</p><h2>Binary trees</h2><p><strong>Binary Tree</strong> - each node has up to two children.</p><p><strong>Binary Search Tree</strong> - when <em>every</em> node is specifically ordered.</p><p><strong>Complete Binary Tree</strong> - every level is filled except the last level. Last level filling from left to right.</p><p><strong>Full Binary Tree</strong> - each node has either zero or two children</p><p><strong>Perfect Binary Tree</strong> - full, complete and all nodes at the same level.</p><h3>Traversal</h3><h4>In-Order</h4><p>First visit the left branch, then the current node then the right branch.</p><pre><code class="language-swift">func traverseInOrder(_ node: Node?) {
    if let node = node {
        traverseInOrder(node?.left)
        visit(node) // for example just print
        traverseInOrder(node?.right)
    }
}
</code></pre><h4>Pre-Order</h4><p>First visit the current node, then the others.</p><pre><code class="language-swift">func traversePreOrder(_ node: Node?) {
    if let node = node {
        visit(node)
        traversePreOrder(node?.left)
        traversePreOrder(node?.right)
    }
}
</code></pre><h4>Post-Order</h4><p>First visit left and right branches, then the current node.</p><pre><code class="language-swift">func traversePostOrder(_ node: Node?) {
    if let node = node {
        traversePostOrder(node?.left)
        traversePostOrder(node?.right)
        visit(node)
    }
}
</code></pre><h2>Balancing</h2><p><strong>Balanced tree</strong> - doesn't mean that right and left sides are of the same size. It means that its balance might allow for specific effective operations such as O(log n) insert and find.</p><h2>Binary Heaps</h2><p><strong>Min-heap</strong> - is a complete binary tree where each node is smaller than its children. The root is the minimum element in the tree.</p><h3>Insert</h3><p>We insert at the rightmost empty spot and then go up by swapping with the parent until it's smaller than its parent.</p><p>O(log n)</p><h3>Get Minimum Element</h3><p>It's always at the top.</p><h3>Remove Minimum Element</h3><ol><li>Remove the top element</li><li>Replace it with the bottommost-rightmost element</li><li>Go from the top to the bottom swapping it with the children until it reaches its place</li></ol><p>O(log n)</p><h2>Trie (Prefix Tree)</h2><p>An n-ary tree where characters are stored at each node. * node indicates a complete word. Each node can have children the number of the size of the alphabet.</p><p>Usage: <em> Storing the entire language for quick prefix lookups. </em> Lists of valid words</p><h1>Graphs</h1><p>A graph is a collection of nodes with edges between some of them.</p><p><strong>Connected graph</strong> - if there's a path between every pair of vertices.</p><p><strong>Acyclic graph</strong> - a graph without cycles</p><h2>Adjacency List</h2><p>A way to represent a graph</p><pre><code class="language-swift">class Graph {
    var nodes: [Node]
}

class Node {
    var val: Int
    var children: [Node]
}
</code></pre><h2>Adjacency Matrix</h2><pre><code class="language-swift">matrix[i][j] == true // represents that there's an edge between i and j nodes
</code></pre><h2>Search</h2><h3>Depth-first search (DFS)</h3><p>Explore each branch completely before moving to the next branch, meaning going deep first.</p><p>DFS is to visit every node in the graph.</p><p>To implement we can use recursion or a stack (which recursion uses underneath).</p><pre><code class="language-swift">    func searchDFS(_ root: Node?) {
        guard let root = root else { return }

        visit(root)
        root.visited = true

        for node in root.children {
            if !node.visited {
                seachDFS(node)
            }
        }
    }
</code></pre><h3>Breadth-first search (BFS)</h3><p>Explore each neighbor before moving to the children, meaning going wide first.</p><p>BFS is used to find the shortest (or any) path between 2 nodes.</p><p>To implement we need to use a queue (FIFO) data structure to ensure we search wide first.</p><pre><code class="language-swift">    func searchBFS(_ root: Node?) {
        guard let root = root else { return }

        let queue = Queue()
        root.marked = true
        queue.enqueue(root) // Add to the end

        while !queue.isEmpty {
            let node = queue.dequeue() // Take from the front
            visit(node)

            for child in node.children {
                if !child.marked {
                    child.marked = true
                    queue.enqueue(child)
                }
            }
        }
    }
</code></pre><p>3 facts to know about BFS: 1. Inorder traversal of BST is an array sorted in the ascending order. 2. Successor = "after node", i.e. the next node in "In order traversal (Left -&gt; Node -&gt; Previous)", or the smallest node after the current one. 3. Predecessor = "before node", i.e. the previous node "In order traversal (Left -&gt; Node -&gt; Previous)", or the largest node before the current one.</p><h3>Bidirectional Search</h3><p>Find the shorted path between 2 nodes by performing 2 simultaneous BFS from both nodes.</p><h2>Example problems to know how to solve:</h2><h3>Convert Sorted Array to Binary Search Tree</h3><p>Keep splitting the sorted array in half so the root would be the middle element.</p><pre><code class="language-swift">// O(n) time complexity, O(logn) space complexity

class Solution {
    func sortedArrayToBST(_ nums: [Int]) -&gt; TreeNode? {
        return createMinimalBST(nums, start: 0, end: nums.count - 1)
    }
    
    private func createMinimalBST(_ nums: [Int], start: Int, end: Int) -&gt; TreeNode? {
        guard start &lt;= end else { return nil }
        
        let mid = ((start + end) / 2)
    
        return TreeNode(
            nums[mid],
            createMinimalBST(nums, start: start, end: mid - 1),
            createMinimalBST(nums, start: mid + 1, end: end)
            )
    }
}
</code></pre><h3>Given a binary tree, return the level order traversal of its nodes</h3><p>It can be done using a simple recursion or a BFS. BFS allows printing easier level by level. In both cases, we need to save the "level" in the queue or pass it during the recursion.</p><h3>Check if Binary Tree is balanced</h3><p>A balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p><p>Calculating the height of each branch is not fully effective. We need to introduce an "early exit" the moment we find one branch not being balanced.</p><pre><code class="language-swift">// O(N) time and O(H) space because of the early exit
// We first go as deep left as possible and then increase the height when going up. The moment we find the difference between left and right more than 1, we throw an error.
class Solution {
    enum TreeError: Error {
        case notBalanced
    }
    
    func isBalanced(_ root: TreeNode?) -&gt; Bool {
        guard let root = root else { return true }
        
        do {
            try checkHeight(root)
            return true
        } catch {
            return false
        }
    }
    
    @discardableResult
    private func checkHeight(_ root: TreeNode?) throws -&gt; Int {      
        guard let root = root else { return -1 }

        let left = try checkHeight(root.left) // Throwing error as an early exit
        let right =  try checkHeight(root.right)
        
        if (abs(left - right) &lt; 2) {
            return max(left, right) + 1
        } else {
            throw TreeError.notBalanced
        }
    }
}
</code></pre><h3>Validate Binary Search Tree</h3><pre><code>A valid BST is defined as follows:

* The left subtree of a node contains only nodes with keys less than the node's key.
* The right subtree of a node contains only nodes with keys greater than the node's key.
* Both the left and right subtrees must also be binary search trees.
</code></pre><img src="/images/notes/86b326043320bbd1a5d8d05117e1187489c2d15b285e3a773dd4476c23e2dc14.png" alt="Leetcode.com"/><p>We have 2 main routes to take.</p><p>First one is more intuitive, traverse the tree recursively, passing valid ranges and then validating them against the current value:</p><pre><code class="language-swift">// O(n), O(n)
func isValidBST(_ root: TreeNode?) -&gt; Bool {
    guard let root = root else { return true }
    
    return isValidBST(root.left, -Int.max..&lt;root.val) &amp;&amp; isValidBST(root.right, root.val+1..&lt;Int.max)
}

private func isValidBST(_ root: TreeNode?, _ allowedRange: Range&lt;Int&gt;) -&gt; Bool {
    guard let root = root else { return true }
            
    if !allowedRange.contains(root.val) {
        return false
    }
    
    return isValidBST(root.left, allowedRange.lowerBound..&lt;root.val) &amp;&amp; isValidBST(root.right, root.val+1..&lt;allowedRange.upperBound)
}
</code></pre><p>Using DFS Inorder traversal is a more interesting solution. <code>Left -&gt; Node -&gt; Right</code>. Traversing like this we expect each node to have a larger value if it is a binary search tree.</p><pre><code class="language-swift">// O(n), O(n)
private var previous: Int?

func isValidBST(_ root: TreeNode?) -&gt; Bool {
guard let root = root else { return true }
    
    // Left
    if !isValidBST(root.left) {
        return false
    }
    
    // Node
    if let previous = previous, previous &gt;= root.val {
        return false
    }
    previous = root.val
    
    // Right
    if !isValidBST(root.right) {
        return false
    }
    
    return true
}
</code></pre><h3>Find a successor (next node) in a binary search tree</h3><ul><li>Successor = "after node", i.e. the next node in the inorder traversal, or the smallest node after the current one.</li></ul><ul><li>Predecessor = "before node", i.e. the previous node in the inorder traversal, or the largest node before the current one.</li></ul><p>So to find a successor we either need to go: - One right node and as many left nodes as possible - If no right node exists, go up the tree until the node is the left child of the parent and return the parent</p><h3>Course Schedule</h3><p>Given the list of courses and dependency list of which courses must come before the others, return a list of course order.</p><p>This issue can be solved with DFS with some caveats. <em> We might not have one graph, there might be multiple graphs. So we might need to do multiple DFS until all nodes (courses) have been visited. </em> Once we reach the end of the graph then we add that node to the <strong>beginning</strong> of the course schedule. * If cycles are found, it's impossible to create a schedule. Cycles can be avoided by <strong>visited</strong> and <strong>visiting</strong> (or gray and black) node marking.</p><h3>Lowest Common Ancestor in a Binary Tree of 2 nodes</h3><p>The idea is to do a DFS recursive search throughout the tree. At each point we make 2 recursive calls (to the left and to the right). At the moment where <strong>both</strong> left and right branches result in a node being found, or any of the branches result in a node being found <strong>and</strong> the current node is a node we are looking for, we return a node.</p><pre><code class="language-swift">// O(n), O(n)
private func findNode(from node: TreeNode?, to p: TreeNode, orTo q: TreeNode) -&gt; Bool {
    guard let node = node else {
        return false
    }
    
    let left = findNode(from: node.left, to: p, orTo: q) ? 1 : 0
    let right = findNode(from: node.right, to: p, orTo: q) ? 1 : 0
    let current = node.val == p.val || node.val == q.val ? 1 : 0
    
    // If any two are correct
    if left + right + current &gt;= 2 {
        ancestor = node
    }
    
    return left + right + current &gt; 0
}
</code></pre><h3>Number of Ways to Reorder Array to Get Same BST</h3><p>How many times we can reorder the same given array to get the same BST.</p><p>The intuition: <em> The first array element needs to be the same to have the same root </em> Smaller elements need to keep the same relative position to other small elements * Larger elements need to keep the same relative position to other large elements</p><p>The solution: <em> Divide and conquer. Keep splitting given array into 2 arrays with larger numbers than the first one and smaller numbers than the first one. Calculate the number of combination for each array </em> Combinatorics nCk (to find the number of ways selecting k things out of n things) * Multiply all the results recursively</p><p>Problems in Swift: <em> No built-in way to calculate nCk </em> No built-in way to calculate using large numbers BigInt</p><p>The gist of the algorithm</p><pre><code class="language-swift">func numOfWays(_ nums: [Int]) -&gt; Int {
    func divideAndConquer(_ sublist: [Int]) -&gt; Int {
        if sublist.count &lt;= 2 {
            return 1 // base case
        }
        
        let root = sublist[0]
        
        let left = sublist.filter { $0 &lt; root }
        let right = sublist.filter { $0 &gt; root }
        
        return nCk(left.count + right.count, left.count) * divideAndConquer(left) * divideAndConquer(right)
    }
    
    return (divideAndConquer(nums) - 1) // With big trees the result will overflow
}

func nCk(_ n: Int, _ k: Int) -&gt; Int {
    //C (n , k) = n! / [ (n-k)! k! ]
    
    if (k &gt; n) { return 0 }
    var result = 1
    for i in 0..&lt;min(k, n-k) {
        result = (result * (n - i))/(i + 1)
    }
    return result
}
</code></pre><h3>Path Sum</h3><p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</p><p>This problem can be solved using a <strong>prefix sum</strong> technique.</p><img src="/images/notes/4b53bbaf1ca1cab5b0a3959afb3ae6aaeefd5c8bf7772fb509f1d80a00ca5492.png" alt="LeetCode.com"/><p><strong>Prefix sum</strong> technique can be used to solve problems such as: * Find a number of arrays/matrices/tree paths that sum to a target</p><p>It's easier to understand the explanation using sum of arrays:</p><pre><code class="language-swift">class Solution {
    func subarraySum(_ nums: [Int], _ k: Int) -&gt; Int {
        var count = 0
        var sumCount: [Int: Int] = [:]
        var sum = 0
        
        for num in nums {
            sum += num
            
            // Special case if we find sum at the first position
            if sum == k {
                count += 1
            }
            
            // This is the most important part
            // Let's say we have array [10, 5, 3] and target sum 8
            // When we come to 3, the sum is 18 and 18 - target sum = 10
            // In this case we encounter sum 10 for the second time, it means that in-between we had numbers that summed up to target sum (8). 
            // Counter-intuitive but super clever
            count += sumCount[sum - k, default: 0] 
            
            sumCount[sum, default: 0] += 1
        }
        
        return count
    }
}
</code></pre><h3>Course Schedule</h3><p>Given the number of courses and a list of prerequisites (the courses that depend on each other) determine if it's possible to create a schedule.</p><p>This task is asking to find cycles in a graph. If a cycle exists, it means the schedule cannot be formed. Perform a DFS, if we encounter a node that was already visited in the same path, the cycle exists.</p><h3>Invert Binary Tree</h3><p>To invert a binary tree we need to replace the left and right nodes at each step of the tree. We can use both recursive and iterative approaches. Time and space complexity in both cases is O(n)</p><pre><code class="language-swift">// If we use iterative approach, we can use queues
// O(n), O(n)
func invertTree(_ root: TreeNode?) -&gt; TreeNode? {
    guard let root = root else { return nil }
    
    let right = invertTree(root.right)
    let left = invertTree(root.left)
    
    root.left = right
    root.right = left

    return root
}
</code></pre><h3>Lowest Common Ancestor of a Binary Search Tree</h3><p>Because this is a binary search tree the solution can be iterative. At each point we can either go left or right depending on the p, q and root values. When p and q values are between the root, the root is our lowest common ancestor.</p><pre><code class="language-swift">// O(n) O(1)
func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -&gt; TreeNode? {
    guard let p = p, let q = q else { return nil }
    
    var root = root
    
    while root != nil {
        let rootVal = root!.val
        let pVal = p.val
        let qVal = q.val
        
        if pVal &gt; rootVal &amp;&amp; qVal &gt; rootVal {
            root = root!.right
        } else if pVal &lt; rootVal &amp;&amp; qVal &lt; rootVal {
            root = root!.left
        } else {
            return root
        }
    }
    
    return nil
}
</code></pre><h3>Implement Trie (prefix tree)</h3><p>This data structure is used to implement autocomplete, spell checker, IP routing, T9 predictive text, solve word games, and many more.</p><p>Trie is a rooted tree that has: - Maximum of X links to children (X could be for example 26, the number of lowercase letters in an English alphabet) - A boolean field that specifies if the node is the end or not</p><p>Main functions of a trie: 1. Insert word (Time complexity O(m), Space complexity O(m)). Where m - length of the word 2. Search word (Time complexity O(m), Space complexity O(1)) 3. Search prefix (Same as word, but we don't check if the last letter is the end)</p><p>Implementation:</p><p>A TrieNode. A node that holds a list of its links. We could use HashTable or Array of fixed size.</p><pre><code class="language-swift">class TrieNode {
    var links: [Character: TrieNode] = [:]
    var isEnd = false
    
    func getNode(_ char: Character) -&gt; TrieNode? {
        return links[char]
    }
    
    @discardableResult
    func createNode(_ char: Character) -&gt; TrieNode {
        let node = TrieNode()
        links[char] = node
        return node
    }
}
</code></pre><p>A Trie.</p><p>To insert, we just start with the root and keep adding links. To search, we start with the root, and look if each node has a character as a link.</p><pre><code class="language-swift">class Trie {
    private var root = TrieNode()
    
    func insert(_ word: String) {
        var currentNode = root
        
        for letter in word {
            if let node = currentNode.getNode(letter) {
                currentNode = node
            } else {
                currentNode = currentNode.createNode(letter)
            }
        }
        
        currentNode.isEnd = true
    }
    
    func search(_ word: String) -&gt; Bool {
        guard let node = findEndNode(word) else {
            return false
        }
        
        return node.isEnd
    }
    
    func startsWith(_ prefix: String) -&gt; Bool {
        return findEndNode(prefix) != nil
    }

    // MARK: - Private
    
    private func findEndNode(_ word: String) -&gt; TrieNode? {
        var currentNode = root
        for letter in word {
            if let node = currentNode.getNode(letter) {
                currentNode = node
            } else {
                return nil
            }
        }
        
        return currentNode
    }
}
</code></pre><h3>Number of Islands in a Grid</h3><p>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.</p><pre><code class="language-swift">Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
</code></pre><p>We need to look at it as a graph problem and solve either with: 1. DFS 2. BFS 3. Union Find</p><p>DFS Solution:</p><pre><code class="language-swift">func numIslands(_ grid: [[Character]]) -&gt; Int {
    var numberOfIslands = 0
    var grid = grid
    
    for row in 0..&lt;grid.count {
        for col in 0..&lt;grid[row].count {
            if grid[row][col] == "1" {
                markIslandAsVisited(&amp;grid, row, col)
                numberOfIslands += 1
            }
        }
    }
    
    return numberOfIslands
}

@discardableResult
private func markIslandAsVisited(_ grid: inout [[Character]], _ row: Int, _ col: Int) {
    guard row &gt;= 0, row &lt; grid.count, col &gt;= 0 , col &lt; grid[0].count else {
        return
    }
    
    guard grid[row][col] == "1" else {
        return
    } 
    
    grid[row][col] = "0"
    
    [(row - 1, col), (row, col - 1), (row + 1, col), (row, col + 1)].forEach { newRow, newCol in 
        markIslandAsVisited(&amp;grid, newRow, newCol)
    }
    
    return
}
</code></pre><h3>Combination Sum</h3><p>Given array of candidates and a target sum, return a list of unique combinations of candidates that sum to target.</p><p>We use backtracking algorithm.</p><p>Time complexity - <strong>O(N^((t/m)+1))</strong>, where t- target value and m - minimal value.</p><p>This is from theory that the maximum number of nodes in N-ary tree of T/M height is O(N^((t/m)+1))</p><p>If 8 - target, and 2 - minimum then O(N^4+1).</p><p>Space - O(t/m)</p><pre><code class="language-swift">    func combinationSum(_ candidates: [Int], _ target: Int) -&gt; [[Int]] {
        // unique = skip if there are 2 same numbers, leetcode already ensures it
        
        var combinations: [[Int]] = []
        
        combinationSum(candidates, target, [], &amp;combinations)
        
        return combinations
    }
    
    private func combinationSum(_ candidates: [Int], 
                                _ remaining: Int, 
                                _ currentCombination: [Int], 
                                _ combinations: inout [[Int]]) {
        print(remaining)
        guard remaining &gt;= 0 else { return }
        
        if remaining == 0 {
            combinations.append(currentCombination)
            return
        }
        
        for i in 0..&lt;candidates.count {
            combinationSum(Array(candidates[i..&lt;candidates.count]), 
                           remaining - candidates[i], 
                           currentCombination + [candidates[i]], 
                           &amp;combinations)
        }
    }
</code></pre><h1>Additional Information</h1><h2>Spanning Tree</h2><p>A spanning tree is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.</p><p>A minimum spanning tree is a spanning tree with the minimum possible total edge weight in a “weighted undirected graph”.</p><p>Tree - doesn't have cycles</p><p>Cut Property - choosing crossing edge between 2 cuts with the lowest weight</p><h3>Minimum Spanning Tree</h3><p><strong>“Kruskal’s algorithm”</strong> is an algorithm to construct a “minimum spanning tree” of a “weighted undirected graph”. 1) Take all possible edges 2) sort by weight 3) pick one by one if the cycle is not created (!uf.connected).</p><p><strong>Prims Algorithm:</strong> - 1) Pick starting node, see which unvisited node we can visit most cheaply. 2) pick visited nodes, see which unvisited node we can visit most cheaply 3) repeat until all nodes are visited. We need to use min-heap to pick the lowest weighted edge - However, in some cases using min-heap is not effective enough so we need to look ways around it (Min Cost to Connect All Points) as even effective sorting adds log(n) of time complexity.</p><p>Heap is not a Priority Queue, but a way to implement a Priority Queue.</p><p>Heap is a special type of binary tree. Insertion, deletion O(log n). Max, minimum - O(1): - Min Heap. - Max Heap</p><p>BFS - Always find the shortest path first. Finding a path in the grid is a usual task.</p><h2>Single source shortest path problem</h2><p>Edge Relaxation operation is a key in solving the "single source shortest path problem" - If A-D distance is 3, but A-C-D is 2 by performing edge relaxation we note that the distance between A-D is actually 2</p><p><strong>Dijkstra's algorithm</strong>. Can only be used to solve the problem with non-negative weights</p><ul><li>In time complexity we have 2 properties: V - number of vertices and E - number of edges. If we use the Fibonacci heap to extract minimum element total complexity O(E + VlogV). If we use Binary heap time complexity would be O(V+ ElogV).</li><li>Space complexity O(V)</li></ul><p><strong>Steps:</strong> 1. Start at the ending vertex by marking it with a distance of 0 (call it <em>currentVertex</em>) 2. Identify all of the vertices connected to <em>currentVertex</em> with weights. If we already identified vertex, only change weight if a new one is smaller 3. Label <em>currentVertex</em> as visited 4. Find smallest identifier vertice and repeat 2 5. Once labeled a beginning vertex - stop</p><p><strong>Bellman-Ford algorithm</strong>. Can solve with any weights.</p><p>“Bellman-Ford algorithm” is only applicable to “graphs” with no “negative weight cycles”.</p><p>We find a negative cycle if after performing Nth edge relaxation (we normally just need to do N-1) we still find a shorter path.</p><ul><li>Time complexity O(V * E)</li><li>Space complexity O(V)</li></ul><p>Positive Weight Cycle: If during each cycle the path weight increases. The shortest path is after the first cycle</p><p>Negative Weight Cycle: If during each cycle the path weight decreases. There's no shortest path then</p><p><strong>Bellman-Ford:</strong> 1. Have previous and current arrays 2. Each iteration simply set current cost to be minimum of already existing or previous + cost current[destination] = min(current[destination], previous[origin] + cost) 3. At the end of iteration set previous = current</p><p>Essentially, <strong>Bellman-Ford</strong> algorithm is a dynamic programming solution optimized for space and time. If 2 loops in the row we get the same result, we can return it as the shortest path.</p><p>If a question has a constraint of going through k edges, then we just use a dynamic programming approach</p><h2>Dynamic Programming</h2><p><strong>Dynamic Programming (DP)</strong> is an algorithmic technique for solving an optimization problem by breaking it down into simpler subproblems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its subproblems.</p><p>Solving shortest path problem using Dynamic Programming: - Asking: Can I find the shortest path using at most 1 edge? Can I find the shortest path using at most 2 edges, etc until N-1 edges</p><p><strong>Dynamic Programming</strong> 1. Look if the same problem can be split into some smaller problems in a tree structure. Then it means we can solve it using recursion. We need to know the base case to return early from recursion. 2. Make it work brute force way 3. Optimize it using “memoization” (creating dict or set for efficiency)</p></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2022 Povilas Staškus</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a></div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>