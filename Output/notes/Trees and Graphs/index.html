<!DOCTYPE html><html lang="en"><head><title>Povilas Staškus - iOS Developer</title><meta name="twitter:title" content="Povilas Staškus - iOS Developer"/><meta name="og:title" content="Povilas Staškus - iOS Developer"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/Pure/styles.css"/><link rel="stylesheet" href="/all.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><a class="pure-menu-heading" href="/">staskus.io</a><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/about">About</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/notes">Notes</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/afterWork">After work</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://avatars0.githubusercontent.com/u/4062343?s=460&v=4"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Povilas Staškus</h1><h3 class="brand-tagline">iOS Developer</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="https://en.wikipedia.org/wiki/Vilnius"><i class="fas fa-map-marker-alt l-box social-icon"></i><a class="social-media" href="https://en.wikipedia.org/wiki/Vilnius">Vilnius, Lithuania</a></a></div><div class="pure-u-md-1-1"><a href="mailto:povilas@staskus.io"><i class="fas fa-envelope-open-text l-box social-icon"></i><a class="social-media" href="mailto:povilas@staskus.io">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/povilas-staškus-6b10528b"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/povilas-staškus-6b10528b">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/nitesuit"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/nitesuit">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/PovilasStaskus"><i class="fab fa-twitter-square l-box social-icon"></i><a class="social-media" href="https://twitter.com/PovilasStaskus">Twitter</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/notes/Trees and Graphs">Trees and Graphs</a></h2><p class="post-meta">Last modified: 2022 March 29</p><div class="post-description"><div><h1>Trees</h1><p><strong>Tree</strong> - a data structure composed of nodes. Each tree has a root node, each child has zero or more child nodes and doesn't have cycles.</p><p><strong>Leaf Node</strong> - a node with no children.</p><h2>Binary trees</h2><p><strong>Binary Tree</strong> - each node has up to two children.</p><p><strong>Binary Search Tree</strong> - when <em>every</em> node is specifically ordered.</p><p><strong>Complete Binary Tree</strong> - every level is filled except the last level. Last level filling from left to right.</p><p><strong>Full Binary Tree</strong> - each node has either zero or two children</p><p><strong>Perfect Binary Tree</strong> - full, complete and all nodes at the same level.</p><h3>Traversal</h3><h4>In-Order</h4><p>First visit the left branch, then the current node then the right branch.</p><pre><code><span class="keyword">func</span> traverseInOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">traverseInOrder</span>(node?.<span class="property">left</span>)
        <span class="call">visit</span>(node) <span class="comment">// for example just print</span>
        <span class="call">traverseInOrder</span>(node?.<span class="property">right</span>)
    }
}
</code></pre><h4>Pre-Order</h4><p>First visit the current node, then the others.</p><pre><code><span class="keyword">func</span> traversePreOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">visit</span>(node)
        <span class="call">traversePreOrder</span>(node?.<span class="property">left</span>)
        <span class="call">traversePreOrder</span>(node?.<span class="property">right</span>)
    }
}
</code></pre><h4>Post-Order</h4><p>First visit left and right branches, then the current node.</p><pre><code><span class="keyword">func</span> traversePostOrder(<span class="keyword">_</span> node: <span class="type">Node</span>?) {
    <span class="keyword">if let</span> node = node {
        <span class="call">traversePostOrder</span>(node?.<span class="property">left</span>)
        <span class="call">traversePostOrder</span>(node?.<span class="property">right</span>)
        <span class="call">visit</span>(node)
    }
}
</code></pre><h2>Balancing</h2><p><strong>Balanced tree</strong> - doesn't mean that right and left sides are of the same size. It means that its balance might allow for specific effective operations such as O(log n) insert and find.</p><h2>Binary Heaps</h2><p><strong>Min-heap</strong> - is a complete binary tree where each node is smaller than its children. The root is the minimum element in the tree.</p><h3>Insert</h3><p>We insert at the rightmost empty spot and then go up by swapping with the parent until it's smaller than its parent.</p><p>O(log n)</p><h3>Get Minimum Element</h3><p>It's always at the top.</p><h3>Remove Minimum Element</h3><ol><li>Remove the top element</li><li>Replace it with the bottommost-rightmost element</li><li>Go from the top to the bottom swapping it with the children until it reaches its place</li></ol><p>O(log n)</p><h2>Trie (Prefix Tree)</h2><p>An n-ary tree where characters are stored at each node. * node indicates a complete word. Each node can have children the number of the size of the alphabet.</p><p>Usage: <em> Storing the entire language for quick prefix lookups. </em> Lists of valid words</p><h1>Graphs</h1><p>A graph is a collection of nodes with edges between some of them.</p><p><strong>Connected graph</strong> - if there's a path between every pair of vertices.</p><p><strong>Acyclic graph</strong> - a graph without cycles</p><h2>Adjacency List</h2><p>A way to represent a graph</p><pre><code><span class="keyword">class</span> Graph {
    <span class="keyword">var</span> nodes: [<span class="type">Node</span>]
}

<span class="keyword">class</span> Node {
    <span class="keyword">var</span> val: <span class="type">Int</span>
    <span class="keyword">var</span> children: [<span class="type">Node</span>]
}
</code></pre><h2>Adjacency Matrix</h2><pre><code>matrix[i][j] == <span class="keyword">true</span> <span class="comment">// represents that there's an edge between i and j nodes</span>
</code></pre><h2>Search</h2><h3>Depth-first search (DFS)</h3><p>Explore each branch completely before moving to the next branch, meaning going deep first.</p><p>DFS is to visit every node in the graph.</p><p>To implement we can use recursion or a stack (which recursion uses underneath).</p><pre><code>     <span class="keyword">func</span> searchDFS(<span class="keyword">_</span> root: <span class="type">Node</span>?) {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="call">visit</span>(root)
        root.<span class="property">visited</span> = <span class="keyword">true

        for</span> node <span class="keyword">in</span> root.<span class="property">children</span> {
            <span class="keyword">if</span> !node.<span class="property">visited</span> {
                <span class="call">seachDFS</span>(node)
            }
        }
    }
</code></pre><h3>Breadth-first search (BFS)</h3><p>Explore each neighbor before moving to the children, meaning going wide first.</p><p>BFS is used to find the shortest (or any) path between 2 nodes.</p><p>To implement we need to use a queue (FIFO) data structure to ensure we search wide first.</p><pre><code>     <span class="keyword">func</span> searchBFS(<span class="keyword">_</span> root: <span class="type">Node</span>?) {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="keyword">let</span> queue = <span class="type">Queue</span>()
        root.<span class="property">marked</span> = <span class="keyword">true</span>
        queue.<span class="call">enqueue</span>(root) <span class="comment">// Add to the end</span>

        <span class="keyword">while</span> !queue.<span class="call">isEmpty</span> {
            <span class="keyword">let</span> node = queue.<span class="call">dequeue</span>() <span class="comment">// Take from the front</span>
            <span class="call">visit</span>(node)

            <span class="keyword">for</span> child <span class="keyword">in</span> node.<span class="property">children</span> {
                <span class="keyword">if</span> !child.<span class="property">marked</span> {
                    child.<span class="property">marked</span> = <span class="keyword">true</span>
                    queue.<span class="call">enqueue</span>(child)
                }
            }
        }
    }
</code></pre><p>3 facts to know about BFS: 1. Inorder traversal of BST is an array sorted in the ascending order. 2. Successor = "after node", i.e. the next node in "In order traversal (Left -&gt; Node -&gt; Previous)", or the smallest node after the current one. 3. Predecessor = "before node", i.e. the previous node "In order traversal (Left -&gt; Node -&gt; Previous)", or the largest node before the current one.</p><h3>Bidirectional Search</h3><p>Find the shorted path between 2 nodes by performing 2 simultaneous BFS from both nodes.</p><h2>Example problems to know how to solve:</h2><h3>Convert Sorted Array to Binary Search Tree</h3><p>Keep splitting the sorted array in half so the root would be the middle element.</p><pre><code><span class="comment">// O(n) time complexity, O(logn) space complexity</span>

<span class="keyword">class</span> Solution {
    <span class="keyword">func</span> sortedArrayToBST(<span class="keyword">_</span> nums: [<span class="type">Int</span>]) -&gt; <span class="type">TreeNode</span>? {
        <span class="keyword">return</span> <span class="call">createMinimalBST</span>(nums, start: <span class="number">0</span>, end: nums.<span class="property">count</span> - <span class="number">1</span>)
    }
    
    <span class="keyword">private func</span> createMinimalBST(<span class="keyword">_</span> nums: [<span class="type">Int</span>], start: <span class="type">Int</span>, end: <span class="type">Int</span>) -&gt; <span class="type">TreeNode</span>? {
        <span class="keyword">guard</span> start &lt;= end <span class="keyword">else</span> { <span class="keyword">return nil</span> }
        
        <span class="keyword">let</span> mid = ((start + end) / <span class="number">2</span>)
    
        <span class="keyword">return</span> <span class="type">TreeNode</span>(
            nums[mid],
            <span class="call">createMinimalBST</span>(nums, start: start, end: mid - <span class="number">1</span>),
            <span class="call">createMinimalBST</span>(nums, start: mid + <span class="number">1</span>, end: end)
            )
    }
}
</code></pre><h3>Given a binary tree, return the level order traversal of its nodes</h3><p>It can be done using a simple recursion or a BFS. BFS allows printing easier level by level. In both cases, we need to save the "level" in the queue or pass it during the recursion.</p><h3>Check if Binary Tree is balanced</h3><p>A balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p><p>Calculating the height of each branch is not fully effective. We need to introduce an "early exit" the moment we find one branch not being balanced.</p><pre><code><span class="comment">// O(N) time and O(H) space because of the early exit
// We first go as deep left as possible and then increase the height when going up. The moment we find the difference between left and right more than 1, we throw an error.</span>
<span class="keyword">class</span> Solution {
    <span class="keyword">enum</span> TreeError: <span class="type">Error</span> {
        <span class="keyword">case</span> notBalanced
    }
    
    <span class="keyword">func</span> isBalanced(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
        
        <span class="keyword">do</span> {
            <span class="keyword">try</span> <span class="call">checkHeight</span>(root)
            <span class="keyword">return true</span>
        } <span class="keyword">catch</span> {
            <span class="keyword">return false</span>
        }
    }
    
    <span class="keyword">@discardableResult
    private func</span> checkHeight(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) <span class="keyword">throws</span> -&gt; <span class="type">Int</span> {      
        <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return</span> -<span class="number">1</span> }

        <span class="keyword">let</span> left = <span class="keyword">try</span> <span class="call">checkHeight</span>(root.<span class="property">left</span>) <span class="comment">// Throwing error as an early exit</span>
        <span class="keyword">let</span> right =  <span class="keyword">try</span> <span class="call">checkHeight</span>(root.<span class="property">right</span>)
        
        <span class="keyword">if</span> (<span class="call">abs</span>(left - right) &lt; <span class="number">2</span>) {
            <span class="keyword">return</span> <span class="call">max</span>(left, right) + <span class="number">1</span>
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">TreeError</span>.<span class="property">notBalanced</span>
        }
    }
}
</code></pre><h3>Validate Binary Search Tree</h3><pre><code><span class="type">A</span> valid <span class="type">BST</span> <span class="keyword">is</span> defined <span class="keyword">as</span> follows:

* <span class="type">The</span> left subtree of a node contains only nodes with keys less than the node's key.
* <span class="type">The</span> right subtree of a node contains only nodes with keys greater than the node's key.
* <span class="type">Both</span> the left and right subtrees must also be binary search trees.
</code></pre><img src="/images/notes/86b326043320bbd1a5d8d05117e1187489c2d15b285e3a773dd4476c23e2dc14.png" alt="Leetcode.com"/><p>We have 2 main routes to take.</p><p>First one is more intuitive, traverse the tree recursively, passing valid ranges and then validating them against the current value:</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
    
    <span class="keyword">return</span> <span class="call">isValidBST</span>(root.<span class="property">left</span>, -<span class="type">Int</span>.<span class="property">max</span>..&lt;root.<span class="property">val</span>) &amp;&amp; <span class="call">isValidBST</span>(root.<span class="property">right</span>, root.<span class="property">val</span>+<span class="number">1</span>..&lt;<span class="type">Int</span>.<span class="property">max</span>)
}

<span class="keyword">private func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?, <span class="keyword">_</span> allowedRange: <span class="type">Range</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
            
    <span class="keyword">if</span> !allowedRange.<span class="call">contains</span>(root.<span class="property">val</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">return</span> <span class="call">isValidBST</span>(root.<span class="property">left</span>, allowedRange.<span class="property">lowerBound</span>..&lt;root.<span class="property">val</span>) &amp;&amp; <span class="call">isValidBST</span>(root.<span class="property">right</span>, root.<span class="property">val</span>+<span class="number">1</span>..&lt;allowedRange.<span class="property">upperBound</span>)
}
</code></pre><p>Using DFS Inorder traversal is a more interesting solution. <code>Left -&gt; Node -&gt; Right</code>. Traversing like this we expect each node to have a larger value if it is a binary search tree.</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">private var</span> previous: <span class="type">Int</span>?

<span class="keyword">func</span> isValidBST(<span class="keyword">_</span> root: <span class="type">TreeNode</span>?) -&gt; <span class="type">Bool</span> {
<span class="keyword">guard let</span> root = root <span class="keyword">else</span> { <span class="keyword">return true</span> }
    
    <span class="comment">// Left</span>
    <span class="keyword">if</span> !<span class="call">isValidBST</span>(root.<span class="property">left</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="comment">// Node</span>
    <span class="keyword">if let</span> previous = previous, previous &gt;= root.<span class="property">val</span> {
        <span class="keyword">return false</span>
    }
    previous = root.<span class="property">val</span>
    
    <span class="comment">// Right</span>
    <span class="keyword">if</span> !<span class="call">isValidBST</span>(root.<span class="property">right</span>) {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">return true</span>
}
</code></pre><h3>Find a successor (next node) in a binary search tree</h3><ul><li>Successor = "after node", i.e. the next node in the inorder traversal, or the smallest node after the current one.</li></ul><ul><li>Predecessor = "before node", i.e. the previous node in the inorder traversal, or the largest node before the current one.</li></ul><p>So to find a successor we either need to go: - One right node and as many left nodes as possible - If no right node exists, go up the tree until the node is the left child of the parent and return the parent</p><h3>Course Schedule</h3><p>Given the list of courses and dependency list of which courses must come before the others, return a list of course order.</p><p>This issue can be solved with DFS with some caveats. <em> We might not have one graph, there might be multiple graphs. So we might need to do multiple DFS until all nodes (courses) have been visited. </em> Once we reach the end of the graph then we add that node to the <strong>beginning</strong> of the course schedule. * If cycles are found, it's impossible to create a schedule. Cycles can be avoided by <strong>visited</strong> and <strong>visiting</strong> (or gray and black) node marking.</p><h3>Lowest Common Ancestor in a Binary Tree of 2 nodes</h3><p>The idea is to do a DFS recursive search throughout the tree. At each point we make 2 recursive calls (to the left and to the right). At the moment where <strong>both</strong> left and right branches result in a node being found, or any of the branches result in a node being found <strong>and</strong> the current node is a node we are looking for, we return a node.</p><pre><code><span class="comment">// O(n), O(n)</span>
<span class="keyword">private func</span> findNode(from node: <span class="type">TreeNode</span>?, to p: <span class="type">TreeNode</span>, orTo q: <span class="type">TreeNode</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">guard let</span> node = node <span class="keyword">else</span> {
        <span class="keyword">return false</span>
    }
    
    <span class="keyword">let</span> left = <span class="call">findNode</span>(from: node.<span class="property">left</span>, to: p, orTo: q) ? <span class="number">1</span> : <span class="number">0</span>
    <span class="keyword">let</span> right = <span class="call">findNode</span>(from: node.<span class="property">right</span>, to: p, orTo: q) ? <span class="number">1</span> : <span class="number">0</span>
    <span class="keyword">let</span> current = node.<span class="property">val</span> == p.<span class="property">val</span> || node.<span class="property">val</span> == q.<span class="property">val</span> ? <span class="number">1</span> : <span class="number">0</span>
    
    <span class="comment">// If any two are correct</span>
    <span class="keyword">if</span> left + right + current &gt;= <span class="number">2</span> {
        ancestor = node
    }
    
    <span class="keyword">return</span> left + right + current &gt; <span class="number">0</span>
}
</code></pre><h1>Additional Information</h1><h2>Spanning Tree</h2><p>A spanning tree is a connected subgraph in an undirected graph where all vertices are connected with the minimum number of edges.</p><p>A minimum spanning tree is a spanning tree with the minimum possible total edge weight in a “weighted undirected graph”.</p><p>Tree - doesn't have cycles</p><p>Cut Property - choosing crossing edge between 2 cuts with the lowest weight</p><h3>Minimum Spanning Tree</h3><p><strong>“Kruskal’s algorithm”</strong> is an algorithm to construct a “minimum spanning tree” of a “weighted undirected graph”. 1) Take all possible edges 2) sort by weight 3) pick one by one if the cycle is not created (!uf.connected).</p><p><strong>Prims Algorithm:</strong> - 1) Pick starting node, see which unvisited node we can visit most cheaply. 2) pick visited nodes, see which unvisited node we can visit most cheaply 3) repeat until all nodes are visited. We need to use min-heap to pick the lowest weighted edge - However, in some cases using min-heap is not effective enough so we need to look ways around it (Min Cost to Connect All Points) as even effective sorting adds log(n) of time complexity.</p><p>Heap is not a Priority Queue, but a way to implement a Priority Queue.</p><p>Heap is a special type of binary tree. Insertion, deletion O(log n). Max, minimum - O(1): - Min Heap. - Max Heap</p><p>BFS - Always find the shortest path first. Finding a path in the grid is a usual task.</p><h2>Single source shortest path problem</h2><p>Edge Relaxation operation is a key in solving the "single source shortest path problem" - If A-D distance is 3, but A-C-D is 2 by performing edge relaxation we note that the distance between A-D is actually 2</p><p><strong>Dijkstra's algorithm</strong>. Can only be used to solve the problem with non-negative weights</p><ul><li>In time complexity we have 2 properties: V - number of vertices and E - number of edges. If we use the Fibonacci heap to extract minimum element total complexity O(E + VlogV). If we use Binary heap time complexity would be O(V+ ElogV).</li><li>Space complexity O(V)</li></ul><p><strong>Steps:</strong> 1. Start at the ending vertex by marking it with a distance of 0 (call it <em>currentVertex</em>) 2. Identify all of the vertices connected to <em>currentVertex</em> with weights. If we already identified vertex, only change weight if a new one is smaller 3. Label <em>currentVertex</em> as visited 4. Find smallest identifier vertice and repeat 2 5. Once labeled a beginning vertex - stop</p><p><strong>Bellman-Ford algorithm</strong>. Can solve with any weights.</p><p>“Bellman-Ford algorithm” is only applicable to “graphs” with no “negative weight cycles”.</p><p>We find a negative cycle if after performing Nth edge relaxation (we normally just need to do N-1) we still find a shorter path.</p><ul><li>Time complexity O(V * E)</li><li>Space complexity O(V)</li></ul><p>Positive Weight Cycle: If during each cycle the path weight increases. The shortest path is after the first cycle</p><p>Negative Weight Cycle: If during each cycle the path weight decreases. There's no shortest path then</p><p><strong>Bellman-Ford:</strong> 1. Have previous and current arrays 2. Each iteration simply set current cost to be minimum of already existing or previous + cost current[destination] = min(current[destination], previous[origin] + cost) 3. At the end of iteration set previous = current</p><p>Essentially, <strong>Bellman-Ford</strong> algorithm is a dynamic programming solution optimized for space and time. If 2 loops in the row we get the same result, we can return it as the shortest path.</p><p>If a question has a constraint of going through k edges, then we just use a dynamic programming approach</p><h2>Dynamic Programming</h2><p><strong>Dynamic Programming (DP)</strong> is an algorithmic technique for solving an optimization problem by breaking it down into simpler subproblems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its subproblems.</p><p>Solving shortest path problem using Dynamic Programming: - Asking: Can I find the shortest path using at most 1 edge? Can I find the shortest path using at most 2 edges, etc until N-1 edges</p><p><strong>Dynamic Programming</strong> 1. Look if the same problem can be split into some smaller problems in a tree structure. Then it means we can solve it using recursion. We need to know the base case to return early from recursion. 2. Make it work brute force way 3. Optimize it using “memoization” (creating dict or set for efficiency)</p></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2022 Povilas Staškus</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a></div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>