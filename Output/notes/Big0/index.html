<!DOCTYPE html><html lang="en"><head><title>Povilas Staškus - Senior iOS Engineer @Automattic</title><meta name="twitter:title" content="Povilas Staškus - Senior iOS Engineer @Automattic"/><meta name="og:title" content="Povilas Staškus - Senior iOS Engineer @Automattic"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/Pure/styles.css"/><link rel="stylesheet" href="/all.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><a class="pure-menu-heading" href="/">staskus.io</a><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/about">About</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/archive">Archive</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/afterWork">After work</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://avatars0.githubusercontent.com/u/4062343?s=460&v=4"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Povilas Staškus</h1><h3 class="brand-tagline">Senior iOS Engineer @Automattic</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="https://en.wikipedia.org/wiki/Vilnius"><i class="fas fa-map-marker-alt l-box social-icon"></i><a class="social-media" href="https://en.wikipedia.org/wiki/Vilnius">Vilnius, Lithuania</a></a></div><div class="pure-u-md-1-1"><a href="mailto:povilas@staskus.io"><i class="fas fa-envelope-open-text l-box social-icon"></i><a class="social-media" href="mailto:povilas@staskus.io">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/povilas-staškus-6b10528b"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/povilas-staškus-6b10528b">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/staskus"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/staskus">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/PovilasStaskus"><i class="fab fa-twitter-square l-box social-icon"></i><a class="social-media" href="https://twitter.com/PovilasStaskus">Twitter</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/notes/Big0">Big O</a></h2><p class="post-meta">Last modified: 2022 December 31</p><div class="post-description"><div><p>Big O describes the efficiency of algorithms.</p><h2>Time Complexity</h2><h2>Space Complexity</h2><p>Space complexity is the amount of memory required by an algorithm.</p><h3>Recursive calls</h3><p>In recursive functions, each call is added to the stack and we take this space into account.</p><h2>Cases</h2><ul><li>Best Case</li><li>Worst Case</li><li>Expected Case</li></ul><p>The best case is not insightful. The expected case and the worst case are usually the same but not always.</p><h2>Simplification</h2><p>Big O is only concerned about the <em>rate of increase</em> and expressed how the runtime scales, thus we can drop the constants and non-dominant terms. O(2N) is just O(N).</p><ul><li>O(N$^2$ + N) is O($N^2$)</li><li>O(N + log N) is O(N)</li><li>O(100*2$^2$ + 5000N$^2$) is O(2$^n$)</li></ul><img src="/images/notes/42d971b30d15ec5efd2f8e1238e39424451afd922a0d719fa83811f80aeaf160.png" alt="Complexities - GeeksForGeeks.org"/><p>However, have in mind that it's usually not possible to remove <em>multiple variables</em>, they still need to be represented in the notation.</p><p>For example, to sort an array of sorted strings the complexity would be <em>O($a</em>s$(log a + log s))*, where a - array length, s - longest string length. In such cases, we cannot simplify much further.</p><h3>O(n)</h3><p>The algorithm that reverses an array only going through half of the array does not impact big O time and still has O(n) time complexity.</p><h3>O(log N)</h3><p>An algorithm will likely have an O(log N) runtime when the number of elements in the problem space gets halved at every step. Example - binary search.</p><h3>O(2$^n$)</h3><p>The base of an exponential complexity matters.</p><h3>O(2$^l$$^o$$^g$$^N$)</h3><p>This expression can be simplified to O(n). If we search binary tree making recursive calls the depth is roughly logN so it doesn't turn the recursive function exponential.</p><h2>Memoization</h2><p>Caching previously computed values is an optimization technique called memoization. It is a very common way to optimize exponential time recursive algorithms.</p></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2023 Povilas Staškus</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a></div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>