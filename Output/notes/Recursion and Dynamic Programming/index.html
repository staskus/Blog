<!DOCTYPE html><html lang="en"><head><title>Povilas Staškus - iOS Developer</title><meta name="twitter:title" content="Povilas Staškus - iOS Developer"/><meta name="og:title" content="Povilas Staškus - iOS Developer"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/Pure/styles.css"/><link rel="stylesheet" href="/all.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><a class="pure-menu-heading" href="/">staskus.io</a><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/about">About</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/archive">Archive</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/afterWork">After work</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://avatars0.githubusercontent.com/u/4062343?s=460&v=4"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Povilas Staškus</h1><h3 class="brand-tagline">iOS Developer</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="https://en.wikipedia.org/wiki/Vilnius"><i class="fas fa-map-marker-alt l-box social-icon"></i><a class="social-media" href="https://en.wikipedia.org/wiki/Vilnius">Vilnius, Lithuania</a></a></div><div class="pure-u-md-1-1"><a href="mailto:povilas@staskus.io"><i class="fas fa-envelope-open-text l-box social-icon"></i><a class="social-media" href="mailto:povilas@staskus.io">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/povilas-staškus-6b10528b"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/povilas-staškus-6b10528b">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/staskus"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/staskus">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/PovilasStaskus"><i class="fab fa-twitter-square l-box social-icon"></i><a class="social-media" href="https://twitter.com/PovilasStaskus">Twitter</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/notes/Recursion and Dynamic Programming">Recursion and Dynamic Programming</a></h2><p class="post-meta">Last modified: 2022 April 28</p><div class="post-description"><div><h2>Recursion</h2><p>Hints for problems that are good candidates for recursion: <em> Compute the nth element to... </em> Write code to list the first n... * Implement a method to compute all...</p><p>Recursive problems are space-intensive and take at least O(n) of memory. The same problems can be solved iteratively although it's usually more complex.</p><h2>Dynamic Programming</h2><p>Dynamic programming is useful when trying to optimize something <strong>given a constraint</strong>. We can use DP when the problem can be broken into subproblems and they don't depend on each other.</p><ol><li>Every DP solution involes a grid</li><li>The values in the grid cells are what we try to optimize</li><li>Each cell is a subproblem</li></ol><p>Approaches: <em> Bottom-Up: Start by solving the most simple case </em> Top-Down: Start with more complex and think about how to split them into subproblems * Half-and-Half: Dividing the data set in half to solve the problem and then merging together the results</p><h2>Example problems</h2><h3>Tribonacci Number</h3><img src="/images/notes/b8daa97dce2af0a8feb01d20e075456e68904da809bc44e9afb26ac5a82ca17e.png" alt="LeetCode.com"/><p>Such a problem can also be solved iteratively. When we use memoization we can notice that we only need to know the last 3 numbers. Instead of saving all the numbers in the dictionary, we can only save the last 3 in the variable:</p><pre><code class="language-swift">// Time - O(n), Space - 0(1)
func tribonacci(_ n: Int) -&gt; Int {
    var memo0 = 0
    var memo1 = 1
    var memo2 = 1
    
    guard n &gt; 0 else { return 0 }
    guard n &gt; 2 else { return 1 }
    
    var temp = 0
    
    for i in 3...n {
        temp = memo0 + memo1 + memo2
        memo0 = memo1
        memo1 = memo2
        memo2 = temp
    }
    
    return temp
}
</code></pre><p>We can also save time instead of space by adding the results into an array before returning the value. This is only applicable if we know the upper bound. Let's say we know that n will be a maximum 40, then we can precompute those 40 values and whenever anyone asks for tribonacci we just return a result.</p><pre><code class="language-swift">// Time - O(1), Space - O(n) 
func tribonacci(_ n: Int) -&gt; Int {
    guard n &gt; 0 else { return 0 }
    guard n &gt; 2 else { return 1 }
    
    var nums: [Int] = [0, 1, 1]
    for i in 3...n {
        nums.append(nums[i-1] + nums[i-2] + nums[i-3])
    } 

    return nums[n]
}
</code></pre><h3>Unique Paths with Obstacles in Grid</h3><p>When starting from (0,0) how many unique paths there are to reach (n-1, n-1) if the path does not encounter obstacles?</p><p>We can use the grid itself as a way to convey information. We first set values of the first column and the first row. If they aren't any obstacles the value is 1, if there're the value is 0. Then we can iterate from the rest of the grid and the value of the cell are the sum of two values from the left and the top. The result at the (n-1, n-1) is the number of unique paths.</p><p>O(M×N), O(1)</p><h3>Divide 2 integers only using addition and subtraction</h3><p>This brute force solution is to do the iteration and sum divisor until we get a number larger than the dividend. This is not efficient.</p><p>The more efficient solution is to use <strong>exponential search</strong> which in spirit is similar to a binary search.</p><h3>Unique permutations with duplicate input</h3><p>If we are given an array of numbers with possible duplications and we need to provide all the possible permutations, we need to start by creating a frequency table of each number (character). This way if we get [1, 1, 1, 1, 1] don't crate duplicating permutations.</p><p>O(n!)</p><h3>Generate Parenthesis</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>This requires a <em>backtracking</em> recursive algorithm. With this concrete issue, the hard part is the calculation of time complexity.</p><p>It's better to know that this is a backtracking algorithm, that has generally a performance O(2^n). In this concrete scenario, we have less complexity, as we don't need to explore all the permutations of parenthesis due to the relationship of closed/opened parenthesis.</p><pre><code class="language-swift">private var max = 0

func generateParenthesis(_ n: Int) -&gt; [String] {****
    max = n
    var result: [String] = []
    backtrack(&amp;result, 0, 0)
    return result
}

private func backtrack(_ result: inout [String],
                        _ opening: Int,
                        _ closing: Int,
                        _ current: String = "") {
                    
    if current.count == max * 2 {
        result.append(current)
        return
    }
    
    if opening &lt; max {
        var current = current
        current.append("(")
        backtrack(&amp;result, opening + 1, closing, current)
    }
    
    if closing &lt; opening {
        var current = current
        current.append(")")
        backtrack(&amp;result, opening, closing + 1, current)
    }
}
</code></pre><h3>Coin Change</h3><p>Given the set of coins (1, 2, 5) in how many ways we can combine it to a given sum (100).</p><p>The trick for a quick solution is this algorithm.</p><p>We calculate the number of combinations for a given amount by adding to it already calculates combinations for x-coin amount <code>combinations[x] += combinations[x - coin]</code>.</p><pre><code class="language-swift">var combinations = Array(repeating: 0, count: amount + 1)
        combinations[0] = 1 // algo requires it
        
        for coin in coins {
            if coin &lt;= amount {
                for x in coin..&lt;amount+1 {
                    combinations[x] += combinations[x - coin]
                }
            }
        }
        
        return combinations[amount]
</code></pre><h3>Coin Change</h3><p>Given the array of coins, return the fewest number of coins that you need to make up that amount.</p><h3>Dynamic Programming - top down approach</h3><p>Use memoization and recursion:</p><pre><code class="language-swift">// Dynamic programming - top down approach
// Time: O(S*n) where S is the amount and n is denomination count
// Space complexity O(s) for memo
func coinChange(_ coins: [Int], _ amount: Int) -&gt; Int {
    var memo: [Int: Int] = [:]
    return coinsChange(coins, amount, &amp;memo)
}

private func coinsChange(_ coins: [Int], _ remaining: Int, _ memo: inout [Int: Int]) -&gt; Int {
    if remaining &lt; 0 { return -1 }
    if remaining == 0 { return 0 }
    
    if let previouslyCalculatedCount = memo[remaining] {
        return previouslyCalculatedCount
    }
    
    var minValue = Int.max
    
    for coin in coins {
        let result = coinsChange(coins, remaining - coin, &amp;memo)
        if result &gt;= 0 &amp;&amp; result &lt; minValue {
            minValue = result + 1
        }
    }
    
    memo[remaining] = minValue == Int.max ? -1 : minValue
    return memo[remaining]!
}
</code></pre><h3>Dynamic Programming - Bottom up approach</h3><p>The key is understanding this line <code>counts[currentAmount] = min(counts[currentAmount], counts[currentAmount - coins[coinIndex]] + 1)</code></p><p>If we get a number not equal to max in <code>counts[currentAmount - coins[coinIndex]]</code> it means that we already calculated a minimum amount and we can just add one coin <code>coin[coinIndex]</code> .</p><pre><code class="language-swift">// Dynamic programming - bottom up approach

func coinChange(_ coins: [Int], _ amount: Int) -&gt; Int {
    guard amount &gt; 0 else { return 0 }
    
    let max = amount + 1
    var counts: [Int] = Array(repeating: max, count: amount + 1)
    counts[0] = 0
    
    for currentAmount in 1...amount {
        for coinIndex in 0..&lt;coins.count {
            if coins[coinIndex] &lt;= currentAmount {
                counts[currentAmount] = min(counts[currentAmount], counts[currentAmount - coins[coinIndex]] + 1)
            }
        }
    }
    
    return counts[amount] == max ? -1 : counts[amount]
}
</code></pre><h3>Optimal Set Of Camping</h3><p>Given list of items:</p><pre><code class="language-swift">let items = [
    Item(name: "Water", weight: 3, value: 10), 
    Item(name: "Book", weight: 1, value: 3), 
    Item(name: "Food", weight: 2, value: 9),
    Item(name: "Jacket", weight: 2, value: 5), 
    Item(name: "Camera", weight: 1, value: 6), 
]
</code></pre><p>and a bag limit of <code>capacity</code>. Find which items to take to maximize the total value.</p><pre><code class="language-swift">struct Item {
    let name: String
    let weight: Int
    let value: Int
}

func optimalSetOfItems(_ capacity: Int, _ items: [Item]) -&gt; [Item] {

    // We need to keep both total values and all items corresponding to the total value
    // We increase the capacity by one, so we wouldn't need to handle a case where we look back at dp table
    var dpItems: [[[Item]]] = Array(repeating: Array(repeating: [], count: capacity + 1), count: items.count + 1)
    var dpValues: [[Int]] = Array(repeating: Array(repeating: 0, count: capacity + 1), count: items.count + 1)

    for itemIndex in 1...items.count {

        // A key to dynamic programming, we iterate through all capacities
        for currentCapacity in 1...capacity {
                let item = items[itemIndex - 1]

                // Skip if an item is heavier than the current capacity
                if item.weight &lt;= currentCapacity {
                    
                    // We already know the best possible value from all the items up to [itemIndex - 1]
                    let totalPreviousValue = dpValues[itemIndex - 1][currentCapacity]

                    // Take current item value
                    // We already know the best possible value for the remaining weight. We calculated it for the previous item
                    // Sum those 2 values
                    let totalPotentialValue = dpValues[itemIndex - 1][currentCapacity - item.weight] + item.value

                    // Check if our new value is larger than the total for the previous item
                    if totalPreviousValue &gt; totalPotentialValue {
                        // If previous value is larger, set the same value and same items
                        dpItems[itemIndex][currentCapacity] = dpItems[itemIndex - 1][currentCapacity]
                        dpValues[itemIndex][currentCapacity] =  totalPreviousValue
                    } else {
                        // Else set new set of items and the new value
                        dpItems[itemIndex][currentCapacity] = dpItems[itemIndex - 1][currentCapacity - item.weight] + [item]
                        dpValues[itemIndex][currentCapacity] = totalPotentialValue
                    }
            }
        }  
    }

    return dpItems[items.count][capacity]
}
</code></pre></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2022 Povilas Staškus</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a></div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>